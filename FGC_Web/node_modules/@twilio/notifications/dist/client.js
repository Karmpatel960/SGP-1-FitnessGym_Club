/*
@license
The MIT License (MIT)

Copyright (c) 2016 Twilio Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('./node_modules/tslib/tslib.es6.js');
var _polyfillNode_events = require('./_virtual/_polyfill-node_events.js');
var twilsock = require('twilsock');
var RegistrarConnector = require('./RegistrarConnector.js');
var TwilsockConnector = require('./TwilsockConnector.js');
var logger = require('./logger.js');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');

var Client_1;
// For validating Connector.ChannelType - keep synchronized!
const channelTypeRule = declarativeTypeValidator.literal("apn", "fcm", "twilsock");
/**
 * @class
 * @alias Notifications
 * @classdesc The helper library for the notification service.
 * Provides high level api for creating and managing notification subscriptions and receiving messages
 * Creates the instance of Notification helper library
 *
 * @constructor
 * @param {string} token - Twilio access token
 * @param {Notifications#ClientOptions} options - Options to customize client behavior
 *
 * @event stateChanged channelType (registered|unregistered) -- coming from connector, i.e. it's per-connector type!
 * @event transportState Forwarded from Twilsock's stateChanged event.
 * @event message Routed from twilsock as a notification event.
 */
exports.Client = Client_1 = class Client extends _polyfillNode_events['default'] {
    constructor(token, options = {}) {
        var _a, _b, _c, _d, _e, _f;
        super();
        options.logLevel = (_a = options.logLevel) !== null && _a !== void 0 ? _a : "error";
        logger.log.setLevel(options.logLevel);
        const productId = (_b = options.productId) !== null && _b !== void 0 ? _b : "notifications";
        const startTwilsock = !options.twilsockClient;
        const twilsock$1 = (options.twilsockClient =
            (_c = options.twilsockClient) !== null && _c !== void 0 ? _c : new twilsock.TwilsockClient(token, productId, options));
        const config = (_d = options.notifications) !== null && _d !== void 0 ? _d : {};
        const region = (_f = (_e = config.region) !== null && _e !== void 0 ? _e : options.region) !== null && _f !== void 0 ? _f : "us1";
        const defaultUrl = `https://ers.${region}.twilio.com/v1/registrations`;
        const registrarUrl = config.ersUrl || defaultUrl;
        this.connectors = new Map();
        const platform = Client_1._detectPlatform();
        this.connectors.set("apn", new RegistrarConnector.RegistrarConnector("apn", { protocolVersion: 4, productId, platform }, twilsock$1, registrarUrl));
        this.connectors.set("fcm", new RegistrarConnector.RegistrarConnector("fcm", { protocolVersion: 3, productId, platform }, twilsock$1, registrarUrl));
        this.connectors.set("twilsock", new TwilsockConnector.TwilsockConnector(productId, platform, twilsock$1));
        twilsock$1.on("stateChanged", (state) => this.emit("transportState", state));
        this._connector("twilsock").on("stateChanged", (type, value, state) => this.emit("stateChanged", type, value, state));
        this._connector("apn").on("stateChanged", (type, value, state) => this.emit("stateChanged", type, value, state));
        this._connector("fcm").on("stateChanged", (type, value, state) => this.emit("stateChanged", type, value, state));
        // Router
        twilsock$1.on("message", (type, message) => this._routeMessage(type, message));
        this.updateToken(token);
        // Start only if we created twilsock locally,
        // otherwise it's the responsibility of whoever created the Twilsock client.
        if (startTwilsock) {
            twilsock$1.connect();
            this.twilsock = twilsock$1;
        }
    }
    async shutdown() {
        this.connectors.clear();
        if (this.twilsock) {
            await this.twilsock.disconnect();
        }
    }
    /**
     * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.
     *
     * You must call this function once you've received the ID of your device from the underlying OS.
     *
     * @param {ChannelType} channelType Channel type ('apn'/'fcm').
     * @param {string} pushRegistrationId Token received from FCM/APNS system on device.
     */
    setPushRegistrationId(channelType, pushRegistrationId) {
        logger.log.debug(`Set ${channelType} push registration id '${pushRegistrationId}'`);
        this._connector(channelType).setNotificationId(pushRegistrationId);
    }
    /**
     * Subscribe to a given message type for a given channel type.
     *
     * Creates a subscriptions to receive incoming messages according to message type.
     * Subscription establishes a binding and you will receive a signal when a notification
     * of this type has been received by the library.
     *
     * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.
     * This is the responsibility of the client SDK.
     *
     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
     * @param {string} messageType The type of message that you want to receive
     */
    subscribe(channelType, messageType) {
        logger.log.debug(`Add ${channelType} subscriptions for message type ${messageType}`);
        this._connector(channelType).subscribe(messageType);
    }
    /**
     * Unsubscribe from a given message type.
     *
     * Unsubscribing breaks a binding and you will not receive more notifications for this message type.
     * Please note that you have to call commitChanges() and receive a successful result before
     * the subscription is actually removed.
     *
     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
     * @param {string} messageType The type of message that you don't want to receive anymore
     */
    unsubscribe(channelType, messageType) {
        logger.log.debug(`Remove ${channelType} subscriptions for message type ${messageType}`);
        this._connector(channelType).unsubscribe(messageType);
    }
    /**
     * Update subscription token. You must update the token when the old one expires.
     *
     * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed
     * token _after_ you have updated twilsock and other associated objects with the new token.
     *
     * @param {string} token Authentication token for registrations
     */
    updateToken(token) {
        this.connectors.forEach((connector) => connector.updateToken(token));
    }
    /**
     * Commit all collected subscription changes as a batched update. This function tries to reduce
     * number of network calls necessary to update bindings status.
     */
    async commitChanges() {
        const promises = [];
        this.connectors.forEach((connector) => {
            if (connector.isActive()) {
                promises.push(connector.commitChanges());
            }
        });
        await Promise.all(promises);
    }
    /**
     * Clear existing registrations directly using provided device token.
     * This is useful to ensure stopped subscriptions without resubscribing.
     *
     * This function goes completely beside the state machine and removes all registrations.
     * Use with caution: if it races with current state machine operations, madness will ensue.
     *
     * @param {ChannelType} channelType Channel type ('apn'/'fcm').
     * @param {string} registrationId Token received from FCM/APNS system on device.
     */
    async removeRegistrations(channelType, registrationId) {
        await this._connector(channelType).sendDeviceRemoveRequest(registrationId);
    }
    /**
     * Handle incoming push notification.
     * Client application should call this method when it receives push notifications and pass the received data.
     * @param {Object} message push message
     * @return {PushNotification} A reformatted payload with extracted message type.
     */
    handlePushNotification(message) {
        return {
            messageType: message.twi_message_type,
            payload: message.payload,
        };
    }
    /**
     * Routes messages to the external subscribers
     */
    _routeMessage(type, message) {
        logger.log.debug("Notification message arrived: ", type, message);
        this.emit("message", type, message);
    }
    /**
     * @param {String} type Channel type
     * @throws {Error} Error with description
     */
    _connector(type) {
        const connector = this.connectors.get(type);
        if (!connector) {
            throw new Error(`Unknown channel type: ${type}`);
        }
        return connector;
    }
    /**
     * Returns platform string limited to max 128 chars
     */
    static _detectPlatform() {
        let platform = "";
        if (typeof navigator !== "undefined") {
            platform = "unknown";
            if (typeof navigator.product !== "undefined") {
                platform = navigator.product;
            }
            if (typeof navigator.userAgent !== "undefined") {
                platform = navigator.userAgent;
            }
        }
        else {
            platform = "web";
        }
        return platform.substring(0, 128);
    }
};
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String, String]),
    tslib_es6.__metadata("design:returntype", void 0)
], exports.Client.prototype, "setPushRegistrationId", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String, String]),
    tslib_es6.__metadata("design:returntype", void 0)
], exports.Client.prototype, "subscribe", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String, String]),
    tslib_es6.__metadata("design:returntype", void 0)
], exports.Client.prototype, "unsubscribe", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", void 0)
], exports.Client.prototype, "updateToken", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(channelTypeRule, declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String, String]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "removeRegistrations", null);
exports.Client = Client_1 = tslib_es6.__decorate([
    declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [
        declarativeTypeValidator.pureObject,
        "undefined",
        declarativeTypeValidator.literal(null),
    ]),
    tslib_es6.__metadata("design:paramtypes", [String, Object])
], exports.Client);
//# sourceMappingURL=client.js.map
