{"version":3,"file":"client.js","sources":["../src/client.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { TwilsockClient, ConnectionState } from \"twilsock\";\nimport { Connector, ChannelType } from \"./connector\";\nimport { RegistrarConnector } from \"./RegistrarConnector\";\nimport { TwilsockConnector } from \"./TwilsockConnector\";\nimport { log } from \"./logger\";\nimport {\n  validateTypesAsync,\n  validateTypes,\n  literal,\n  nonEmptyString,\n  validateConstructorTypes,\n  pureObject,\n} from \"@twilio/declarative-type-validator\";\nimport { LogLevelDesc } from \"loglevel\";\n\n// For validating Connector.ChannelType - keep synchronized!\nconst channelTypeRule = literal(\"apn\", \"fcm\", \"twilsock\");\n\ninterface PushNotification {\n  messageType: string;\n  payload: any;\n}\n\ninterface NotificationOptions {\n  region?: string;\n  ersUrl?: string;\n}\n\ninterface ClientOptions {\n  logLevel?: LogLevelDesc;\n  minTokenRefreshInterval?: number;\n  productId?: string;\n  twilsockClient?: TwilsockClient;\n  notifications?: NotificationOptions;\n  region?: string;\n}\n\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n *\n * @event stateChanged channelType (registered|unregistered) -- coming from connector, i.e. it's per-connector type!\n * @event transportState Forwarded from Twilsock's stateChanged event.\n * @event message Routed from twilsock as a notification event.\n */\n@validateConstructorTypes(nonEmptyString, [\n  pureObject,\n  \"undefined\",\n  literal(null),\n])\nclass Client extends EventEmitter {\n  private readonly twilsock?: TwilsockClient;\n  private readonly connectors: Map<ChannelType, Connector>;\n\n  constructor(token: string, options: ClientOptions = {}) {\n    super();\n\n    options.logLevel = options.logLevel ?? \"error\";\n    log.setLevel(options.logLevel);\n\n    const productId = options.productId ?? \"notifications\";\n\n    const startTwilsock = !options.twilsockClient;\n\n    const twilsock = (options.twilsockClient =\n      options.twilsockClient ?? new TwilsockClient(token, productId, options));\n\n    const config = options.notifications ?? {};\n    const region = config.region ?? options.region ?? \"us1\";\n    const defaultUrl = `https://ers.${region}.twilio.com/v1/registrations`;\n    const registrarUrl = config.ersUrl || defaultUrl;\n\n    this.connectors = new Map<ChannelType, Connector>();\n\n    const platform = Client._detectPlatform();\n\n    this.connectors.set(\n      \"apn\",\n      new RegistrarConnector(\n        \"apn\",\n        { protocolVersion: 4, productId, platform },\n        twilsock,\n        registrarUrl\n      )\n    );\n    this.connectors.set(\n      \"fcm\",\n      new RegistrarConnector(\n        \"fcm\",\n        { protocolVersion: 3, productId, platform },\n        twilsock,\n        registrarUrl\n      )\n    );\n    this.connectors.set(\n      \"twilsock\",\n      new TwilsockConnector(productId, platform, twilsock)\n    );\n\n    twilsock.on(\"stateChanged\", (state) => this.emit(\"transportState\", state));\n\n    this._connector(\"twilsock\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n    this._connector(\"apn\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n    this._connector(\"fcm\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n\n    // Router\n    twilsock.on(\"message\", (type, message) =>\n      this._routeMessage(type, message)\n    );\n\n    this.updateToken(token);\n\n    // Start only if we created twilsock locally,\n    // otherwise it's the responsibility of whoever created the Twilsock client.\n    if (startTwilsock) {\n      twilsock.connect();\n      this.twilsock = twilsock;\n    }\n  }\n\n  public async shutdown(): Promise<void> {\n    this.connectors.clear();\n    if (this.twilsock) {\n      await this.twilsock.disconnect();\n    }\n  }\n\n  /**\n   * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.\n   *\n   * You must call this function once you've received the ID of your device from the underlying OS.\n   *\n   * @param {ChannelType} channelType Channel type ('apn'/'fcm').\n   * @param {string} pushRegistrationId Token received from FCM/APNS system on device.\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public setPushRegistrationId(\n    channelType: ChannelType,\n    pushRegistrationId: string\n  ): void {\n    log.debug(\n      `Set ${channelType} push registration id '${pushRegistrationId}'`\n    );\n    this._connector(channelType).setNotificationId(pushRegistrationId);\n  }\n\n  /**\n   * Subscribe to a given message type for a given channel type.\n   *\n   * Creates a subscriptions to receive incoming messages according to message type.\n   * Subscription establishes a binding and you will receive a signal when a notification\n   * of this type has been received by the library.\n   *\n   * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.\n   * This is the responsibility of the client SDK.\n   *\n   * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'\n   * @param {string} messageType The type of message that you want to receive\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public subscribe(channelType: ChannelType, messageType: string): void {\n    log.debug(\n      `Add ${channelType} subscriptions for message type ${messageType}`\n    );\n    this._connector(channelType).subscribe(messageType);\n  }\n\n  /**\n   * Unsubscribe from a given message type.\n   *\n   * Unsubscribing breaks a binding and you will not receive more notifications for this message type.\n   * Please note that you have to call commitChanges() and receive a successful result before\n   * the subscription is actually removed.\n   *\n   * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'\n   * @param {string} messageType The type of message that you don't want to receive anymore\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public unsubscribe(channelType: ChannelType, messageType: string): void {\n    log.debug(\n      `Remove ${channelType} subscriptions for message type ${messageType}`\n    );\n    this._connector(channelType).unsubscribe(messageType);\n  }\n\n  /**\n   * Update subscription token. You must update the token when the old one expires.\n   *\n   * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed\n   * token _after_ you have updated twilsock and other associated objects with the new token.\n   *\n   * @param {string} token Authentication token for registrations\n   */\n  @validateTypes(nonEmptyString)\n  public updateToken(token: string): void {\n    this.connectors.forEach((connector) => connector.updateToken(token));\n  }\n\n  /**\n   * Commit all collected subscription changes as a batched update. This function tries to reduce\n   * number of network calls necessary to update bindings status.\n   */\n  public async commitChanges(): Promise<void> {\n    const promises: Promise<void>[] = [];\n    this.connectors.forEach((connector) => {\n      if (connector.isActive()) {\n        promises.push(connector.commitChanges());\n      }\n    });\n    await Promise.all(promises);\n  }\n\n  /**\n   * Clear existing registrations directly using provided device token.\n   * This is useful to ensure stopped subscriptions without resubscribing.\n   *\n   * This function goes completely beside the state machine and removes all registrations.\n   * Use with caution: if it races with current state machine operations, madness will ensue.\n   *\n   * @param {ChannelType} channelType Channel type ('apn'/'fcm').\n   * @param {string} registrationId Token received from FCM/APNS system on device.\n   */\n  @validateTypesAsync(channelTypeRule, nonEmptyString)\n  public async removeRegistrations(\n    channelType: ChannelType,\n    registrationId: string\n  ): Promise<void> {\n    await this._connector(channelType).sendDeviceRemoveRequest(registrationId);\n  }\n\n  /**\n   * Handle incoming push notification.\n   * Client application should call this method when it receives push notifications and pass the received data.\n   * @param {Object} message push message\n   * @return {PushNotification} A reformatted payload with extracted message type.\n   */\n  public handlePushNotification(message: any): PushNotification {\n    return {\n      messageType: message.twi_message_type,\n      payload: message.payload,\n    };\n  }\n\n  /**\n   * Routes messages to the external subscribers\n   */\n  private _routeMessage(type: string, message: string): void {\n    log.debug(\"Notification message arrived: \", type, message);\n    this.emit(\"message\", type, message);\n  }\n\n  /**\n   * @param {String} type Channel type\n   * @throws {Error} Error with description\n   */\n  private _connector(type: ChannelType): Connector {\n    const connector = this.connectors.get(type);\n    if (!connector) {\n      throw new Error(`Unknown channel type: ${type}`);\n    }\n    return connector;\n  }\n\n  /**\n   * Returns platform string limited to max 128 chars\n   */\n  private static _detectPlatform(): string {\n    let platform = \"\";\n    if (typeof navigator !== \"undefined\") {\n      platform = \"unknown\";\n      if (typeof navigator.product !== \"undefined\") {\n        platform = navigator.product;\n      }\n      if (typeof navigator.userAgent !== \"undefined\") {\n        platform = navigator.userAgent;\n      }\n    } else {\n      platform = \"web\";\n    }\n\n    return platform.substring(0, 128);\n  }\n}\n\n/**\n * @event Client#message\n * Fired when a new notification message arrives.\n * @param {string} type Message type\n * @param {Object} message Message payload\n */\n\n/**\n * @event Client#stateChanged\n * Fired when the registration state changes.\n * @param {ChannelType} type Type of channel\n * @param {string} status Status of registration (registered/unregistered)\n * @param {Object} state Registration state details\n *                       (token, notificationId, currently subscribed types)\n */\n\n/**\n * @event Client#transportState\n * Fired when the twilsock connection state changes.\n * @param {string} state New transport state. Coming directly from Twilsock#ConnectionState.\n */\n\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */\n\nexport { ChannelType, ConnectionState, PushNotification, Client };\n"],"names":["literal","Client","EventEmitter","log","twilsock","TwilsockClient","RegistrarConnector","TwilsockConnector","__decorate","validateTypes","nonEmptyString","validateTypesAsync","validateConstructorTypes","pureObject"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AACA,MAAM,eAAe,GAAGA,gCAAO,CAAC,KAAK,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;AAqB1D;;;;;;;;;;;;;;;AAoBMC,cAAM,cAAZ,MAAM,MAAO,SAAQC,+BAAY;IAI/B,YAAY,KAAa,EAAE,UAAyB,EAAE;;QACpD,KAAK,EAAE,CAAC;QAER,OAAO,CAAC,QAAQ,GAAG,MAAA,OAAO,CAAC,QAAQ,mCAAI,OAAO,CAAC;QAC/CC,UAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAE/B,MAAM,SAAS,GAAG,MAAA,OAAO,CAAC,SAAS,mCAAI,eAAe,CAAC;QAEvD,MAAM,aAAa,GAAG,CAAC,OAAO,CAAC,cAAc,CAAC;QAE9C,MAAMC,UAAQ,IAAI,OAAO,CAAC,cAAc;YACtC,MAAA,OAAO,CAAC,cAAc,mCAAI,IAAIC,uBAAc,CAAC,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;QAE3E,MAAM,MAAM,GAAG,MAAA,OAAO,CAAC,aAAa,mCAAI,EAAE,CAAC;QAC3C,MAAM,MAAM,GAAG,MAAA,MAAA,MAAM,CAAC,MAAM,mCAAI,OAAO,CAAC,MAAM,mCAAI,KAAK,CAAC;QACxD,MAAM,UAAU,GAAG,eAAe,MAAM,8BAA8B,CAAC;QACvE,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,IAAI,UAAU,CAAC;QAEjD,IAAI,CAAC,UAAU,GAAG,IAAI,GAAG,EAA0B,CAAC;QAEpD,MAAM,QAAQ,GAAG,QAAM,CAAC,eAAe,EAAE,CAAC;QAE1C,IAAI,CAAC,UAAU,CAAC,GAAG,CACjB,KAAK,EACL,IAAIC,qCAAkB,CACpB,KAAK,EACL,EAAE,eAAe,EAAE,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,EAC3CF,UAAQ,EACR,YAAY,CACb,CACF,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,GAAG,CACjB,KAAK,EACL,IAAIE,qCAAkB,CACpB,KAAK,EACL,EAAE,eAAe,EAAE,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,EAC3CF,UAAQ,EACR,YAAY,CACb,CACF,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,GAAG,CACjB,UAAU,EACV,IAAIG,mCAAiB,CAAC,SAAS,EAAE,QAAQ,EAAEH,UAAQ,CAAC,CACrD,CAAC;QAEFA,UAAQ,CAAC,EAAE,CAAC,cAAc,EAAE,CAAC,KAAK,KAAK,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,KAAK,CAAC,CAAC,CAAC;QAE3E,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,cAAc,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,KAChE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAC9C,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,cAAc,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,KAC3D,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAC9C,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,cAAc,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,KAC3D,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAC9C,CAAC;;QAGFA,UAAQ,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,IAAI,EAAE,OAAO,KACnC,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,OAAO,CAAC,CAClC,CAAC;QAEF,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;;;QAIxB,IAAI,aAAa,EAAE;YACjBA,UAAQ,CAAC,OAAO,EAAE,CAAC;YACnB,IAAI,CAAC,QAAQ,GAAGA,UAAQ,CAAC;SAC1B;KACF;IAEM,MAAM,QAAQ;QACnB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACxB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC;SAClC;KACF;;;;;;;;;IAWM,qBAAqB,CAC1B,WAAwB,EACxB,kBAA0B;QAE1BD,UAAG,CAAC,KAAK,CACP,OAAO,WAAW,0BAA0B,kBAAkB,GAAG,CAClE,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,CAAC;KACpE;;;;;;;;;;;;;;IAgBM,SAAS,CAAC,WAAwB,EAAE,WAAmB;QAC5DA,UAAG,CAAC,KAAK,CACP,OAAO,WAAW,mCAAmC,WAAW,EAAE,CACnE,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;KACrD;;;;;;;;;;;IAaM,WAAW,CAAC,WAAwB,EAAE,WAAmB;QAC9DA,UAAG,CAAC,KAAK,CACP,UAAU,WAAW,mCAAmC,WAAW,EAAE,CACtE,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;KACvD;;;;;;;;;IAWM,WAAW,CAAC,KAAa;QAC9B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;KACtE;;;;;IAMM,MAAM,aAAa;QACxB,MAAM,QAAQ,GAAoB,EAAE,CAAC;QACrC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS;YAChC,IAAI,SAAS,CAAC,QAAQ,EAAE,EAAE;gBACxB,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,aAAa,EAAE,CAAC,CAAC;aAC1C;SACF,CAAC,CAAC;QACH,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;KAC7B;;;;;;;;;;;IAaM,MAAM,mBAAmB,CAC9B,WAAwB,EACxB,cAAsB;QAEtB,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,uBAAuB,CAAC,cAAc,CAAC,CAAC;KAC5E;;;;;;;IAQM,sBAAsB,CAAC,OAAY;QACxC,OAAO;YACL,WAAW,EAAE,OAAO,CAAC,gBAAgB;YACrC,OAAO,EAAE,OAAO,CAAC,OAAO;SACzB,CAAC;KACH;;;;IAKO,aAAa,CAAC,IAAY,EAAE,OAAe;QACjDA,UAAG,CAAC,KAAK,CAAC,gCAAgC,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;QAC3D,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;KACrC;;;;;IAMO,UAAU,CAAC,IAAiB;QAClC,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC5C,IAAI,CAAC,SAAS,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,EAAE,CAAC,CAAC;SAClD;QACD,OAAO,SAAS,CAAC;KAClB;;;;IAKO,OAAO,eAAe;QAC5B,IAAI,QAAQ,GAAG,EAAE,CAAC;QAClB,IAAI,OAAO,SAAS,KAAK,WAAW,EAAE;YACpC,QAAQ,GAAG,SAAS,CAAC;YACrB,IAAI,OAAO,SAAS,CAAC,OAAO,KAAK,WAAW,EAAE;gBAC5C,QAAQ,GAAG,SAAS,CAAC,OAAO,CAAC;aAC9B;YACD,IAAI,OAAO,SAAS,CAAC,SAAS,KAAK,WAAW,EAAE;gBAC9C,QAAQ,GAAG,SAAS,CAAC,SAAS,CAAC;aAChC;SACF;aAAM;YACL,QAAQ,GAAG,KAAK,CAAC;SAClB;QAED,OAAO,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;KACnC;EACF;AAlJCK;IADCC,sCAAa,CAAC,eAAe,EAAEC,uCAAc,CAAC;;;;2DAS9C;AAgBDF;IADCC,sCAAa,CAAC,eAAe,EAAEC,uCAAc,CAAC;;;;+CAM9C;AAaDF;IADCC,sCAAa,CAAC,eAAe,EAAEC,uCAAc,CAAC;;;;iDAM9C;AAWDF;IADCC,sCAAa,CAACC,uCAAc,CAAC;;;;iDAG7B;AA2BDF;IADCG,2CAAkB,CAAC,eAAe,EAAED,uCAAc,CAAC;;;;yDAMnD;AAxLGT,cAAM;IALXW,iDAAwB,CAACF,uCAAc,EAAE;QACxCG,mCAAU;QACV,WAAW;QACXb,gCAAO,CAAC,IAAI,CAAC;KACd,CAAC;;GACIC,cAAM,CA8OX;;"}