/*
@license
The MIT License (MIT)

Copyright (c) 2016 Twilio Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('core-js/modules/es.reflect.construct.js');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _inherits = require('@babel/runtime/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/es.map.js');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.string.iterator.js');
require('core-js/modules/web.dom-collections.iterator.js');
require('core-js/modules/es.array.concat.js');
require('core-js/modules/web.dom-collections.for-each.js');
require('core-js/modules/es.promise.js');
var _typeof = require('@babel/runtime/helpers/typeof');
var twilsock = require('twilsock');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
require('core-js/modules/es.regexp.to-string.js');
require('core-js/modules/es.array.from.js');
require('core-js/modules/es.object.assign.js');
var operationRetrier = require('@twilio/operation-retrier');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
require('core-js/modules/es.set.js');
require('core-js/modules/es.array.filter.js');
var logger = require('loglevel');
var uuid = require('uuid');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var logger__namespace = /*#__PURE__*/_interopNamespace(logger);
var uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default['default'](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default['default'](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

var log = logger__namespace.getLogger("twilio-notificatiions");

function prepareLine(prefix, args) {
  return ["".concat(new Date().toISOString(), " Twilio.Notifications ").concat(prefix, ":")].concat(Array.from(args));
}

var Logger = /*#__PURE__*/function () {
  function Logger() {
    _classCallCheck__default['default'](this, Logger);
  }

  _createClass__default['default'](Logger, [{
    key: "setLevel",
    value: function setLevel(level) {
      log.setLevel(level);
    }
  }, {
    key: "trace",
    value: function trace() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      log.trace.apply(null, prepareLine("T", args));
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      log.debug.apply(null, prepareLine("D", args));
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      log.info.apply(null, prepareLine("I", args));
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      log.warn.apply(null, prepareLine("W", args));
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      log.error.apply(null, prepareLine("E", args));
    }
  }]);

  return Logger;
}();

var logInstance = new Logger();

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var RegistrationState = function RegistrationState() {
  var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  var notificationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var messageTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();

  _classCallCheck__default['default'](this, RegistrationState);

  this.token = token;
  this.notificationId = notificationId;
  this.messageTypes = messageTypes;
};

function setDifference(a, b) {
  return [].concat(_toConsumableArray__default['default'](_toConsumableArray__default['default'](a).filter(function (x) {
    return !b.has(x);
  })), _toConsumableArray__default['default'](_toConsumableArray__default['default'](b).filter(function (x) {
    return !a.has(x);
  })));
}

function hasDifference(a, b) {
  var reasons = new Set();

  if (a.notificationId !== b.notificationId) {
    reasons.add("notificationId");
  }

  if (a.token !== b.token) {
    reasons.add("token");
  }

  if (setDifference(a.messageTypes, b.messageTypes).length > 0) {
    reasons.add("messageType");
  }

  return [reasons.size > 0, reasons];
}

var Connector = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](Connector, _EventEmitter);

  var _super = _createSuper$3(Connector);

  // @todo replace with FSM
  function Connector(channelType) {
    var _this;

    _classCallCheck__default['default'](this, Connector);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "desiredState", new RegistrationState());

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "currentState", new RegistrationState());

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_hasActiveAttempt", false);

    _this.channelType = channelType;
    return _this;
  }
  /**
   * Set desired notification ID for the registration.
   * Call commitChanges() afterwards to commit this change.
   * @param notificationId Notification context ID to register.
   */


  _createClass__default['default'](Connector, [{
    key: "setNotificationId",
    value: function setNotificationId(notificationId) {
      this.desiredState.notificationId = notificationId;
    }
    /**
     * Return true is this connector is in usable state and should be able to commit changes.
     */

  }, {
    key: "isActive",
    value: function isActive() {
      return this.desiredState.notificationId !== "";
    }
  }, {
    key: "subscribe",
    value: function subscribe(messageType) {
      if (this.desiredState.messageTypes.has(messageType)) {
        logInstance.debug("message type '".concat(messageType, "' for channel ").concat(this.channelType, " is already registered"));
        return;
      }

      this.desiredState.messageTypes.add(messageType);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(messageType) {
      if (!this.desiredState.messageTypes.has(messageType)) {
        return;
      }

      this.desiredState.messageTypes.delete(messageType);
    }
  }, {
    key: "updateToken",
    value: function updateToken(token) {
      // @todo not entirely correct?
      this.desiredState.token = token;
    }
    /**
     * Perform actual registration after all required changes are settled.
     */

  }, {
    key: "commitChanges",
    value: function () {
      var _commitChanges = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        var _hasDifference, _hasDifference2, needToUpdate, reasons, stateToPersist, persistedState;

        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._hasActiveAttempt) {
                  _context.next = 3;
                  break;
                }

                // Concurrent access violation
                logInstance.error("One registration attempt is already in progress");
                throw new Error("One registration attempt is already in progress");

              case 3:
                _hasDifference = hasDifference(this.desiredState, this.currentState), _hasDifference2 = _slicedToArray__default['default'](_hasDifference, 2), needToUpdate = _hasDifference2[0], reasons = _hasDifference2[1];

                if (needToUpdate) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return");

              case 6:
                if (!this.currentState.notificationId) {
                  reasons.delete("notificationId");
                }

                logInstance.trace("Persisting ".concat(this.channelType, " registration"), reasons, this.desiredState);
                _context.prev = 8;
                this._hasActiveAttempt = true;
                stateToPersist = new RegistrationState();
                stateToPersist.token = this.desiredState.token;
                stateToPersist.notificationId = this.desiredState.notificationId;
                stateToPersist.messageTypes = new Set(this.desiredState.messageTypes);

                if (!(stateToPersist.messageTypes.size > 0)) {
                  _context.next = 24;
                  break;
                }

                _context.next = 17;
                return this.updateRegistration(stateToPersist, reasons);

              case 17:
                persistedState = _context.sent;
                this.currentState.token = persistedState.token;
                this.currentState.notificationId = persistedState.notificationId;
                this.currentState.messageTypes = new Set(persistedState.messageTypes); // @todo twilsock emits registered(notificationContextId) when this context is reg'd

                this.emit("stateChanged", this.channelType, "registered", this.currentState);
                _context.next = 30;
                break;

              case 24:
                _context.next = 26;
                return this.removeRegistration();

              case 26:
                this.currentState.token = stateToPersist.token;
                this.currentState.notificationId = stateToPersist.notificationId;
                this.currentState.messageTypes.clear();
                this.emit("stateChanged", this.channelType, "unregistered", this.currentState);

              case 30:
                _context.next = 35;
                break;

              case 32:
                _context.prev = 32;
                _context.t0 = _context["catch"](8);
                throw _context.t0;

              case 35:
                _context.prev = 35;
                this._hasActiveAttempt = false;
                return _context.finish(35);

              case 38:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[8, 32, 35, 38]]);
      }));

      function commitChanges() {
        return _commitChanges.apply(this, arguments);
      }

      return commitChanges;
    }()
  }]);

  return Connector;
}(EventEmitter);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var retrierConfig = {
  min: 2000,
  max: 120000,
  randomness: 0.2
};
/**
 * Manages the registrations on ERS service.
 * Deduplicates registrations and manages them automatically.
 */

var RegistrarConnector = /*#__PURE__*/function (_Connector) {
  _inherits__default['default'](RegistrarConnector, _Connector);

  var _super = _createSuper$2(RegistrarConnector);

  /**
   * Creates new instance of the ERS registrar
   *
   * @param channelType {string} Channel this connector will be servicing.
   * @param context {any} productId, platform, and protocolVersion.
   * @param twilsock {TwilsockClient} connection transport.
   * @param registrarUrl {string}
   */
  function RegistrarConnector(channelType, context, // context is separate from config because it's not shared with other connectors
  twilsock, registrarUrl) {
    var _this;

    _classCallCheck__default['default'](this, RegistrarConnector);

    _this = _super.call(this, channelType);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "registrationId", null);

    _this.context = context;
    _this.twilsock = twilsock;
    _this.registrarUrl = registrarUrl;
    return _this;
  }

  _createClass__default['default'](RegistrarConnector, [{
    key: "updateRegistration",
    value: function () {
      var _updateRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(registration, reasons) {
        var _this2 = this;

        var registrarRequest, productId, url, headers, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!reasons.has("notificationId")) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return this.removeRegistration();

              case 3:
                if (!(!registration.notificationId || !registration.notificationId.length)) {
                  _context.next = 6;
                  break;
                }

                logInstance.error("No push notification ID for registration");
                throw new Error("No push notification ID for registration");

              case 6:
                logInstance.trace("Registering", this.channelType, registration);
                registrarRequest = {
                  endpoint_platform: this.context.platform,
                  channel_type: this.channelType,
                  version: this.context.protocolVersion.toString(),
                  message_types: Array.from(registration.messageTypes),
                  data: {
                    registration_id: registration.notificationId
                  } //ttl: 'PT24H' - This is totally ignored by notify, all bindings use PT1Y ttl.

                };
                productId = this.context.productId;
                url = "".concat(this.registrarUrl, "?productId=").concat(productId);
                headers = {
                  "Content-Type": "application/json" // 'X-Twilio-Token': registration.token

                };
                logInstance.trace("Creating registration for channel ".concat(this.channelType));
                _context.prev = 12;
                _context.next = 15;
                return new operationRetrier.AsyncRetrier(retrierConfig).run(function () {
                  return _this2.twilsock.post(url, headers, registrarRequest, productId);
                });

              case 15:
                response = _context.sent;
                this.registrationId = response.body.id;
                logInstance.debug("Registration created: ", response);
                _context.next = 24;
                break;

              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](12);
                logInstance.error("Registration failed: ", _context.t0);
                throw _context.t0;

              case 24:
                return _context.abrupt("return", registration);

              case 25:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[12, 20]]);
      }));

      function updateRegistration(_x, _x2) {
        return _updateRegistration.apply(this, arguments);
      }

      return updateRegistration;
    }()
  }, {
    key: "removeRegistration",
    value: function () {
      var _removeRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        var _this3 = this;

        var productId, url, headers;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.registrationId) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                productId = this.context.productId;
                url = "".concat(this.registrarUrl, "/").concat(this.registrationId, "?productId=").concat(productId);
                headers = {
                  "Content-Type": "application/json" // 'X-Twilio-Token': this.config.token

                };
                logInstance.trace("Removing registration for ".concat(this.channelType));
                _context2.prev = 6;
                _context2.next = 9;
                return new operationRetrier.AsyncRetrier(Object.assign(retrierConfig, {
                  maxAttemptsCount: 3
                })).run(function () {
                  return _this3.twilsock.delete(url, headers, {}, productId);
                });

              case 9:
                this.registrationId = null;
                this.currentState.notificationId = "";
                logInstance.debug("Registration removed for ".concat(this.channelType));
                _context2.next = 18;
                break;

              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](6);
                logInstance.error("Failed to remove registration ", this.channelType, _context2.t0);
                throw _context2.t0;

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 14]]);
      }));

      function removeRegistration() {
        return _removeRegistration.apply(this, arguments);
      }

      return removeRegistration;
    }()
  }, {
    key: "sendDeviceRemoveRequest",
    value: function () {
      var _sendDeviceRemoveRequest = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(registrationId) {
        var _this4 = this;

        var productId, url, headers, payload;
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(registrationId === "")) {
                  _context3.next = 2;
                  break;
                }

                throw new Error("Empty registration ID");

              case 2:
                productId = this.context.productId;
                url = "".concat(this.registrarUrl, "?productId=").concat(productId);
                headers = {
                  "Content-Type": "application/json" // @todo Content-Length??

                };
                payload = {
                  binding_type: this.channelType,
                  address: registrationId
                };
                _context3.prev = 6;
                logInstance.trace("Removing old registrations for ".concat(this.channelType));
                _context3.next = 10;
                return new operationRetrier.AsyncRetrier(Object.assign(retrierConfig, {
                  maxAttemptsCount: 3
                })).run(function () {
                  return _this4.twilsock.delete(url, headers, payload, productId);
                });

              case 10:
                this.registrationId = null;
                this.currentState.notificationId = "";
                logInstance.debug("Registration removed for ".concat(this.channelType));
                _context3.next = 19;
                break;

              case 15:
                _context3.prev = 15;
                _context3.t0 = _context3["catch"](6);
                logInstance.error("Failed to remove registration ", this.channelType, _context3.t0);
                throw _context3.t0;

              case 19:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[6, 15]]);
      }));

      function sendDeviceRemoveRequest(_x3) {
        return _sendDeviceRemoveRequest.apply(this, arguments);
      }

      return sendDeviceRemoveRequest;
    }()
  }]);

  return RegistrarConnector;
}(Connector);

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Registrar connector implementation for twilsock -- @todo Drop twilsock.connector COMPLETELY?!
 */

var TwilsockConnector = /*#__PURE__*/function (_Connector) {
  _inherits__default['default'](TwilsockConnector, _Connector);

  var _super = _createSuper$1(TwilsockConnector);

  /**
   * Create twilsock registration connector.
   * @param productId product ID
   * @param platform platform ID string
   * @param twilsock {TwilsockClient} connection transport.
   */
  function TwilsockConnector(productId, platform, twilsock) {
    var _this;

    _classCallCheck__default['default'](this, TwilsockConnector);

    _this = _super.call(this, "twilsock");

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "contextId", uuid__namespace.v4());

    _this.productId = productId;
    _this.platform = platform;
    _this.twilsock = twilsock;
    return _this;
  }

  _createClass__default['default'](TwilsockConnector, [{
    key: "updateRegistration",
    value: function () {
      var _updateRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(registration, reasons) {
        var messageTypes, context;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (reasons.has("messageType")) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", registration);

              case 2:
                messageTypes = Array.from(registration.messageTypes);
                context = {
                  product_id: this.productId,
                  notification_protocol_version: 4,
                  endpoint_platform: this.platform,
                  message_types: messageTypes
                };
                _context.prev = 4;
                _context.next = 7;
                return this.twilsock.setNotificationsContext(this.contextId, context);

              case 7:
                _context.next = 13;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](4);
                logInstance.error("Failed to update twilsock notification context: ".concat(_context.t0));
                throw _context.t0;

              case 13:
                return _context.abrupt("return", registration);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 9]]);
      }));

      function updateRegistration(_x, _x2) {
        return _updateRegistration.apply(this, arguments);
      }

      return updateRegistration;
    }()
  }, {
    key: "removeRegistration",
    value: function () {
      var _removeRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return this.twilsock.removeNotificationsContext(this.contextId);

              case 3:
                _context2.next = 9;
                break;

              case 5:
                _context2.prev = 5;
                _context2.t0 = _context2["catch"](0);
                logInstance.error("Failed to remove twilsock notification context: ".concat(_context2.t0));
                throw _context2.t0;

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 5]]);
      }));

      function removeRegistration() {
        return _removeRegistration.apply(this, arguments);
      }

      return removeRegistration;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "sendDeviceRemoveRequest",
    value: function () {
      var _sendDeviceRemoveRequest = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(registrationId) {
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function sendDeviceRemoveRequest(_x3) {
        return _sendDeviceRemoveRequest.apply(this, arguments);
      }

      return sendDeviceRemoveRequest;
    }()
  }]);

  return TwilsockConnector;
}(Connector);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Client_1;

var channelTypeRule = declarativeTypeValidator.literal("apn", "fcm", "twilsock");
/**
 * @class
 * @alias Notifications
 * @classdesc The helper library for the notification service.
 * Provides high level api for creating and managing notification subscriptions and receiving messages
 * Creates the instance of Notification helper library
 *
 * @constructor
 * @param {string} token - Twilio access token
 * @param {Notifications#ClientOptions} options - Options to customize client behavior
 *
 * @event stateChanged channelType (registered|unregistered) -- coming from connector, i.e. it's per-connector type!
 * @event transportState Forwarded from Twilsock's stateChanged event.
 * @event message Routed from twilsock as a notification event.
 */

exports.Notifications = Client_1 = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](Client, _EventEmitter);

  var _super = _createSuper(Client);

  function Client(token) {
    var _options$logLevel, _options$productId, _options$twilsockClie, _options$notification, _ref, _config$region;

    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck__default['default'](this, Client);

    _this = _super.call(this);
    options.logLevel = (_options$logLevel = options.logLevel) !== null && _options$logLevel !== void 0 ? _options$logLevel : "error";
    logInstance.setLevel(options.logLevel);
    var productId = (_options$productId = options.productId) !== null && _options$productId !== void 0 ? _options$productId : "notifications";
    var startTwilsock = !options.twilsockClient;
    var twilsock$1 = options.twilsockClient = (_options$twilsockClie = options.twilsockClient) !== null && _options$twilsockClie !== void 0 ? _options$twilsockClie : new twilsock.TwilsockClient(token, productId, options);
    var config = (_options$notification = options.notifications) !== null && _options$notification !== void 0 ? _options$notification : {};
    var region = (_ref = (_config$region = config.region) !== null && _config$region !== void 0 ? _config$region : options.region) !== null && _ref !== void 0 ? _ref : "us1";
    var defaultUrl = "https://ers.".concat(region, ".twilio.com/v1/registrations");
    var registrarUrl = config.ersUrl || defaultUrl;
    _this.connectors = new Map();

    var platform = Client_1._detectPlatform();

    _this.connectors.set("apn", new RegistrarConnector("apn", {
      protocolVersion: 4,
      productId: productId,
      platform: platform
    }, twilsock$1, registrarUrl));

    _this.connectors.set("fcm", new RegistrarConnector("fcm", {
      protocolVersion: 3,
      productId: productId,
      platform: platform
    }, twilsock$1, registrarUrl));

    _this.connectors.set("twilsock", new TwilsockConnector(productId, platform, twilsock$1));

    twilsock$1.on("stateChanged", function (state) {
      return _this.emit("transportState", state);
    });

    _this._connector("twilsock").on("stateChanged", function (type, value, state) {
      return _this.emit("stateChanged", type, value, state);
    });

    _this._connector("apn").on("stateChanged", function (type, value, state) {
      return _this.emit("stateChanged", type, value, state);
    });

    _this._connector("fcm").on("stateChanged", function (type, value, state) {
      return _this.emit("stateChanged", type, value, state);
    }); // Router


    twilsock$1.on("message", function (type, message) {
      return _this._routeMessage(type, message);
    });

    _this.updateToken(token); // Start only if we created twilsock locally,
    // otherwise it's the responsibility of whoever created the Twilsock client.


    if (startTwilsock) {
      twilsock$1.connect();
      _this.twilsock = twilsock$1;
    }

    return _this;
  }

  _createClass__default['default'](Client, [{
    key: "shutdown",
    value: function () {
      var _shutdown = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.connectors.clear();

                if (!this.twilsock) {
                  _context.next = 4;
                  break;
                }

                _context.next = 4;
                return this.twilsock.disconnect();

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function shutdown() {
        return _shutdown.apply(this, arguments);
      }

      return shutdown;
    }()
    /**
     * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.
     *
     * You must call this function once you've received the ID of your device from the underlying OS.
     *
     * @param {ChannelType} channelType Channel type ('apn'/'fcm').
     * @param {string} pushRegistrationId Token received from FCM/APNS system on device.
     */

  }, {
    key: "setPushRegistrationId",
    value: function setPushRegistrationId(channelType, pushRegistrationId) {
      logInstance.debug("Set ".concat(channelType, " push registration id '").concat(pushRegistrationId, "'"));

      this._connector(channelType).setNotificationId(pushRegistrationId);
    }
    /**
     * Subscribe to a given message type for a given channel type.
     *
     * Creates a subscriptions to receive incoming messages according to message type.
     * Subscription establishes a binding and you will receive a signal when a notification
     * of this type has been received by the library.
     *
     * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.
     * This is the responsibility of the client SDK.
     *
     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
     * @param {string} messageType The type of message that you want to receive
     */

  }, {
    key: "subscribe",
    value: function subscribe(channelType, messageType) {
      logInstance.debug("Add ".concat(channelType, " subscriptions for message type ").concat(messageType));

      this._connector(channelType).subscribe(messageType);
    }
    /**
     * Unsubscribe from a given message type.
     *
     * Unsubscribing breaks a binding and you will not receive more notifications for this message type.
     * Please note that you have to call commitChanges() and receive a successful result before
     * the subscription is actually removed.
     *
     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
     * @param {string} messageType The type of message that you don't want to receive anymore
     */

  }, {
    key: "unsubscribe",
    value: function unsubscribe(channelType, messageType) {
      logInstance.debug("Remove ".concat(channelType, " subscriptions for message type ").concat(messageType));

      this._connector(channelType).unsubscribe(messageType);
    }
    /**
     * Update subscription token. You must update the token when the old one expires.
     *
     * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed
     * token _after_ you have updated twilsock and other associated objects with the new token.
     *
     * @param {string} token Authentication token for registrations
     */

  }, {
    key: "updateToken",
    value: function updateToken(token) {
      this.connectors.forEach(function (connector) {
        return connector.updateToken(token);
      });
    }
    /**
     * Commit all collected subscription changes as a batched update. This function tries to reduce
     * number of network calls necessary to update bindings status.
     */

  }, {
    key: "commitChanges",
    value: function () {
      var _commitChanges = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        var promises;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                promises = [];
                this.connectors.forEach(function (connector) {
                  if (connector.isActive()) {
                    promises.push(connector.commitChanges());
                  }
                });
                _context2.next = 4;
                return Promise.all(promises);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function commitChanges() {
        return _commitChanges.apply(this, arguments);
      }

      return commitChanges;
    }()
    /**
     * Clear existing registrations directly using provided device token.
     * This is useful to ensure stopped subscriptions without resubscribing.
     *
     * This function goes completely beside the state machine and removes all registrations.
     * Use with caution: if it races with current state machine operations, madness will ensue.
     *
     * @param {ChannelType} channelType Channel type ('apn'/'fcm').
     * @param {string} registrationId Token received from FCM/APNS system on device.
     */

  }, {
    key: "removeRegistrations",
    value: function () {
      var _removeRegistrations = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(channelType, registrationId) {
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._connector(channelType).sendDeviceRemoveRequest(registrationId);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function removeRegistrations(_x, _x2) {
        return _removeRegistrations.apply(this, arguments);
      }

      return removeRegistrations;
    }()
    /**
     * Handle incoming push notification.
     * Client application should call this method when it receives push notifications and pass the received data.
     * @param {Object} message push message
     * @return {PushNotification} A reformatted payload with extracted message type.
     */

  }, {
    key: "handlePushNotification",
    value: function handlePushNotification(message) {
      return {
        messageType: message.twi_message_type,
        payload: message.payload
      };
    }
    /**
     * Routes messages to the external subscribers
     */

  }, {
    key: "_routeMessage",
    value: function _routeMessage(type, message) {
      logInstance.debug("Notification message arrived: ", type, message);
      this.emit("message", type, message);
    }
    /**
     * @param {String} type Channel type
     * @throws {Error} Error with description
     */

  }, {
    key: "_connector",
    value: function _connector(type) {
      var connector = this.connectors.get(type);

      if (!connector) {
        throw new Error("Unknown channel type: ".concat(type));
      }

      return connector;
    }
    /**
     * Returns platform string limited to max 128 chars
     */

  }], [{
    key: "_detectPlatform",
    value: function _detectPlatform() {
      var platform = "";

      if (typeof navigator !== "undefined") {
        platform = "unknown";

        if (typeof navigator.product !== "undefined") {
          platform = navigator.product;
        }

        if (typeof navigator.userAgent !== "undefined") {
          platform = navigator.userAgent;
        }
      } else {
        platform = "web";
      }

      return platform.substring(0, 128);
    }
  }]);

  return Client;
}(EventEmitter);

__decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", void 0)], exports.Notifications.prototype, "setPushRegistrationId", null);

__decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", void 0)], exports.Notifications.prototype, "subscribe", null);

__decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", void 0)], exports.Notifications.prototype, "unsubscribe", null);

__decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", void 0)], exports.Notifications.prototype, "updateToken", null);

__decorate([declarativeTypeValidator.validateTypesAsync(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", Promise)], exports.Notifications.prototype, "removeRegistrations", null);

exports.Notifications = Client_1 = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.pureObject, "undefined", declarativeTypeValidator.literal(null)]), __metadata("design:paramtypes", [String, Object])], exports.Notifications);
//# sourceMappingURL=browser.js.map
