/*
@license
Copyright (c) 2018, Twilio, Inc.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
require('core-js/modules/es.promise.js');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
require('core-js/modules/es.array.from.js');
var log$2 = require('loglevel');
require('core-js/modules/es.string.starts-with.js');
require('core-js/modules/es.array.reduce.js');
require('core-js/modules/es.regexp.exec.js');
require('core-js/modules/es.string.split.js');
require('core-js/modules/es.object.assign.js');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/web.dom-collections.iterator.js');
require('core-js/modules/web.url.js');
var operationRetrier = require('@twilio/operation-retrier');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var log__namespace = /*#__PURE__*/_interopNamespace(log$2);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function prepareLine(prefix, args) {
  return ["".concat(new Date().toISOString(), " MCS Client ").concat(prefix, ":")].concat(Array.from(args));
}

class Logger {
  constructor(prefix) {
    _defineProperty__default['default'](this, "prefix", "");

    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0 ? prefix + " " : "";
  }

  static scope(prefix) {
    return new Logger(prefix);
  }

  setLevel(level) {
    log__namespace.setLevel(level);
  }

  static setLevel(level) {
    log__namespace.setLevel(level);
  }
  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */


  trace() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    log__namespace.trace.apply(null, prepareLine(this.prefix + "T", args));
  }

  debug() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    log__namespace.debug.apply(null, prepareLine(this.prefix + "D", args));
  }

  info() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    log__namespace.info.apply(null, prepareLine(this.prefix + "I", args));
  }

  warn() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    log__namespace.warn.apply(null, prepareLine(this.prefix + "W", args));
  }

  error() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    log__namespace.error.apply(null, prepareLine(this.prefix + "E", args));
  }

  static trace() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    log__namespace.trace.apply(null, prepareLine("T", args));
  }

  static debug() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    log__namespace.debug.apply(null, prepareLine("D", args));
  }

  static info() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    log__namespace.info.apply(null, prepareLine("I", args));
  }

  static warn() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    log__namespace.warn.apply(null, prepareLine("W", args));
  }

  static error() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }

    log__namespace.error.apply(null, prepareLine("E", args));
  }

}

var MINIMUM_RETRY_DELAY = 1000;
var MAXIMUM_RETRY_DELAY = 4000;
var MAXIMUM_ATTEMPTS_COUNT = 3;
var RETRY_WHEN_THROTTLED = true;

var regionalMcsHost = region => "https://mcs.".concat(region !== null && region !== void 0 ? region : "us1", ".twilio.com");

var isFullUrl = url => url.startsWith("http");

var fullUrl = (partUrl, region) => "".concat(!isFullUrl(partUrl) ? regionalMcsHost(region) : "").concat(partUrl);

class Configuration {
  constructor(token, baseUrl, baseSetUrl, options) {
    var _ref, _options$MCS, _ref2, _constructorOptions$r, _constructorOptions$r2, _constructorOptions$b;

    var constructorOptions = (_ref = (_options$MCS = options.MCS) !== null && _options$MCS !== void 0 ? _options$MCS : options) !== null && _ref !== void 0 ? _ref : {};
    this.region = (_ref2 = (_constructorOptions$r = constructorOptions.region) !== null && _constructorOptions$r !== void 0 ? _constructorOptions$r : options.region) !== null && _ref2 !== void 0 ? _ref2 : 'us1';
    this.mediaUrl = fullUrl(baseUrl, this.region);
    this.mediaSetUrl = baseSetUrl ? fullUrl(baseSetUrl) : "".concat(this.mediaUrl, "Set");
    this.token = token;
    this.retryWhenThrottledOverride = (_constructorOptions$r2 = constructorOptions.retryWhenThrottledOverride) !== null && _constructorOptions$r2 !== void 0 ? _constructorOptions$r2 : RETRY_WHEN_THROTTLED;
    this.backoffConfigOverride = (_constructorOptions$b = constructorOptions.backoffConfigOverride) !== null && _constructorOptions$b !== void 0 ? _constructorOptions$b : Configuration.backoffConfigDefault;
  }

  static get backoffConfigDefault() {
    return {
      min: MINIMUM_RETRY_DELAY,
      max: MAXIMUM_RETRY_DELAY,
      maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT
    };
  }

  static get retryWhenThrottledDefault() {
    return RETRY_WHEN_THROTTLED;
  }

  updateToken(token) {
    this.token = token;
  }

}

/**
 * @classdesc A Media represents a metadata information for the media upload
 * @property {String} sid - The server-assigned unique identifier for Media
 * @property {String} serviceSid - Service instance id which Media belongs/uploaded to
 * @property {Date} dateCreated - When the Media was created
 * @property {Date} dateUpdated - When the Media was updated
 * @property {Number} size - Size of media, bytes
 * @property {String} contentType - content type of media
 * @property {String} fileName - file name, if present, null otherwise
 * @property {MediaCategory} category - attachment category
 */
class Media {
  constructor(config, network, data) {
    this.config = config;
    this.network = network;

    this._update(data);
  }

  get sid() {
    return this.state.sid;
  }

  get serviceSid() {
    return this.state.serviceSid;
  }

  get dateCreated() {
    return this.state.dateCreated;
  }

  get dateUpdated() {
    return this.state.dateUpdated;
  }

  get contentType() {
    return this.state.contentType;
  }

  get size() {
    return this.state.size;
  }
  /** @deprecated Use filename instead */


  get fileName() {
    return this.state.filename;
  }

  get filename() {
    return this.state.filename;
  }

  get category() {
    return this.state.category;
  }
  /**
   * Returns direct content URL to uploaded binary. This URL will expire after some time.
   * This function gets a new URL every time, preventing it from expiring but putting additional load on backend.
   * See getCachedContentUrl() for a function that reduces the amount of network requests.
   *
   * It is reasonable to build your own refresh logic upon these two functions: as soon as URL returned
   * by getCachedContentUrl() returns 40x status you should call getContentUrl() to refresh it.
   *
   * @returns {Promise<string>}
   */


  getContentUrl() {
    var _this = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
      var response;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.network.get("".concat(_this.config.mediaUrl, "/").concat(_this.sid));

            case 2:
              response = _context.sent;

              _this._update(response.body);

              return _context.abrupt("return", Promise.resolve(_this.state.contentDirectUrl));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  }
  /**
   * Returns direct content URL to uploaded binary. This URL will expire after some time.
   * This function does not support getting a new URL however. Once set it will remain the same.
   * Use getContentUrl() to query a new one.
   *
   * It is reasonable to build your own refresh logic upon these two functions: as soon as URL returned
   * by getCachedContentUrl() returns 40x status you should call getContentUrl() to refresh it.
   *
   * @returns {Promise<string>}
   */


  getCachedContentUrl() {
    var _this2 = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!_this2.state.contentDirectUrl) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", Promise.resolve(_this2.state.contentDirectUrl));

            case 2:
              _context2.next = 4;
              return _this2.getContentUrl();

            case 4:
              return _context2.abrupt("return", _context2.sent);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  }

  _update(data) {
    var _data$links$content_d, _data$filename, _data$category, _data$is_multipart_up;

    this.state = {
      sid: data.sid,
      serviceSid: data.service_sid,
      channelSid: data.channel_sid,
      messageSid: data.message_sid,
      dateCreated: data.date_created ? new Date(data.date_created) : null,
      dateUploadUpdated: data.date_upload_updated ? new Date(data.date_upload_updated) : null,
      dateUpdated: data.date_updated ? new Date(data.date_updated) : null,
      size: data.size,
      contentType: data.content_type,
      author: data.author,
      url: data.url,
      contentUrl: data.links.content,
      contentDirectUrl: (_data$links$content_d = data.links.content_direct_temporary) !== null && _data$links$content_d !== void 0 ? _data$links$content_d : null,
      filename: (_data$filename = data.filename) !== null && _data$filename !== void 0 ? _data$filename : null,
      category: (_data$category = data.category) !== null && _data$category !== void 0 ? _data$category : "media",
      isMultipartUpstream: (_data$is_multipart_up = data.is_multipart_upstream) !== null && _data$is_multipart_up !== void 0 ? _data$is_multipart_up : false
    };
  }

}

class TransportError extends Error {
  constructor(message, code, body, status, headers) {
    super(message);
    this.code = code;
    this.body = body;
    this.status = status;
    this.headers = headers;
  }

}

var XHR = global["XMLHttpRequest"] || require("xmlhttprequest").XMLHttpRequest;

function parseResponseHeaders(headerString) {
  if (!headerString) {
    return {};
  }

  return headerString.split("\r\n").map(el => el.split(": ")).filter(el => el.length === 2 && el[1].length > 0).reduce((prev, curr) => {
    prev[curr[0]] = curr[1];
    return prev;
  }, {});
}

function extractBody(xhr) {
  var contentType = xhr.getResponseHeader("Content-Type");

  if (!contentType || contentType.indexOf("application/json") !== 0 || xhr.responseText.length === 0) {
    return xhr.responseText;
  }

  try {
    return JSON.parse(xhr.responseText);
  } catch (e) {
    return xhr.responseText;
  }
}
/**
 * Provides generic network interface
 */


class Transport {
  static request(method, url, headers, body) {
    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise((resolve, reject) => {
                var xhr = new XHR();
                xhr.open(method, url, true);

                xhr.onreadystatechange = function onreadystatechange() {
                  if (xhr.readyState !== 4) {
                    return;
                  }

                  var headers = parseResponseHeaders(xhr.getAllResponseHeaders());
                  var body = extractBody(xhr);

                  if (200 <= xhr.status && xhr.status < 300) {
                    resolve({
                      status: xhr.status,
                      headers,
                      body
                    });
                  } else {
                    var _xhr$statusText;

                    var status = (_xhr$statusText = xhr.statusText) !== null && _xhr$statusText !== void 0 ? _xhr$statusText : "NONE";
                    var bodyRepresentation;

                    if (typeof body === "string") {
                      bodyRepresentation = body && body.split("\n", 2).length === 1 ? body : "";
                    } else {
                      bodyRepresentation = JSON.stringify(body);
                    }

                    var message = "".concat(xhr.status, ": [").concat(status, "] ").concat(bodyRepresentation);
                    reject(new TransportError(message, xhr.status, body, status, headers));
                  }
                };

                for (var headerName in headers) {
                  xhr.setRequestHeader(headerName, headers[headerName]);

                  if (headerName === "Content-Type" && headers[headerName] === "application/json") {
                    body = JSON.stringify(body);
                  }
                }

                xhr.send(body);
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  }
  /**
   * Make a GET request by given URL
   */


  get(url, headers) {
    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", Transport.request("GET", url, headers));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  }
  /**
   * Make a POST request by given URL
   */


  post(url, headers, body) {
    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {
      return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", Transport.request("POST", url, headers, body));

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }))();
  }

}

var log$1 = Logger.scope("Network");

class Network {
  constructor(config, transport) {
    this.config = config;
    this.transport = transport;
  }

  backoffConfig() {
    return Object.assign(Configuration.backoffConfigDefault, this.config.backoffConfigOverride);
  }

  retryWhenThrottled() {
    var _ref, _this$config$retryWhe;

    return (_ref = (_this$config$retryWhe = this.config.retryWhenThrottledOverride) !== null && _this$config$retryWhe !== void 0 ? _this$config$retryWhe : Configuration.retryWhenThrottledDefault) !== null && _ref !== void 0 ? _ref : false;
  }

  executeWithRetry(request, retryWhenThrottled) {
    var _this = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise((resolve, reject) => {
                var codesToRetryOn = [502, 503, 504];

                if (retryWhenThrottled) {
                  codesToRetryOn.push(429);
                }

                var retrier = new operationRetrier.Retrier(_this.backoffConfig());
                retrier.on("attempt", /*#__PURE__*/_asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
                  var result;
                  return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return request();

                        case 3:
                          result = _context.sent;
                          retrier.succeeded(result);
                          _context.next = 10;
                          break;

                        case 7:
                          _context.prev = 7;
                          _context.t0 = _context["catch"](0);

                          if (codesToRetryOn.indexOf(_context.t0.status) > -1) {
                            retrier.failed(_context.t0);
                          } else if (_context.t0.message === "Twilsock disconnected") {
                            // Ugly hack. We must make a proper exceptions for twilsock
                            retrier.failed(_context.t0);
                          } else {
                            // Fatal error
                            retrier.removeAllListeners();
                            retrier.cancel();
                            reject(_context.t0);
                          }

                        case 10:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 7]]);
                })));
                retrier.on("succeeded", result => {
                  resolve(result);
                });
                retrier.on("cancelled", err => reject(err));
                retrier.on("failed", err => reject(err));
                retrier.start();
              }));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  }

  get(url) {
    var _this2 = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {
      var headers, response;
      return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              headers = {
                "X-Twilio-Token": _this2.config.token
              };
              log$1.trace("sending GET request to ", url, " headers ", headers);
              _context3.prev = 2;
              _context3.next = 5;
              return _this2.executeWithRetry(() => _this2.transport.get(url, headers), _this2.retryWhenThrottled());

            case 5:
              response = _context3.sent;
              log$1.trace("response", response);
              return _context3.abrupt("return", response);

            case 10:
              _context3.prev = 10;
              _context3.t0 = _context3["catch"](2);
              log$1.debug("get() error ".concat(_context3.t0));
              throw _context3.t0;

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[2, 10]]);
    }))();
  }

  post(url, category, media, contentType, filename) {
    var _this3 = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {
      var headers, fullUrl, response;
      return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              headers = {
                "X-Twilio-Token": _this3.config.token
              };

              if ((typeof FormData === "undefined" || !(media instanceof FormData)) && contentType) {
                Object.assign(headers, {
                  "Content-Type": contentType
                });
              }

              fullUrl = new URL(url);

              if (category) {
                fullUrl.searchParams.append("Category", category);
              }

              if (filename) {
                fullUrl.searchParams.append("Filename", filename);
              }

              log$1.trace("sending POST request to ".concat(url, " with headers ").concat(headers));
              _context4.prev = 6;
              _context4.next = 9;
              return _this3.transport.post(fullUrl.href, headers, media);

            case 9:
              response = _context4.sent;
              _context4.next = 18;
              break;

            case 12:
              _context4.prev = 12;
              _context4.t0 = _context4["catch"](6);

              if (!(global["XMLHttpRequest"] === undefined && media instanceof FormData)) {
                _context4.next = 16;
                break;
              }

              throw new TypeError("Posting FormData supported only with browser engine's FormData");

            case 16:
              log$1.debug("post() error ".concat(_context4.t0));
              throw _context4.t0;

            case 18:
              log$1.trace("response", response);
              return _context4.abrupt("return", response);

            case 20:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[6, 12]]);
    }))();
  }

}

var version = "0.5.3";

var _class, _temp;
var log = Logger.scope("");
/**
 * @classdesc A Client provides an interface for Media Content Service
 */

exports['default'] = (_temp = _class = class Client {
  // eslint-disable-next-line

  /**
   * Base URLs must be full URLs with host. If host is not provided it will be generated from a default configuration
   * template using options.region.
   *
   * @param {String} token - Access token
   * @param {String} baseUrl - Base URL for Media Content Service Media resource, i.e. /v1/Services/{serviceSid}/Media
   * @param {String} baseSetUrl - Base URL for Media Content Service MediaSet resource, i.e. /v1/Services/{serviceSid}/MediaSet
   * @param {Client#ClientOptions} [options] - Options to customize the Client
   */
  constructor(token, baseUrl, baseSetUrl) {
    var _this$options$logLeve, _this$options$transpo;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    this.options = options;
    this.options.logLevel = (_this$options$logLeve = this.options.logLevel) !== null && _this$options$logLeve !== void 0 ? _this$options$logLeve : "silent";
    this.config = new Configuration(token, baseUrl, baseSetUrl, this.options);
    log.setLevel(this.options.logLevel);
    this.options.transport = (_this$options$transpo = this.options.transport) !== null && _this$options$transpo !== void 0 ? _this$options$transpo : new Transport();
    this.transport = this.options.transport;
    this.network = new Network(this.config, this.transport);
  }
  /**
   * These options can be passed to Client constructor
   * @typedef {Object} Client#ClientOptions
   * @property {String} [logLevel='silent'] - The level of logging to enable. Valid options
   *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
   */

  /**
   * Update the token used for Client operations
   * @param {String} token - The JWT string of the new token
   * @returns {void}
   */


  updateToken(token) {
    log.info("updateToken");
    this.config.updateToken(token);
  }
  /**
   * Gets media from media service
   * @param {String} sid - Media's SID
   * @returns {Promise<Media>}
   */


  get(sid) {
    var _this = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
      var response;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.network.get("".concat(_this.config.mediaUrl, "/").concat(sid));

            case 2:
              response = _context.sent;
              return _context.abrupt("return", new Media(_this.config, _this.network, response.body));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  }
  /**
   * Posts raw content to media service
   * @param {String} contentType - content type of media
   * @param {String|Buffer|Blob} media - content to post
   * @param {MediaCategory|null} category - category for the media
   * @returns {Promise<Media>}
   */


  post(contentType, media, category, filename) {
    var _this2 = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
      var response;
      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _this2.network.post(_this2.config.mediaUrl, category !== null && category !== void 0 ? category : "media", media, contentType, filename);

            case 2:
              response = _context2.sent;
              return _context2.abrupt("return", new Media(_this2.config, _this2.network, response.body));

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  }
  /**
   * Posts FormData to media service. Can be used only with browser engine's FormData.
   * In non-browser FormData case the method will do promise reject with
   * new TypeError("Posting FormData supported only with browser engine's FormData")
   * @param {FormData} formData - form data to post
   * @param {MediaCategory|null} category - category for the media
   * @returns {Promise<Media>}
   */


  postFormData(formData, category) {
    var _this3 = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {
      var response;
      return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _this3.network.post(_this3.config.mediaUrl, category !== null && category !== void 0 ? category : "media", formData);

            case 2:
              response = _context3.sent;
              return _context3.abrupt("return", new Media(_this3.config, _this3.network, response.body));

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }))();
  }
  /**
   * Retrieve information about multiple media SIDs at the same time.
   * @param mediaSids Array of Media SIDs to get information from.
   */


  mediaSetGet(mediaSids) {
    var _this4 = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {
      var query, response;
      return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              query = {
                command: "get",
                list: mediaSids.map(sid => ({
                  media_sid: sid
                }))
              };
              _context4.next = 3;
              return _this4.network.post("".concat(_this4.config.mediaSetUrl), null, query, "application/json");

            case 3:
              response = _context4.sent;
              return _context4.abrupt("return", response.body.map(item => {
                if (item.code !== 200) {
                  throw new Error("Failed to obtain detailed information about Media items (failed SID ".concat(item.media_record.sid, ")"));
                }

                return new Media(_this4.config, _this4.network, item.media_record);
              }));

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }))();
  }

}, _defineProperty__default['default'](_class, "version", version), _temp);

__decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", void 0)], exports['default'].prototype, "updateToken", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports['default'].prototype, "get", null);

exports['default'] = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.literal(null)], [declarativeTypeValidator.pureObject, "undefined"]), __metadata("design:paramtypes", [String, String, Object, Object])], exports['default']); // Proper renames should happen in index.ts,

exports.Client = exports['default'];
exports.McsClient = exports['default'];
exports.McsMedia = Media;
exports.Media = Media;
exports.default = exports['default'];
//# sourceMappingURL=lib.js.map
