{"version":3,"file":"type-validator.js","sources":["../src/type-validator.ts"],"sourcesContent":["import { type } from \"./rules/type\";\n\nexport type TypeRule =\n  | \"undefined\"\n  | \"object\"\n  | \"boolean\"\n  | \"number\"\n  | \"bigint\"\n  | \"string\"\n  | \"symbol\"\n  | \"function\"\n  | { new (...args: unknown[]): unknown };\n\nexport type RuleFunction = (\n  value: unknown\n) => [boolean, (string | string[])?, string?];\n\nexport type RuleDefinition = {\n  checks: RuleFunction[];\n};\n\nexport type RuleArgument =\n  | TypeRule\n  | RuleDefinition\n  | (TypeRule | RuleDefinition)[];\n\ntype Decorator = (\n  target: unknown,\n  propertyKey: string,\n  descriptor: PropertyDescriptor\n) => void;\n\nexport const runtimeTypeValidation = (\n  rules: RuleDefinition[][],\n  values: unknown[]\n): void => {\n  if (values.length > rules.length) {\n    throw new Error(\n      `Expected at most ${rules.length} argument(s), but got ${values.length}`\n    );\n  }\n\n  while (values.length < rules.length) {\n    values.push(undefined);\n  }\n\n  for (const [index, value] of values.entries()) {\n    const [isValid, received, expected, delimeter] = validateValue(\n      rules[index],\n      value\n    );\n\n    if (isValid) {\n      continue;\n    }\n\n    const argumentIndex = index + 1;\n\n    throw new Error(\n      `Argument ${argumentIndex} is expected to be ${expected}${delimeter} but got ${received}`\n    );\n  }\n};\n\nexport const stringifyReceivedType = (value: unknown): string => {\n  let receivedType;\n  const types = [\"undefined\", \"boolean\", \"number\", \"bigint\", \"string\"];\n\n  if (types.includes(typeof value)) {\n    receivedType = typeof value === \"string\" ? `\"${value}\"` : `${value}`;\n  }\n\n  if (typeof value === \"object\" && value?.constructor?.name !== \"Object\") {\n    receivedType =\n      value === null ? \"null\" : `instance of ${value?.constructor?.name}`;\n  }\n\n  if (!receivedType) {\n    receivedType = typeof value;\n  }\n\n  return receivedType;\n};\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const validateConstructorTypes = (\n  ...args: RuleArgument[]\n): (<T extends new (...args: any[]) => any>(ctor: T) => T) => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return <T extends { new (...args: any[]): any }>(ctor: T): T => {\n    return class extends ctor {\n      constructor(...args: any[]) {\n        runtimeTypeValidation(finalRuleSet, args);\n        super(...args);\n      }\n    };\n  };\n};\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport const validateTypes = (...args: RuleArgument[]): Decorator => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return (\n    target: unknown,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) => {\n    if (typeof descriptor.value !== \"function\") {\n      throw new Error(\n        \"The validateTypes decorator can only be applied to methods\"\n      );\n    }\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: unknown[]) {\n      runtimeTypeValidation(finalRuleSet, args);\n      return originalMethod.apply(this, args);\n    };\n  };\n};\n\nexport const validateTypesAsync = (...args: RuleArgument[]): Decorator => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return (\n    target: unknown,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) => {\n    if (typeof descriptor.value !== \"function\") {\n      throw new Error(\n        \"The validateTypesAsync decorator can only be applied to methods\"\n      );\n    }\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: unknown[]) {\n      try {\n        runtimeTypeValidation(finalRuleSet, args);\n      } catch (e) {\n        return Promise.reject<Error>(e);\n      }\n\n      return originalMethod.apply(this, args);\n    };\n  };\n};\n\nexport const convertRuleArguments = (\n  args: RuleArgument[]\n): RuleDefinition[][] => {\n  const finalRuleDefinitionSet: RuleDefinition[][] = [];\n\n  for (const arg of args) {\n    finalRuleDefinitionSet.push(convertRuleArgument(arg));\n  }\n\n  return finalRuleDefinitionSet;\n};\n\nexport const convertRuleArgument = (arg: RuleArgument): RuleDefinition[] => {\n  const finalArgumentRuleDefinitions: RuleDefinition[] = [];\n  const declaredRules = Array.isArray(arg) ? arg : [arg];\n\n  for (const rule of declaredRules) {\n    if (typeof rule === \"string\" || typeof rule === \"function\") {\n      finalArgumentRuleDefinitions.push(type(rule));\n      continue;\n    }\n\n    finalArgumentRuleDefinitions.push(rule);\n  }\n\n  return finalArgumentRuleDefinitions;\n};\n\nexport const validateValue = (\n  ruleDefinitions: RuleDefinition[],\n  value: unknown\n): [true] | [false, string, string, string] => {\n  let expectedTypes: string[] = [];\n  let customReceivedType: string | undefined;\n  let isValid = false;\n\n  for (const definition of ruleDefinitions) {\n    for (const check of definition.checks) {\n      const [checkPassed, typeDescription, receivedType] = check(value);\n      isValid = isValid || checkPassed;\n\n      if (!customReceivedType && receivedType) {\n        customReceivedType = receivedType;\n      }\n\n      if (typeDescription) {\n        expectedTypes =\n          typeof typeDescription === \"string\"\n            ? [...expectedTypes, typeDescription]\n            : [...expectedTypes, ...typeDescription];\n      }\n    }\n  }\n\n  if (isValid) {\n    return [true];\n  }\n\n  const receivedType = customReceivedType || stringifyReceivedType(value);\n  const lastIndex = expectedTypes.length - 1;\n  const expectedTypesString =\n    lastIndex > 0\n      ? `${expectedTypes.slice(0, lastIndex).join(\", \")} or ${\n          expectedTypes[lastIndex]\n        }`\n      : expectedTypes.join(\", \");\n\n  return [false, receivedType, expectedTypesString, lastIndex > 1 ? \";\" : \",\"];\n};\n"],"names":["type"],"mappings":"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"}