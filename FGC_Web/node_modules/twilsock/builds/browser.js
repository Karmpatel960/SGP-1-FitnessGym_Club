/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2016, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes javascript-state-machine under the following license.

    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.


*/
'use strict';

var global =
  typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : typeof window !== "undefined"
    ? window
    : {};

Object.defineProperty(exports, '__esModule', { value: true });

require('core-js/modules/es.reflect.construct.js');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _createClass = require('@babel/runtime/helpers/createClass');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _get = require('@babel/runtime/helpers/get');
var _inherits = require('@babel/runtime/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
require('core-js/modules/es.array.concat.js');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.regexp.to-string.js');
require('core-js/modules/es.array.join.js');
require('core-js/modules/es.array.map.js');
var _typeof = require('@babel/runtime/helpers/typeof');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
require('core-js/modules/es.array.from.js');
require('core-js/modules/es.string.iterator.js');
var loglevelLog = require('loglevel');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/es.set.js');
require('core-js/modules/web.dom-collections.iterator.js');
require('core-js/modules/es.symbol.js');
require('core-js/modules/es.symbol.description.js');
require('core-js/modules/es.promise.js');
var StateMachine = require('javascript-state-machine');
var uuid = require('uuid');
require('core-js/modules/es.regexp.exec.js');
require('core-js/modules/es.string.replace.js');
require('core-js/modules/es.number.constructor.js');
require('core-js/modules/es.typed-array.uint8-array.js');
require('core-js/modules/es.typed-array.copy-within.js');
require('core-js/modules/es.typed-array.every.js');
require('core-js/modules/es.typed-array.fill.js');
require('core-js/modules/es.typed-array.filter.js');
require('core-js/modules/es.typed-array.find.js');
require('core-js/modules/es.typed-array.find-index.js');
require('core-js/modules/es.typed-array.for-each.js');
require('core-js/modules/es.typed-array.includes.js');
require('core-js/modules/es.typed-array.index-of.js');
require('core-js/modules/es.typed-array.iterator.js');
require('core-js/modules/es.typed-array.join.js');
require('core-js/modules/es.typed-array.last-index-of.js');
require('core-js/modules/es.typed-array.map.js');
require('core-js/modules/es.typed-array.reduce.js');
require('core-js/modules/es.typed-array.reduce-right.js');
require('core-js/modules/es.typed-array.reverse.js');
require('core-js/modules/es.typed-array.set.js');
require('core-js/modules/es.typed-array.slice.js');
require('core-js/modules/es.typed-array.some.js');
require('core-js/modules/es.typed-array.sort.js');
require('core-js/modules/es.typed-array.subarray.js');
require('core-js/modules/es.typed-array.to-locale-string.js');
require('core-js/modules/es.typed-array.to-string.js');
require('core-js/modules/es.string.split.js');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
require('core-js/modules/es.object.keys.js');
require('core-js/modules/es.array.filter.js');
require('core-js/modules/es.object.get-own-property-descriptor.js');
require('core-js/modules/web.dom-collections.for-each.js');
require('core-js/modules/es.object.get-own-property-descriptors.js');
var operationRetrier = require('@twilio/operation-retrier');
require('core-js/modules/es.map.js');
var platform = require('platform');
require('core-js/modules/es.string.match.js');
require('core-js/modules/es.string.search.js');
require('core-js/modules/es.array.splice.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);
var StateMachine__namespace = /*#__PURE__*/_interopNamespace(StateMachine);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);
var platform__namespace = /*#__PURE__*/_interopNamespace(platform);

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default['default'](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default['default'](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

var log = loglevelLog__namespace.getLogger("twilsock"); // twilsock is used by Flex SDK. Please DO NOT change

function prepareLine(prefix, args) {
  return ["".concat(new Date().toISOString(), " Twilsock ").concat(prefix, ":")].concat(Array.from(args));
}

var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck__default['default'](this, Logger);

    _defineProperty__default['default'](this, "prefix", "");

    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0 ? " " + prefix + ":" : "";
  }

  _createClass__default['default'](Logger, [{
    key: "setLevel",
    value: function setLevel(level) {
      log.setLevel(level);
    }
  }, {
    key: "trace",
    value: function trace() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      log.trace.apply(null, prepareLine("T", args));
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      log.debug.apply(null, prepareLine("D", args));
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      log.info.apply(null, prepareLine("I", args));
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      log.warn.apply(null, prepareLine("W", args));
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      log.error.apply(null, prepareLine("E", args));
    }
  }], [{
    key: "setLevel",
    value: function setLevel(level) {
      log.setLevel(level);
    }
  }, {
    key: "trace",
    value: function trace() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      log.trace.apply(null, prepareLine("T", args));
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      log.debug.apply(null, prepareLine("D", args));
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      log.info.apply(null, prepareLine("I", args));
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      log.warn.apply(null, prepareLine("W", args));
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }

      log.error.apply(null, prepareLine("E", args));
    }
  }]);

  return Logger;
}();

var logInstance = new Logger("");

var version = "0.12.2";

/**
 * Settings container for the Twilsock client library
 */

var Configuration = /*#__PURE__*/function () {
  /**
   * @param {String} token - authentication token
   * @param {Object} options - options to override defaults
   */
  function Configuration(token, activeGrant, options) {
    _classCallCheck__default['default'](this, Configuration);

    _defineProperty__default['default'](this, "confirmedCapabilities", new Set());

    this.activeGrant = activeGrant;
    this._token = token;
    var region = options.region || "us1";
    var defaultTwilsockUrl = "wss://tsock.".concat(region, ".twilio.com/v3/wsconnect");
    var twilsockOptions = options.twilsock || options.Twilsock || {};
    this.url = twilsockOptions.uri || defaultTwilsockUrl;
    this._continuationToken = options.continuationToken ? options.continuationToken : null;
    this.logLevel = options.logLevel ? options.logLevel : "error";
    this.retryPolicy = options.retryPolicy ? options.retryPolicy : {
      min: 1 * 1000,
      max: 2 * 60 * 1000,
      randomness: 0.2
    };
    this.clientMetadata = options.clientMetadata ? options.clientMetadata : {};
    this.clientMetadata.ver = version;
    this.initRegistrations = options.initRegistrations ? options.initRegistrations : null;
    this.tweaks = options.tweaks ? options.tweaks : null;
  }

  _createClass__default['default'](Configuration, [{
    key: "token",
    get: function get() {
      return this._token;
    }
  }, {
    key: "continuationToken",
    get: function get() {
      return this._continuationToken;
    }
  }, {
    key: "updateToken",
    value: function updateToken(token) {
      this._token = token;
    }
  }, {
    key: "updateContinuationToken",
    value: function updateContinuationToken(continuationToken) {
      this._continuationToken = continuationToken;
    }
  }]);

  return Configuration;
}();

var AbstractMessage = function AbstractMessage(id) {
  _classCallCheck__default['default'](this, AbstractMessage);

  this.id = id || "TM".concat(uuid.v4());
};

function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Init = /*#__PURE__*/function (_AbstractMessage) {
  _inherits__default['default'](Init, _AbstractMessage);

  var _super = _createSuper$f(Init);

  function Init(token, continuationToken, metadata, registrations, tweaks) {
    var _this;

    _classCallCheck__default['default'](this, Init);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "method", "init");

    _this.token = token;
    _this.continuation_token = continuationToken;
    _this.metadata = metadata;
    _this.registrations = registrations;
    _this.tweaks = tweaks;
    _this.capabilities = ["client_update", "offline_storage", "telemetry.v1"];
    return _this;
  }

  return Init;
}(AbstractMessage);

function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var InitReply = /*#__PURE__*/function (_AbstractMessage) {
  _inherits__default['default'](InitReply, _AbstractMessage);

  var _super = _createSuper$e(InitReply);

  function InitReply(id, continuationToken, confirmedCapabilities, continuationTokenStatus, offlineStorage, initRegistrations, debugInfo) {
    var _this;

    _classCallCheck__default['default'](this, InitReply);

    _this = _super.call(this, id);
    _this.continuationToken = continuationToken;
    _this.continuationTokenStatus = continuationTokenStatus;
    _this.offlineStorage = offlineStorage;
    _this.initRegistrations = initRegistrations;
    _this.debugInfo = debugInfo;
    _this.confirmedCapabilities = confirmedCapabilities;
    return _this;
  }

  return InitReply;
}(AbstractMessage);

function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Update = /*#__PURE__*/function (_AbstractMessage) {
  _inherits__default['default'](Update, _AbstractMessage);

  var _super = _createSuper$d(Update);

  function Update(token) {
    var _this;

    _classCallCheck__default['default'](this, Update);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "method", "update");

    _this.token = token;
    return _this;
  }

  return Update;
}(AbstractMessage);

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Message = /*#__PURE__*/function (_AbstractMessage) {
  _inherits__default['default'](Message, _AbstractMessage);

  var _super = _createSuper$c(Message);

  function Message(grant, contentType, request) {
    var _this;

    _classCallCheck__default['default'](this, Message);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "method", "message");

    _this.active_grant = grant;
    _this.payload_type = contentType;
    _this.http_request = request;
    return _this;
  }

  return Message;
}(AbstractMessage);

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Reply = /*#__PURE__*/function (_AbstractMessage) {
  _inherits__default['default'](Reply, _AbstractMessage);

  var _super = _createSuper$b(Reply);

  function Reply(id) {
    var _this;

    _classCallCheck__default['default'](this, Reply);

    _this = _super.call(this, id);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "method", "reply");

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "payload_type", "application/json");

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "status", {
      code: 200,
      status: "OK"
    });

    return _this;
  }

  return Reply;
}(AbstractMessage);

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Close = /*#__PURE__*/function (_AbstractMessage) {
  _inherits__default['default'](Close, _AbstractMessage);

  var _super = _createSuper$a(Close);

  function Close() {
    var _this;

    _classCallCheck__default['default'](this, Close);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "method", "close");

    return _this;
  }

  return Close;
}(AbstractMessage);

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var TelemetryEvent = function TelemetryEvent(start, // relative to event send time
end, // relative to event send time
title, details, id, // optional, default will be random assigned by backend
type) {
  _classCallCheck__default['default'](this, TelemetryEvent);

  this.start = start;
  this.end = end;
  this.title = title;
  this.details = details;
  this.id = id;
  this.type = type;
} // optional, default will be "SDK" assigned by backend
;

var Telemetry = /*#__PURE__*/function (_AbstractMessage) {
  _inherits__default['default'](Telemetry, _AbstractMessage);

  var _super = _createSuper$9(Telemetry);

  function Telemetry(events) {
    var _this;

    _classCallCheck__default['default'](this, Telemetry);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "method", "telemetry.v1");

    _this.events = events;
    return _this;
  }

  return Telemetry;
}(AbstractMessage);

function byteLength(s) {
  var escstr = encodeURIComponent(s);
  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {
    return String.fromCharCode(Number("0x" + p1));
  });
  return binstr.length;
}

function stringToUint8Array(s) {
  var escstr = encodeURIComponent(s);
  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {
    return String.fromCharCode(Number("0x" + p1));
  });
  var ua = new Uint8Array(binstr.length);
  Array.prototype.forEach.call(binstr, function (ch, i) {
    ua[i] = ch.charCodeAt(0);
  });
  return ua;
}

function uint8ArrayToString(ua) {
  var binstr = Array.prototype.map.call(ua, function (ch) {
    return String.fromCharCode(ch);
  }).join("");
  var escstr = binstr.replace(/(.)/g, function (m, p) {
    var code = p.charCodeAt(0).toString(16).toUpperCase();

    if (code.length < 2) {
      code = "0" + code;
    }

    return "%" + code;
  });
  return decodeURIComponent(escstr);
}

function getJsonObject(array) {
  return JSON.parse(uint8ArrayToString(array));
}

function getMagic(buffer) {
  var strMagic = "";
  var idx = 0;

  for (; idx < buffer.length; ++idx) {
    var chr = String.fromCharCode(buffer[idx]);
    strMagic += chr;

    if (chr === "\r") {
      idx += 2;
      break;
    }
  }

  var magics = strMagic.split(" ");
  return {
    size: idx,
    protocol: magics[0],
    version: magics[1],
    headerSize: Number(magics[2])
  };
}

var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck__default['default'](this, Parser);
  }

  _createClass__default['default'](Parser, null, [{
    key: "parse",
    value: function parse(message) {
      var fieldMargin = 2;
      var dataView = new Uint8Array(message);
      var magic = getMagic(dataView);

      if (magic.protocol !== "TWILSOCK" || magic.version !== "V3.0") {
        logInstance.error("unsupported protocol: ".concat(magic.protocol, " ver ").concat(magic.version)); //throw new Error('Unsupported protocol');
        //this.fsm.unsupportedProtocol();

        return null;
      }

      var header;

      try {
        header = getJsonObject(dataView.subarray(magic.size, magic.size + magic.headerSize));
      } catch (e) {
        logInstance.error("failed to parse message header", e, message); //throw new Error('Failed to parse message');
        //this.fsm.protocolError();

        return null;
      }

      logInstance.debug("message received: ", header.method);
      logInstance.trace("message received: ", header);
      var payload;

      if (header.payload_size > 0) {
        var payloadOffset = fieldMargin + magic.size + magic.headerSize;
        var payloadSize = header.payload_size;

        if (!header.hasOwnProperty("payload_type") || header.payload_type.indexOf("application/json") === 0) {
          try {
            payload = getJsonObject(dataView.subarray(payloadOffset, payloadOffset + payloadSize));
          } catch (e) {
            logInstance.error("failed to parse message body", e, message); //this.fsm.protocolError();

            return null;
          }
        } else if (header.payload_type.indexOf("text/plain") === 0) {
          payload = uint8ArrayToString(dataView.subarray(payloadOffset, payloadOffset + payloadSize));
        }
      }

      return {
        method: header.method,
        header: header,
        payload: payload
      };
    }
  }, {
    key: "createPacket",
    value: function createPacket(header) {
      var payloadString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      header.payload_size = byteLength(payloadString); // eslint-disable-line camelcase

      var headerString = JSON.stringify(header);
      var magicString = "TWILSOCK V3.0 " + byteLength(headerString);
      logInstance.debug("send request:", magicString + headerString + payloadString);
      var message = stringToUint8Array(magicString + "\r\n" + headerString + "\r\n" + payloadString);
      return message.buffer;
    }
  }]);

  return Parser;
}();

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var TwilsockError = /*#__PURE__*/function (_Error) {
  _inherits__default['default'](TwilsockError, _Error);

  var _super = _createSuper$8(TwilsockError);

  function TwilsockError(description) {
    _classCallCheck__default['default'](this, TwilsockError);

    return _super.call(this, description);
  }

  return TwilsockError;
}( /*#__PURE__*/_wrapNativeSuper__default['default'](Error));

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var TwilsockReplyError = /*#__PURE__*/function (_TwilsockError) {
  _inherits__default['default'](TwilsockReplyError, _TwilsockError);

  var _super = _createSuper$7(TwilsockReplyError);

  function TwilsockReplyError(description, reply) {
    var _this;

    _classCallCheck__default['default'](this, TwilsockReplyError);

    _this = _super.call(this, description);
    _this.reply = reply;
    return _this;
  }

  return TwilsockReplyError;
}(TwilsockError);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BackoffRetrier = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](BackoffRetrier, _EventEmitter);

  var _super = _createSuper$6(BackoffRetrier);

  function BackoffRetrier(options) {
    var _this;

    _classCallCheck__default['default'](this, BackoffRetrier);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "newBackoff", null);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "usedBackoff", null);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "retrier", null);

    _this.options = options ? _objectSpread({}, options) : {};
    return _this;
  }
  /**
   * Should be called once per attempt series to start retrier.
   */


  _createClass__default['default'](BackoffRetrier, [{
    key: "inProgress",
    get: function get() {
      return !!this.retrier;
    }
  }, {
    key: "start",
    value: function start() {
      if (this.inProgress) {
        throw new Error("Already waiting for next attempt, call finishAttempt(success : boolean) to finish it");
      }

      this.createRetrier();
    }
    /**
     * Should be called to stop retrier entirely.
     */

  }, {
    key: "stop",
    value: function stop() {
      this.cleanRetrier();
      this.newBackoff = null;
      this.usedBackoff = null;
    }
    /**
     * Modifies backoff for next attempt.
     * Expected behavior:
     * - If there was no backoff passed previously reschedulling next attempt to given backoff
     * - If previous backoff was longer then ignoring this one.
     * - If previous backoff was shorter then reschedulling with this one.
     * With or without backoff retrier will keep growing normally.
     * @param delay delay of next attempts in ms.
     */

  }, {
    key: "modifyBackoff",
    value: function modifyBackoff(delay) {
      this.newBackoff = delay;
    }
    /**
     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.
     */

  }, {
    key: "attemptFailed",
    value: function attemptFailed() {
      if (!this.inProgress) {
        throw new Error("No attempt is in progress");
      }

      if (this.newBackoff) {
        var shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;

        if (shouldUseNewBackoff) {
          this.createRetrier();
        } else {
          var _this$retrier;

          (_this$retrier = this.retrier) === null || _this$retrier === void 0 ? void 0 : _this$retrier.failed(new Error());
        }
      } else {
        var _this$retrier2;

        (_this$retrier2 = this.retrier) === null || _this$retrier2 === void 0 ? void 0 : _this$retrier2.failed(new Error());
      }
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var _this$retrier3;

      (_this$retrier3 = this.retrier) === null || _this$retrier3 === void 0 ? void 0 : _this$retrier3.cancel();
    }
  }, {
    key: "cleanRetrier",
    value: function cleanRetrier() {
      var _this$retrier4, _this$retrier5;

      (_this$retrier4 = this.retrier) === null || _this$retrier4 === void 0 ? void 0 : _this$retrier4.removeAllListeners();
      (_this$retrier5 = this.retrier) === null || _this$retrier5 === void 0 ? void 0 : _this$retrier5.cancel();
      this.retrier = null;
    }
  }, {
    key: "getRetryPolicy",
    value: function getRetryPolicy() {
      var clone = _objectSpread({}, this.options);

      if (this.newBackoff) {
        clone.min = this.newBackoff;
        clone.max = this.options.max && this.options.max > this.newBackoff ? this.options.max : this.newBackoff;
      } // As we're always skipping first attempt we should add one extra if limit is present


      clone.maxAttemptsCount = this.options.maxAttemptsCount ? this.options.maxAttemptsCount + 1 : undefined;
      return clone;
    }
  }, {
    key: "createRetrier",
    value: function createRetrier() {
      var _this2 = this;

      this.cleanRetrier();
      var retryPolicy = this.getRetryPolicy();
      this.retrier = new operationRetrier.Retrier(retryPolicy);
      this.retrier.once("attempt", function () {
        var _this2$retrier, _this2$retrier2;

        (_this2$retrier = _this2.retrier) === null || _this2$retrier === void 0 ? void 0 : _this2$retrier.on("attempt", function () {
          return _this2.emit("attempt");
        });
        (_this2$retrier2 = _this2.retrier) === null || _this2$retrier2 === void 0 ? void 0 : _this2$retrier2.failed(new Error("Skipping first attempt"));
      });
      this.retrier.on("failed", function (err) {
        return _this2.emit("failed", err);
      });
      this.usedBackoff = this.newBackoff;
      this.newBackoff = null;
      this.retrier.start(); // .catch(err => {});
    }
  }]);

  return BackoffRetrier;
}(EventEmitter);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var DISCONNECTING_TIMEOUT = 3000; // Wraps asynchronous rescheduling
// Just makes it simpler to find these hacks over the code
// Currently there's exactly one instance of this in closeSocket()

function trampoline(f) {
  setTimeout(f, 0);
}
/**
 * Twilsock channel level protocol implementation
 */


var TwilsockChannel = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](TwilsockChannel, _EventEmitter);

  var _super = _createSuper$5(TwilsockChannel);

  function TwilsockChannel(websocket, transport, config) {
    var _this;

    _classCallCheck__default['default'](this, TwilsockChannel);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "disconnectingTimer", null);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "disconnectedPromiseResolve", null);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "terminalStates", ["disconnected", "rejected"]);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "tokenExpiredSasCode", 20104);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "terminationReason", "Connection is not initialized");

    _this.websocket = websocket;

    _this.websocket.on("connected", function () {
      return _this.fsm.socketConnected();
    });

    _this.websocket.on("disconnected", function () {
      return _this.fsm.socketClosed();
    });

    _this.websocket.on("message", function (message) {
      return _this.onIncomingMessage(message);
    });

    _this.websocket.on("socketError", function (e) {
      return _this.emit("connectionError", {
        terminal: false,
        message: "Socket error: ".concat(e.message),
        httpStatusCode: null,
        errorCode: null
      });
    });

    _this.transport = transport;
    _this.config = config;
    _this.retrier = new BackoffRetrier(config.retryPolicy);

    _this.retrier.on("attempt", function () {
      return _this.retry();
    });

    _this.retrier.on("failed", function (err) {
      logInstance.warn("Retrying failed: ".concat(err.message));

      _this.disconnect();
    });

    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", function () {
        logInstance.debug("Browser reported connectivity state: online");

        _this.resetBackoff();

        _this.fsm.systemOnline();
      });
      window.addEventListener("offline", function () {
        logInstance.debug("Browser reported connectivity state: offline");

        _this.websocket.close();

        _this.fsm.socketClosed();
      });
    } // We have to use a factory function in here because using the default
    // StateMachine constructor would cause an error for the consumers of the
    // rollup bundles. This is a quirk unique to the javascript-state-machine
    // library.


    var TwilsockStateMachine = StateMachine__namespace.factory({
      init: "disconnected",
      transitions: [{
        name: "userConnect",
        from: ["disconnected", "rejected"],
        to: "connecting"
      }, {
        name: "userConnect",
        from: ["connecting", "connected"]
      }, {
        name: "userDisconnect",
        from: ["connecting", "initialising", "connected", "updating", "retrying", "rejected", "waitSocketClosed", "waitOffloadSocketClosed"],
        to: "disconnecting"
      }, {
        name: "userRetry",
        from: ["retrying"],
        to: "connecting"
      }, {
        name: "socketConnected",
        from: ["connecting"],
        to: "initialising"
      }, {
        name: "socketClosed",
        from: ["connecting", "initialising", "connected", "updating", "error", "waitOffloadSocketClosed"],
        to: "retrying"
      }, {
        name: "socketClosed",
        from: ["disconnecting"],
        to: "disconnected"
      }, {
        name: "socketClosed",
        from: ["waitSocketClosed"],
        to: "disconnected"
      }, {
        name: "socketClosed",
        from: ["rejected"],
        to: "rejected"
      }, {
        name: "initSuccess",
        from: ["initialising"],
        to: "connected"
      }, {
        name: "initError",
        from: ["initialising"],
        to: "error"
      }, {
        name: "tokenRejected",
        from: ["initialising", "updating"],
        to: "rejected"
      }, {
        name: "protocolError",
        from: ["initialising", "connected", "updating"],
        to: "error"
      }, {
        name: "receiveClose",
        from: ["initialising", "connected", "updating"],
        to: "waitSocketClosed"
      }, {
        name: "receiveOffload",
        from: ["initialising", "connected", "updating"],
        to: "waitOffloadSocketClosed"
      }, {
        name: "unsupportedProtocol",
        from: ["initialising", "connected", "updating"],
        to: "unsupported"
      }, {
        name: "receiveFatalClose",
        from: ["initialising", "connected", "updating"],
        to: "unsupported"
      }, {
        name: "userUpdateToken",
        from: ["disconnected", "rejected", "connecting", "retrying"],
        to: "connecting"
      }, {
        name: "userUpdateToken",
        from: ["connected"],
        to: "updating"
      }, {
        name: "updateSuccess",
        from: ["updating"],
        to: "connected"
      }, {
        name: "updateError",
        from: ["updating"],
        to: "error"
      }, {
        name: "userSend",
        from: ["connected"],
        to: "connected"
      }, {
        name: "systemOnline",
        from: ["retrying"],
        to: "connecting"
      }],
      methods: {
        onConnecting: function onConnecting() {
          _this.setupSocket();

          _this.emit("connecting");
        },
        onEnterInitialising: function onEnterInitialising() {
          _this.sendInit();
        },
        onLeaveInitialising: function onLeaveInitialising() {
          _this.cancelInit();
        },
        onEnterUpdating: function onEnterUpdating() {
          _this.sendUpdate();
        },
        onLeaveUpdating: function onLeaveUpdating() {
          _this.cancelUpdate();
        },
        onEnterRetrying: function onEnterRetrying() {
          _this.initRetry();

          _this.emit("connecting");
        },
        onEnterConnected: function onEnterConnected() {
          _this.resetBackoff();

          _this.onConnected();
        },
        onUserUpdateToken: function onUserUpdateToken() {
          _this.resetBackoff();
        },
        onTokenRejected: function onTokenRejected() {
          _this.resetBackoff();

          _this.closeSocket(true);

          _this.finalizeSocket();
        },
        onUserDisconnect: function onUserDisconnect() {
          _this.closeSocket(true);
        },
        onEnterDisconnecting: function onEnterDisconnecting() {
          _this.startDisconnectTimer();
        },
        onLeaveDisconnecting: function onLeaveDisconnecting() {
          _this.cancelDisconnectTimer();
        },
        onEnterWaitSocketClosed: function onEnterWaitSocketClosed() {
          _this.startDisconnectTimer();
        },
        onLeaveWaitSocketClosed: function onLeaveWaitSocketClosed() {
          _this.cancelDisconnectTimer();
        },
        onEnterWaitOffloadSocketClosed: function onEnterWaitOffloadSocketClosed() {
          _this.startDisconnectTimer();
        },
        onLeaveWaitOffloadSocketClosed: function onLeaveWaitOffloadSocketClosed() {
          _this.cancelDisconnectTimer();
        },
        onDisconnected: function onDisconnected() {
          _this.resetBackoff();

          _this.finalizeSocket();
        },
        onReceiveClose: function onReceiveClose() {
          _this.onCloseReceived();
        },
        onReceiveOffload: function onReceiveOffload(event, args) {
          logInstance.debug("onreceiveoffload: ", args);

          _this.modifyBackoff(args.body);

          _this.onCloseReceived();
        },
        onUnsupported: function onUnsupported() {
          _this.closeSocket(true);

          _this.finalizeSocket();
        },
        onError: function onError(lifecycle, graceful) {
          _this.closeSocket(graceful);

          _this.finalizeSocket();
        },
        onEnterState: function onEnterState(event) {
          if (event.from !== "none") {
            _this.changeState(event);
          }
        },
        onInvalidTransition: function onInvalidTransition(transition, from, to) {
          logInstance.warn("FSM: unexpected transition", from, to);
        }
      }
    });
    _this.fsm = new TwilsockStateMachine();
    return _this;
  }

  _createClass__default['default'](TwilsockChannel, [{
    key: "changeState",
    value: function changeState(event) {
      logInstance.debug("FSM: ".concat(event.transition, ": ").concat(event.from, " --> ").concat(event.to));

      if (this.lastEmittedState !== this.state) {
        this.lastEmittedState = this.state;
        this.emit("stateChanged", this.state);
      }
    }
  }, {
    key: "resetBackoff",
    value: function resetBackoff() {
      logInstance.trace("resetBackoff");
      this.retrier.stop();
    }
  }, {
    key: "modifyBackoff",
    value: function modifyBackoff(body) {
      logInstance.trace("modifyBackoff", body);
      var backoffPolicy = body ? body.backoff_policy : null;

      if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === "number") {
        this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);
      }
    }
  }, {
    key: "startDisconnectTimer",
    value: function startDisconnectTimer() {
      var _this2 = this;

      logInstance.trace("startDisconnectTimer");

      if (this.disconnectingTimer) {
        clearTimeout(this.disconnectingTimer);
        this.disconnectingTimer = null;
      }

      this.disconnectingTimer = setTimeout(function () {
        logInstance.debug("disconnecting is timed out");

        _this2.closeSocket(true);
      }, DISCONNECTING_TIMEOUT);
    }
  }, {
    key: "cancelDisconnectTimer",
    value: function cancelDisconnectTimer() {
      logInstance.trace("cancelDisconnectTimer");

      if (this.disconnectingTimer) {
        clearTimeout(this.disconnectingTimer);
        this.disconnectingTimer = null;
      }
    }
  }, {
    key: "isConnected",
    get: function get() {
      return this.state === "connected" && this.websocket.isConnected;
    }
  }, {
    key: "state",
    get: function get() {
      switch (this.fsm.state) {
        case "connecting":
        case "initialising":
        case "retrying":
        case "error":
          return "connecting";

        case "updating":
        case "connected":
          return "connected";

        case "rejected":
          return "denied";

        case "disconnecting":
        case "waitSocketClosed":
        case "waitOffloadSocketClosed":
          return "disconnecting";

        case "disconnected":
        default:
          return "disconnected";
      }
    }
  }, {
    key: "initRetry",
    value: function initRetry() {
      logInstance.debug("initRetry");

      if (this.retrier.inProgress) {
        this.retrier.attemptFailed();
      } else {
        this.retrier.start();
      }
    }
  }, {
    key: "retry",
    value: function retry() {
      if (this.fsm.state != "connecting") {
        logInstance.trace("retry");
        this.websocket.close();
        this.fsm.userRetry();
      } else {
        logInstance.trace("can\t retry as already connecting");
      }
    }
  }, {
    key: "onConnected",
    value: function onConnected() {
      this.emit("connected");
    }
  }, {
    key: "finalizeSocket",
    value: function finalizeSocket() {
      logInstance.trace("finalizeSocket");
      this.websocket.close();
      this.emit("disconnected");

      if (this.disconnectedPromiseResolve) {
        this.disconnectedPromiseResolve();
        this.disconnectedPromiseResolve = null;
      }
    }
  }, {
    key: "setupSocket",
    value: function setupSocket() {
      logInstance.trace("setupSocket:", this.config.token);
      this.emit("beforeConnect"); // This is used by client to record startup telemetry event

      this.websocket.connect();
    }
  }, {
    key: "onIncomingMessage",
    value: function onIncomingMessage(message) {
      var parsedMessage = Parser.parse(message);

      if (!parsedMessage) {
        return;
      }

      var method = parsedMessage.method,
          header = parsedMessage.header,
          payload = parsedMessage.payload;

      if (method !== "reply") {
        this.confirmReceiving(header);
      }

      if (method === "notification") {
        this.emit("message", header.message_type, payload);
      } else if (header.method === "reply") {
        this.transport.processReply({
          id: header.id,
          status: header.status,
          header: header,
          body: payload
        });
      } else if (header.method === "client_update") {
        if (header.client_update_type === "token_about_to_expire") {
          this.emit("tokenAboutToExpire");
        }
      } else if (header.method === "close") {
        if (header.status.code === 308) {
          logInstance.debug("Connection has been offloaded");
          this.fsm.receiveOffload({
            status: header.status.status,
            body: payload
          });
        } else if (header.status.code === 406) {
          // Not acceptable message
          var _message = "Server closed connection because can't parse protocol: ".concat(JSON.stringify(header.status));

          this.emitReplyConnectionError(_message, header, true);
          logInstance.error(_message);
          this.fsm.receiveFatalClose();
        } else if (header.status.code === 417) {
          // Protocol error
          logInstance.error("Server closed connection because can't parse client reply: ".concat(JSON.stringify(header.status)));
          this.fsm.receiveFatalClose(header.status.status);
        } else if (header.status.code === 410) {
          // Expired token
          logInstance.warn("Server closed connection: ".concat(JSON.stringify(header.status)));
          this.fsm.receiveClose(header.status.status);
          this.emit("tokenExpired");
        } else if (header.status.code === 401) {
          // Authentication fail
          logInstance.error("Server closed connection: ".concat(JSON.stringify(header.status)));
          this.fsm.receiveClose(header.status.status);
        } else {
          logInstance.warn("unexpected message: ", header.status); // Try to reconnect

          this.fsm.receiveOffload({
            status: header.status.status,
            body: null
          });
        }
      }
    }
  }, {
    key: "sendInit",
    value: function () {
      var _sendInit = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        var reply, isTerminalError;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                logInstance.trace("sendInit");
                _context.prev = 1;
                this.emit("beforeSendInit"); // This is used by client to record startup telemetry event

                _context.next = 5;
                return this.transport.sendInit();

              case 5:
                reply = _context.sent;
                this.config.updateContinuationToken(reply.continuationToken);
                this.config.confirmedCapabilities = reply.confirmedCapabilities;
                this.fsm.initSuccess(reply);
                this.emit("initialized", reply);
                this.emit("tokenUpdated");
                _context.next = 17;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](1);

                if (_context.t0 instanceof TwilsockReplyError) {
                  isTerminalError = false;
                  logInstance.warn("Init rejected by server: ".concat(JSON.stringify(_context.t0.reply.status)));
                  this.emit("sendInitFailed"); // This is used by client to record startup telemetry event
                  // @todo emit telemetry from inside "if" below for more granularity...

                  if (_context.t0.reply.status.code === 401 || _context.t0.reply.status.code === 403) {
                    isTerminalError = true;
                    this.fsm.tokenRejected(_context.t0.reply.status);

                    if (_context.t0.reply.status.errorCode === this.tokenExpiredSasCode) {
                      this.emit("tokenExpired");
                    }
                  } else if (_context.t0.reply.status.code === 429) {
                    this.modifyBackoff(_context.t0.reply.body);
                    this.fsm.initError(true);
                  } else if (_context.t0.reply.status.code === 500) {
                    this.fsm.initError(false);
                  } else {
                    this.fsm.initError(true);
                  }

                  this.emitReplyConnectionError(_context.t0.message, _context.t0.reply, isTerminalError);
                } else {
                  this.terminationReason = _context.t0.message;
                  this.emit("connectionError", {
                    terminal: true,
                    message: "Unknown error during connection initialisation: ".concat(_context.t0.message, "\n").concat(JSON.stringify(_context.t0, null, 2)),
                    httpStatusCode: null,
                    errorCode: null
                  });
                  this.fsm.initError(true);
                }

                this.emit("tokenUpdated", _context.t0);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 13]]);
      }));

      function sendInit() {
        return _sendInit.apply(this, arguments);
      }

      return sendInit;
    }()
  }, {
    key: "sendUpdate",
    value: function () {
      var _sendUpdate = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        var message, reply, isTerminalError;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                logInstance.trace("sendUpdate");
                message = new Update(this.config.token);
                _context2.prev = 2;
                _context2.next = 5;
                return this.transport.sendWithReply(message);

              case 5:
                reply = _context2.sent;
                this.fsm.updateSuccess(reply.body);
                this.emit("tokenUpdated");
                _context2.next = 14;
                break;

              case 10:
                _context2.prev = 10;
                _context2.t0 = _context2["catch"](2);

                if (_context2.t0 instanceof TwilsockReplyError) {
                  isTerminalError = false;
                  logInstance.warn("Token update rejected by server: ".concat(JSON.stringify(_context2.t0.reply.status)));

                  if (_context2.t0.reply.status.code === 401 || _context2.t0.reply.status.code === 403) {
                    isTerminalError = true;
                    this.fsm.tokenRejected(_context2.t0.reply.status);

                    if (_context2.t0.reply.status.errorCode === this.tokenExpiredSasCode) {
                      this.emit("tokenExpired");
                    }
                  } else if (_context2.t0.reply.status.code === 429) {
                    this.modifyBackoff(_context2.t0.reply.body);
                    this.fsm.updateError(_context2.t0.reply.status);
                  } else {
                    this.fsm.updateError(_context2.t0.reply.status);
                  }

                  this.emitReplyConnectionError(_context2.t0.message, _context2.t0.reply, isTerminalError);
                } else {
                  this.emit("error", false, _context2.t0.message, null, null);
                  this.fsm.updateError(_context2.t0);
                }

                this.emit("tokenUpdated", _context2.t0);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 10]]);
      }));

      function sendUpdate() {
        return _sendUpdate.apply(this, arguments);
      }

      return sendUpdate;
    }()
  }, {
    key: "emitReplyConnectionError",
    value: function emitReplyConnectionError(message, header, terminal) {
      var description = header.status && header.status.description ? header.status.description : message;
      var httpStatusCode = header.status.code;
      var errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;

      if (terminal) {
        this.terminationReason = description;
      }

      this.emit("connectionError", {
        terminal: terminal,
        message: "Connection error: ".concat(description),
        httpStatusCode: httpStatusCode,
        errorCode: errorCode
      });
    }
  }, {
    key: "cancelInit",
    value: function cancelInit() {
      logInstance.trace("cancelInit"); // TODO: implement
    }
  }, {
    key: "cancelUpdate",
    value: function cancelUpdate() {
      logInstance.trace("cancelUpdate"); // TODO: implement
    }
    /**
     * Should be called for each message to confirm it received
     */

  }, {
    key: "confirmReceiving",
    value: function confirmReceiving(messageHeader) {
      logInstance.trace("confirmReceiving");

      try {
        //@todo send telemetry events AnyEvents
        this.transport.send(new Reply(messageHeader.id));
      } catch (e) {
        logInstance.debug("failed to confirm packet receiving", e);
      }
    }
    /**
     * Shutdown connection
     */

  }, {
    key: "closeSocket",
    value: function closeSocket(graceful) {
      var _this3 = this;

      logInstance.trace("closeSocket (graceful: ".concat(graceful, ")"));

      if (graceful && this.transport.isConnected) {
        this.transport.sendClose();
      }

      this.websocket.close();
      trampoline(function () {
        return _this3.fsm.socketClosed();
      });
    }
    /**
     * Initiate the twilsock connection
     * If already connected, it does nothing
     */

  }, {
    key: "connect",
    value: function connect() {
      logInstance.trace("connect");
      this.fsm.userConnect();
    }
    /**
     * Close twilsock connection
     * If already disconnected, it does nothing
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this4 = this;

      logInstance.trace("disconnect");

      if (this.fsm.is("disconnected")) {
        return Promise.resolve();
      }

      return new Promise(function (resolve) {
        _this4.disconnectedPromiseResolve = resolve;

        _this4.fsm.userDisconnect();
      });
    }
    /**
     * Update fpa token for twilsock connection
     */

  }, {
    key: "updateToken",
    value: function updateToken(token) {
      var _this5 = this;

      logInstance.trace("updateToken:", token);
      return new Promise(function (resolve, reject) {
        _this5.once("tokenUpdated", function (e) {
          if (e) {
            reject(e);
          } else {
            resolve();
          }
        });

        _this5.fsm.userUpdateToken();
      });
    }
  }, {
    key: "isTerminalState",
    get: function get() {
      return this.terminalStates.indexOf(this.fsm.state) !== -1;
    }
  }, {
    key: "getTerminationReason",
    get: function get() {
      return this.terminationReason;
    }
  }, {
    key: "onCloseReceived",
    value: function onCloseReceived() {
      this.websocket.close();
    }
  }]);

  return TwilsockChannel;
}(EventEmitter);

var Metadata = /*#__PURE__*/function () {
  function Metadata() {
    _classCallCheck__default['default'](this, Metadata);
  }

  _createClass__default['default'](Metadata, null, [{
    key: "getMetadata",
    value: function getMetadata(options) {
      var _platform$name, _platform$version, _platform$os$family, _platform$os, _platform$os$version, _platform$os2, _platform$os$architec, _platform$os3;

      var overrides = options && options.clientMetadata ? options.clientMetadata : {};
      var fieldNames = ["ver", "env", "envv", "os", "osv", "osa", "type", "sdk", "sdkv", "dev", "devv", "devt", "app", "appv"];
      var defaults = {
        env: (_platform$name = platform__namespace.name) !== null && _platform$name !== void 0 ? _platform$name : "unknown",
        envv: (_platform$version = platform__namespace.version) !== null && _platform$version !== void 0 ? _platform$version : "unknown",
        os: (_platform$os$family = (_platform$os = platform__namespace.os) === null || _platform$os === void 0 ? void 0 : _platform$os.family) !== null && _platform$os$family !== void 0 ? _platform$os$family : "unknown",
        osv: (_platform$os$version = (_platform$os2 = platform__namespace.os) === null || _platform$os2 === void 0 ? void 0 : _platform$os2.version) !== null && _platform$os$version !== void 0 ? _platform$os$version : "unknown",
        osa: (_platform$os$architec = (_platform$os3 = platform__namespace.os) === null || _platform$os3 === void 0 ? void 0 : _platform$os3.architecture) !== null && _platform$os$architec !== void 0 ? _platform$os$architec : "unknown",
        sdk: "js-default"
      };
      var finalClientMetadata = {};
      fieldNames.filter(function (key) {
        return key in overrides || key in defaults;
      }).forEach(function (key) {
        return finalClientMetadata[key] = key in overrides ? overrides[key] : defaults[key];
      });
      return finalClientMetadata;
    }
  }]);

  return Metadata;
}();

var REQUEST_TIMEOUT$1 = 30000;

function isHttpSuccess$1(code) {
  return code >= 200 && code < 300;
}
/**
 * Makes sure that body is properly stringified
 */


function preparePayload(payload) {
  switch (_typeof__default['default'](payload)) {
    case "undefined":
      return "";

    case "object":
      return JSON.stringify(payload);

    default:
      return payload;
  }
}

var PacketInterface = /*#__PURE__*/function () {
  function PacketInterface(channel, config) {
    var _this = this;

    _classCallCheck__default['default'](this, PacketInterface);

    this.config = config;
    this.activeRequests = new Map();
    this.channel = channel;
    this.channel.on("reply", function (reply) {
      return _this.processReply(reply);
    });
    this.channel.on("disconnected", function () {
      _this.activeRequests.forEach(function (descriptor) {
        clearTimeout(descriptor.timeout);
        descriptor.reject(new TwilsockError("disconnected"));
      });

      _this.activeRequests.clear();
    });
  }

  _createClass__default['default'](PacketInterface, [{
    key: "isConnected",
    get: function get() {
      return this.channel.isConnected;
    }
  }, {
    key: "processReply",
    value: function processReply(reply) {
      var request = this.activeRequests.get(reply.id);

      if (request) {
        clearTimeout(request.timeout);
        this.activeRequests.delete(reply.id);

        if (!isHttpSuccess$1(reply.status.code)) {
          request.reject(new TwilsockReplyError("Transport failure: " + reply.status.status, reply));
          logInstance.trace("message rejected");
        } else {
          request.resolve(reply);
        }
      }
    }
  }, {
    key: "storeRequest",
    value: function storeRequest(id, resolve, reject) {
      var requestDescriptor = {
        resolve: resolve,
        reject: reject,
        timeout: setTimeout(function () {
          logInstance.trace("request", id, "is timed out");
          reject(new TwilsockError("Twilsock: request timeout: " + id));
        }, REQUEST_TIMEOUT$1)
      };
      this.activeRequests.set(id, requestDescriptor);
    }
  }, {
    key: "shutdown",
    value: function shutdown() {
      this.activeRequests.forEach(function (descriptor) {
        clearTimeout(descriptor.timeout);
        descriptor.reject(new TwilsockError("Twilsock: request cancelled by user"));
      });
      this.activeRequests.clear();
    }
  }, {
    key: "sendInit",
    value: function () {
      var _sendInit = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        var metadata, message, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                logInstance.trace("sendInit");
                metadata = Metadata.getMetadata(this.config);
                message = new Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);
                _context.next = 5;
                return this.sendWithReply(message);

              case 5:
                response = _context.sent;
                return _context.abrupt("return", new InitReply(response.id, response.header.continuation_token, new Set(response.header.capabilities), response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function sendInit() {
        return _sendInit.apply(this, arguments);
      }

      return sendInit;
    }()
  }, {
    key: "sendClose",
    value: function sendClose() {
      var message = new Close(); //@todo send telemetry AnyEventsIncludingUnfinished

      this.send(message);
    }
  }, {
    key: "sendWithReply",
    value: function sendWithReply(header, payload) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var id = _this2.send(header, payload);

        _this2.storeRequest(id, resolve, reject);
      });
    }
  }, {
    key: "send",
    value: function send(header, payload) {
      header.id = header.id || "TM".concat(uuid.v4());
      var message = Parser.createPacket(header, preparePayload(payload));

      try {
        this.channel.send(message);
        return header.id;
      } catch (e) {
        logInstance.debug("failed to send ", header, e);
        logInstance.trace(e.stack);
        throw e;
      }
    }
  }]);

  return PacketInterface;
}();

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var WebSocketChannel = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](WebSocketChannel, _EventEmitter);

  var _super = _createSuper$4(WebSocketChannel);

  function WebSocketChannel(url) {
    var _this;

    _classCallCheck__default['default'](this, WebSocketChannel);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "socket", null);

    _this.url = url;
    _this.url = url;
    _this.WebSocket = global["WebSocket"] || global["MozWebSocket"] || {};
    return _this;
  }

  _createClass__default['default'](WebSocketChannel, [{
    key: "isConnected",
    get: function get() {
      return !!this.socket && this.socket.readyState === 1;
    }
  }, {
    key: "connect",
    value: function connect() {
      var _this2 = this;

      logInstance.trace("connecting to socket");
      var socket;

      try {
        socket = new this.WebSocket(this.url);
      } catch (e) {
        logInstance.debug("Socket error: ".concat(this.url));
        this.emit("socketError", e);
        return;
      }

      socket.binaryType = "arraybuffer";

      socket.onopen = function () {
        logInstance.debug("socket opened ".concat(_this2.url));

        _this2.emit("connected");
      };

      socket.onclose = function (e) {
        logInstance.debug("socket closed", e);

        _this2.emit("disconnected", e);
      };

      socket.onerror = function (e) {
        logInstance.debug("Socket error:", e);

        _this2.emit("socketError", e);
      };

      socket.onmessage = function (message) {
        _this2.emit("message", message.data);
      };

      this.socket = socket;
    }
  }, {
    key: "send",
    value: function send(message) {
      return this.socket && this.socket.send(message);
    }
  }, {
    key: "close",
    value: function close() {
      logInstance.trace("closing socket");

      if (this.socket) {
        this.socket.onopen = null;
        this.socket.onclose = null;
        this.socket.onerror = null;
        this.socket.onmessage = null;

        try {
          this.socket.close();
        } finally {}
      }
    }
  }]);

  return WebSocketChannel;
}(EventEmitter);

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Registrations module handles all operations with registration contexts through twilsock.
 * Main role: it automatically refreshes all registrations after reconnect.
 */

var Registrations = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](Registrations, _EventEmitter);

  var _super = _createSuper$3(Registrations);

  function Registrations(transport) {
    var _this;

    _classCallCheck__default['default'](this, Registrations);

    _this = _super.call(this);
    _this.transport = transport;
    _this.registrations = new Map();
    _this.registrationsInProgress = new Map();
    return _this;
  }

  _createClass__default['default'](Registrations, [{
    key: "putNotificationContext",
    value: function () {
      var _putNotificationContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(contextId, context) {
        var header;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                header = {
                  method: "put_notification_ctx",
                  notification_ctx_id: contextId
                };
                _context.next = 3;
                return this.transport.sendWithReply(header, context);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function putNotificationContext(_x, _x2) {
        return _putNotificationContext.apply(this, arguments);
      }

      return putNotificationContext;
    }()
  }, {
    key: "deleteNotificationContext",
    value: function () {
      var _deleteNotificationContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(contextId) {
        var message;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                message = {
                  method: "delete_notification_ctx",
                  notification_ctx_id: contextId
                };
                _context2.next = 3;
                return this.transport.sendWithReply(message);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deleteNotificationContext(_x3) {
        return _deleteNotificationContext.apply(this, arguments);
      }

      return deleteNotificationContext;
    }()
  }, {
    key: "updateRegistration",
    value: function () {
      var _updateRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(contextId, context) {
        var registrationAttempts, attemptId;
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                logInstance.debug("update registration for context", contextId);
                registrationAttempts = this.registrationsInProgress.get(contextId);

                if (!registrationAttempts) {
                  registrationAttempts = new Set();
                  this.registrationsInProgress.set(contextId, registrationAttempts);
                }

                attemptId = uuid.v4();
                registrationAttempts.add(attemptId);
                _context3.prev = 5;
                _context3.next = 8;
                return this.putNotificationContext(contextId, context);

              case 8:
                logInstance.debug("registration attempt succeeded for context", context);
                registrationAttempts.delete(attemptId);

                if (registrationAttempts.size === 0) {
                  this.registrationsInProgress.delete(contextId);
                  this.emit("registered", contextId);
                }

                _context3.next = 19;
                break;

              case 13:
                _context3.prev = 13;
                _context3.t0 = _context3["catch"](5);
                logInstance.warn("registration attempt failed for context", context);
                logInstance.debug(_context3.t0);
                registrationAttempts.delete(attemptId);

                if (registrationAttempts.size === 0) {
                  this.registrationsInProgress.delete(contextId);
                  this.emit("registrationFailed", contextId, _context3.t0);
                }

              case 19:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[5, 13]]);
      }));

      function updateRegistration(_x4, _x5) {
        return _updateRegistration.apply(this, arguments);
      }

      return updateRegistration;
    }()
  }, {
    key: "updateRegistrations",
    value: function () {
      var _updateRegistrations = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {
        var _this2 = this;

        var promises;
        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                logInstance.trace("refreshing ".concat(this.registrations.size, " registrations"));
                promises = [];
                this.registrations.forEach(function (context, id) {
                  promises.push(_this2.updateRegistration(id, context));
                });
                _context4.next = 5;
                return Promise.all(promises);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function updateRegistrations() {
        return _updateRegistrations.apply(this, arguments);
      }

      return updateRegistrations;
    }()
  }, {
    key: "setNotificationsContext",
    value: function () {
      var _setNotificationsContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(contextId, context) {
        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(!contextId || !context)) {
                  _context5.next = 2;
                  break;
                }

                throw new TwilsockError("Invalid arguments provided");

              case 2:
                this.registrations.set(contextId, context);
                _context5.next = 5;
                return this.updateRegistration(contextId, context);

              case 5:
                return _context5.abrupt("return", _context5.sent);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function setNotificationsContext(_x6, _x7) {
        return _setNotificationsContext.apply(this, arguments);
      }

      return setNotificationsContext;
    }()
  }, {
    key: "removeNotificationsContext",
    value: function () {
      var _removeNotificationsContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(contextId) {
        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this.registrations.has(contextId)) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                _context6.next = 4;
                return this.deleteNotificationContext(contextId);

              case 4:
                if (this.transport.isConnected) {
                  this.registrations.delete(contextId);
                }

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function removeNotificationsContext(_x8) {
        return _removeNotificationsContext.apply(this, arguments);
      }

      return removeNotificationsContext;
    }()
  }]);

  return Registrations;
}(EventEmitter);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var TwilsockUpstreamError = /*#__PURE__*/function (_TwilsockError) {
  _inherits__default['default'](TwilsockUpstreamError, _TwilsockError);

  var _super = _createSuper$2(TwilsockUpstreamError);

  function TwilsockUpstreamError(status, description, body) {
    var _this;

    _classCallCheck__default['default'](this, TwilsockUpstreamError);

    _this = _super.call(this, description);
    _this.status = status;
    _this.description = description;
    _this.body = body;
    return _this;
  }

  return TwilsockUpstreamError;
}(TwilsockError);

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var TransportUnavailableError = /*#__PURE__*/function (_TwilsockError) {
  _inherits__default['default'](TransportUnavailableError, _TwilsockError);

  var _super = _createSuper$1(TransportUnavailableError);

  function TransportUnavailableError(description) {
    _classCallCheck__default['default'](this, TransportUnavailableError);

    return _super.call(this, description);
  }

  return TransportUnavailableError;
}(TwilsockError);

var REQUEST_TIMEOUT = 20000;

function isHttpSuccess(code) {
  return code >= 200 && code < 300;
}

function isHttpReply(packet) {
  return packet && packet.header && packet.header.http_status;
}

function parseUri(uri) {
  var match = uri.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/);

  if (match) {
    var uriStruct = {
      protocol: match[1],
      host: match[2],
      hostname: match[3],
      port: match[4],
      pathname: match[5],
      search: match[6],
      hash: match[7],
      params: {}
    };

    if (uriStruct.search.length > 0) {
      var paramsString = uriStruct.search.substring(1);
      uriStruct.params = paramsString.split("&").map(function (el) {
        return el.split("=");
      }).reduce(function (prev, curr) {
        if (!prev.hasOwnProperty(curr[0])) {
          prev[curr[0]] = curr[1];
        } else if (Array.isArray(prev[curr[0]])) {
          prev[curr[0]].push(curr[1]);
        } else {
          prev[curr[0]] = [prev[curr[0]], curr[1]];
        }

        return prev;
      }, {});
    }

    return uriStruct;
  }

  throw new TwilsockError("Incorrect URI: " + uri);
}

function twilsockAddress(method, uri) {
  var parsedUri = parseUri(uri);
  var to = {
    method: method,
    host: parsedUri.host,
    path: parsedUri.pathname
  };

  if (parsedUri.params) {
    to.params = parsedUri.params;
  }

  return to;
}

function twilsockParams(method, uri, headers, body, grant) {
  return {
    to: twilsockAddress(method, uri),
    headers: headers,
    body: body,
    grant: grant
  };
}

var Upstream = /*#__PURE__*/function () {
  function Upstream(transport, twilsock, config) {
    _classCallCheck__default['default'](this, Upstream);

    this.config = config;
    this.transport = transport;
    this.pendingMessages = [];
    this.twilsock = twilsock;
  }

  _createClass__default['default'](Upstream, [{
    key: "saveMessage",
    value: function saveMessage(message) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var requestDescriptor = {
          message: message,
          resolve: resolve,
          reject: reject,
          alreadyRejected: false,
          timeout: setTimeout(function () {
            logInstance.debug("request is timed out");
            reject(new TwilsockError("request '".concat(message.to.method, "' to '").concat(message.to.host, "' timed out")));
            requestDescriptor.alreadyRejected = true;
          }, REQUEST_TIMEOUT)
        };

        _this.pendingMessages.push(requestDescriptor);
      });
    }
  }, {
    key: "sendPendingMessages",
    value: function sendPendingMessages() {
      var _this2 = this;

      var _loop = function _loop() {
        var request = _this2.pendingMessages[0]; // Do not send message if we've rejected its promise already

        if (!request.alreadyRejected) {
          try {
            var message = request.message;

            _this2.actualSend(message).then(function (response) {
              return request.resolve(response);
            }).catch(function (e) {
              return request.reject(e);
            });

            clearTimeout(request.timeout);
          } catch (e) {
            logInstance.debug("Failed to send pending message", e);
            return "break";
          }
        }

        _this2.pendingMessages.splice(0, 1);
      };

      while (this.pendingMessages.length > 0) {
        var _ret = _loop();

        if (_ret === "break") break;
      }
    }
  }, {
    key: "rejectPendingMessages",
    value: function rejectPendingMessages() {
      var _this3 = this;

      this.pendingMessages.forEach(function (message) {
        message.reject(new TransportUnavailableError( // @todo Error Unhandled promise rejection!
        "Unable to connect: " + _this3.twilsock.getTerminationReason));
        message.alreadyRejected = true;
        clearTimeout(message.timeout);
      });
      this.pendingMessages.splice(0, this.pendingMessages.length);
    }
  }, {
    key: "actualSend",
    value: function () {
      var _actualSend = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(message) {
        var _message$grant;

        var address, headers, body, grant, httpRequest, upstreamMessage, reply;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                address = message.to;
                headers = message.headers;
                body = message.body;
                grant = (_message$grant = message.grant) !== null && _message$grant !== void 0 ? _message$grant : this.config.activeGrant;
                httpRequest = {
                  host: address.host,
                  path: address.path,
                  method: address.method,
                  params: address.params,
                  headers: headers
                };
                upstreamMessage = new Message(grant, headers["Content-Type"] || "application/json", httpRequest);
                logInstance.trace("Sending upstream message", upstreamMessage);
                _context.next = 9;
                return this.transport.sendWithReply(upstreamMessage, body);

              case 9:
                reply = _context.sent;
                logInstance.trace("Received upstream message response", reply);

                if (!(isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code))) {
                  _context.next = 13;
                  break;
                }

                throw new TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);

              case 13:
                return _context.abrupt("return", {
                  status: reply.header.http_status,
                  headers: reply.header.http_headers,
                  body: reply.body
                });

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function actualSend(_x) {
        return _actualSend.apply(this, arguments);
      }

      return actualSend;
    }()
    /**
     * Send an upstream message
     * @param {string} method The upstream method
     * @param {string} url URL to send the message to
     * @param {object} [headers] The message headers
     * @param {any} [body] The message body
     * @param {string} [grant] The product grant
     * @returns {Promise<Result>} Result from remote side
     */

  }, {
    key: "send",
    value: function send(method, url) {
      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var grant = arguments.length > 4 ? arguments[4] : undefined;

      if (this.twilsock.isTerminalState) {
        return Promise.reject(new TransportUnavailableError("Unable to connect: " + this.twilsock.getTerminationReason));
      }

      var twilsockMessage = twilsockParams(method, url, headers, body, grant);

      if (!this.twilsock.isConnected) {
        return this.saveMessage(twilsockMessage);
      }

      return this.actualSend(twilsockMessage);
    }
  }]);

  return Upstream;
}();

var Deferred = /*#__PURE__*/function () {
  function Deferred() {
    var _this = this;

    _classCallCheck__default['default'](this, Deferred);

    this._promise = new Promise(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  }

  _createClass__default['default'](Deferred, [{
    key: "promise",
    get: function get() {
      return this._promise;
    }
  }, {
    key: "update",
    value: function update(value) {
      this._resolve(value);
    }
  }, {
    key: "set",
    value: function set(value) {
      this._resolve(value);
    }
  }, {
    key: "fail",
    value: function fail(e) {
      this._reject(e);
    }
  }]);

  return Deferred;
}();

var OfflineProductStorage = /*#__PURE__*/function () {
  function OfflineProductStorage(id) {
    _classCallCheck__default['default'](this, OfflineProductStorage);

    this.id = id;
  }

  _createClass__default['default'](OfflineProductStorage, null, [{
    key: "create",
    value: function create(productPayload) {
      if (productPayload instanceof Object && "storage_id" in productPayload) {
        return new OfflineProductStorage(productPayload.storage_id);
      } else {
        throw new TwilsockError('Field "storage_id" is missing');
      }
    }
  }]);

  return OfflineProductStorage;
}();

var TokenStorage = /*#__PURE__*/function () {
  function TokenStorage() {
    _classCallCheck__default['default'](this, TokenStorage);

    _defineProperty__default['default'](this, "initializedFlag", "twilio_twilsock_token_storage");

    _defineProperty__default['default'](this, "tokenStoragePrefix", "twilio_continuation_token_");

    if (!TokenStorage._instance) {
      this.initialize();
      TokenStorage._instance = this;
    }

    return TokenStorage._instance;
  }

  _createClass__default['default'](TokenStorage, [{
    key: "sessionStorage",
    value: function sessionStorage() {
      try {
        return global["sessionStorage"];
      } catch (err) {
        return null;
      }
    }
  }, {
    key: "window",
    value: function window() {
      try {
        return global["window"];
      } catch (err) {
        return null;
      }
    }
  }, {
    key: "storeToken",
    value: function storeToken(continuationToken, productId) {
      if (this.canStore()) {
        this.sessionStorage.setItem(this.getKeyName(productId), continuationToken);
      }
    }
  }, {
    key: "getStoredToken",
    value: function getStoredToken(productId) {
      if (!this.canStore()) {
        return null;
      }

      return this.sessionStorage.getItem(this.getKeyName(productId));
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var _this = this;

      if (this.canStore()) {
        var flag = this.sessionStorage.getItem(this.initializedFlag); // Duplicated tab, cleaning up all stored keys

        if (flag) {
          this.clear();
        }

        this.sessionStorage.setItem(this.initializedFlag, "true"); // When leaving page or refreshing

        var removeStorageItem = this.sessionStorage.removeItem;
        this.window.addEventListener("unload", function () {
          removeStorageItem(_this.initializedFlag);
        });
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.canStore()) {
        var keyToDelete = [];

        for (var i = 0; i < this.sessionStorage.length; i++) {
          var key = this.sessionStorage.key(i); // We manually removed startsWith here due to some problems with babel polyfill setup.
          // Restore it when we figure out what's wrong.
          //if (key.startsWith(TokenStorage.tokenStoragePrefix)) {

          if (key && key.indexOf(this.tokenStoragePrefix) === 0) {
            keyToDelete.push(key);
          }
        }

        var removeStorageItem = this.sessionStorage.removeItem;
        keyToDelete.forEach(function (key) {
          return removeStorageItem(key);
        });
        removeStorageItem(this.initializedFlag);
      }
    }
  }, {
    key: "getKeyName",
    value: function getKeyName(productId) {
      return "".concat(this.tokenStoragePrefix).concat(productId);
    }
  }, {
    key: "canStore",
    value: function canStore() {
      return !!(this.sessionStorage && this.sessionStorage.length && this.window);
    }
  }]);

  return TokenStorage;
}();

_defineProperty__default['default'](TokenStorage, "_instance", null);

var TokenStorage$1 = new TokenStorage();

var TelemetryEventDescription = /*#__PURE__*/function () {
  function TelemetryEventDescription(title, details, start, end, type, id) {
    _classCallCheck__default['default'](this, TelemetryEventDescription);

    this.title = title;
    this.details = details;
    this.start = start;
    this.type = type;
    this.id = id;
    this.end = end;
  } // Prepare telemetry event right before sending it.
  // Convert times to relative.


  _createClass__default['default'](TelemetryEventDescription, [{
    key: "toTelemetryEvent",
    value: function toTelemetryEvent() {
      // Fix dates
      var now = new Date();
      var actualStart = this.start;
      var actualEnd = this.end ? this.end : now;

      if (actualEnd < actualStart) {
        var tmp = actualEnd;
        actualEnd = actualStart;
        actualStart = tmp;
      } // Converting dates to relative offset from current moment in ms


      var startOffset = actualStart.getTime() - now.getTime();
      var endOffset = actualEnd.getTime() - now.getTime();
      var result = new TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);
      return result;
    }
  }]);

  return TelemetryEventDescription;
}();

exports.TelemetryPoint = void 0;

(function (TelemetryPoint) {
  TelemetryPoint[TelemetryPoint["Start"] = 0] = "Start";
  TelemetryPoint[TelemetryPoint["End"] = 1] = "End";
})(exports.TelemetryPoint || (exports.TelemetryPoint = {}));

exports.EventSendingLimitation = void 0;

(function (EventSendingLimitation) {
  EventSendingLimitation[EventSendingLimitation["MinEventsPortion"] = 0] = "MinEventsPortion";
  EventSendingLimitation[EventSendingLimitation["AnyEvents"] = 1] = "AnyEvents";
  EventSendingLimitation[EventSendingLimitation["AnyEventsIncludingUnfinished"] = 2] = "AnyEventsIncludingUnfinished";
})(exports.EventSendingLimitation || (exports.EventSendingLimitation = {}));

var TelemetryTracker = /*#__PURE__*/function () {
  // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)
  // max events batch size to be sent in a single Telemetry message
  // started events: have TelemetryEvent::startTime only
  // events ready to send
  function TelemetryTracker(config, packetInterface) {
    _classCallCheck__default['default'](this, TelemetryTracker);

    _defineProperty__default['default'](this, "minEventsPortionToSend", 50);

    _defineProperty__default['default'](this, "maxEventsPortionToSend", 100);

    _defineProperty__default['default'](this, "pendingEvents", new Map());

    _defineProperty__default['default'](this, "readyEvents", []);

    _defineProperty__default['default'](this, "hasInitializationFinished", false);

    _defineProperty__default['default'](this, "_canSendTelemetry", false);

    this.config = config;
    this.packetInterface = packetInterface;
  } // Keeping this private prevents the type declaration from being generated properly.
  // Ideally, this should be private.


  _createClass__default['default'](TelemetryTracker, [{
    key: "isTelemetryEnabled",
    get: function get() {
      return this.config.confirmedCapabilities.has("telemetry.v1");
    }
  }, {
    key: "canSendTelemetry",
    get: function get() {
      return this._canSendTelemetry && this.isTelemetryEnabled;
    },
    set: function set(enable) {
      logInstance.debug("TelemetryTracker.canSendTelemetry: ".concat(enable, " TelemetryTracker.isTelemetryEnabled: ").concat(this.isTelemetryEnabled)); // We want to keep telemetry events added in advance but
      // we need to purge events from previous connection when being disconnected

      if (this._canSendTelemetry && !enable) {
        this.pendingEvents.clear();
        this.readyEvents = [];
      }

      this._canSendTelemetry = enable;

      if (enable) {
        this.sendTelemetry(exports.EventSendingLimitation.AnyEvents);
      }

      if (enable && !this.hasInitializationFinished) {
        this.hasInitializationFinished = true;
      }
    } // Add complete event

  }, {
    key: "addTelemetryEvent",
    value: function addTelemetryEvent(event) {
      // Allow adding events before initialization.
      if (!this.canSendTelemetry && this.hasInitializationFinished) {
        return;
      }

      this.readyEvents.push(event);
    } // Add incomplete event (with either starting or ending time point)

  }, {
    key: "addPartialEvent",
    value: function addPartialEvent(incompleteEvent, eventKey, point) {
      logInstance.debug("Adding ".concat(point === exports.TelemetryPoint.Start ? "starting" : "ending", " timepoint for '").concat(eventKey, "' event"));
      var exists = this.pendingEvents.has(eventKey);

      if (point === exports.TelemetryPoint.Start) {
        if (exists) {
          logInstance.debug("Overwriting starting point for '".concat(eventKey, "' event"));
        }

        this.pendingEvents.set(eventKey, incompleteEvent);
      } else {
        if (!exists) {
          logInstance.info("Could not find started event for '".concat(eventKey, "' event"));
          return;
        }

        this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));
        this.pendingEvents.delete(eventKey);
      }
    }
  }, {
    key: "getTelemetryToSend",
    value: function getTelemetryToSend(sendingLimit) {
      if (!this.canSendTelemetry || this.readyEvents.length == 0) {
        return []; // Events are collected but not sent until telemetry is enabled
      }

      if (sendingLimit == exports.EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {
        return [];
      }

      return this.getTelemetryPortion(sendingLimit == exports.EventSendingLimitation.AnyEventsIncludingUnfinished);
    }
  }, {
    key: "getTelemetryPortion",
    value: function getTelemetryPortion(includeUnfinished) {
      var _this = this;

      var eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);
      var res = this.readyEvents.splice(0, eventsPortionToSend);

      if (includeUnfinished && res.length < this.maxEventsPortionToSend) {
        this.pendingEvents.forEach(function (value, key) {
          if (res.length >= _this.maxEventsPortionToSend) {
            return; // @fixme does not end the loop early
          }

          var event = _this.pendingEvents.get(key);

          _this.pendingEvents.delete(key);

          res.push(new TelemetryEventDescription("[UNFINISHED] ".concat(event.title), // add prefix title to mark unfinished events for CleanSock
          event.details, event.start, null, // Not ended, on sending will be replaced with now
          event.type, event.id));
        });
      }

      return res;
    } // Merging 2 partial events:
    //   use start.startTime & end.endTime.
    // For other fields,
    //   if there are values in end, use them,
    //   else use values from start.

  }, {
    key: "merge",
    value: function merge(start, end) {
      return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);
    }
  }, {
    key: "sendTelemetryIfMinimalPortionCollected",
    value: function sendTelemetryIfMinimalPortionCollected() {
      this.sendTelemetry(exports.EventSendingLimitation.MinEventsPortion);
    } // NB: getTelemetryToSend will return non-empty array only if we have already received initReply
    // and telemetry.v1 capability is enabled there.

  }, {
    key: "sendTelemetry",
    value: function sendTelemetry(limit) {
      var events = this.getTelemetryToSend(limit);

      if (events.length === 0) {
        return; // not enough telemetry data collected
      }

      try {
        this.packetInterface.send(new Telemetry(events.map(function (e) {
          return e.toTelemetryEvent();
        })));
      } catch (err) {
        logInstance.debug("Error while sending ".concat(events.length, " telemetry events due to ").concat(err, "; they will be resubmitted"));
        this.readyEvents = this.readyEvents.concat(events);
      }
    }
  }]);

  return TelemetryTracker;
}();

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var TelemetryEvents = function TelemetryEvents() {
  _classCallCheck__default['default'](this, TelemetryEvents);
};
/**
 * @alias Twilsock
 * @classdesc Client library for the Twilsock service
 * It allows to recevie service-generated updates as well as bi-directional transport
 * @fires Twilsock#message
 * @fires Twilsock#connected
 * @fires Twilsock#disconnected
 * @fires Twilsock#tokenAboutToExpire
 * @fires Twilsock#tokenExpired
 * @fires Twilsock#stateChanged
 * @fires Twilsock#connectionError
 */

_defineProperty__default['default'](TelemetryEvents, "TWILSOCK_CONNECT", "twilsock.sdk.connect");

_defineProperty__default['default'](TelemetryEvents, "TWILSOCK_INIT", "twilsock.sdk.init");

exports.TwilsockClient = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](TwilsockClient, _EventEmitter);

  var _super = _createSuper(TwilsockClient);

  /**
   * @param {string} token Twilio access token
   * @param {string} productId Product identifier. Should be the same as a grant name in token
   * @param {object} options Twilsock configuration options
   */
  function TwilsockClient(token, productId, options) {
    var _this;

    _classCallCheck__default['default'](this, TwilsockClient);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "version", version);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "offlineStorageDeferred", new Deferred());

    options.continuationToken = options.continuationToken ? options.continuationToken : TokenStorage$1.getStoredToken(productId);
    var config = _this.config = new Configuration(token, productId, options);
    logInstance.setLevel(config.logLevel);
    var websocket = new WebSocketChannel(config.url);
    var transport = new PacketInterface(websocket, config);
    _this.channel = new TwilsockChannel(websocket, transport, config);
    _this.registrations = new Registrations(transport);
    _this.upstream = new Upstream(transport, _this.channel, config); // Send telemetry only when connected and initialised

    _this.telemetryTracker = new TelemetryTracker(config, transport);

    _this.channel.on("initialized", function () {
      return _this.telemetryTracker.canSendTelemetry = true;
    });

    websocket.on("disconnected", function () {
      return _this.telemetryTracker.canSendTelemetry = false;
    });

    _this.registrations.on("registered", function (id) {
      return _this.emit("registered", id);
    });

    _this.channel.on("message", function (type, message) {
      return setTimeout(function () {
        return _this.emit("message", type, message);
      }, 0);
    });

    _this.channel.on("stateChanged", function (state) {
      return setTimeout(function () {
        return _this.emit("stateChanged", state);
      }, 0);
    });

    _this.channel.on("connectionError", function (connectionError) {
      return setTimeout(function () {
        return _this.emit("connectionError", connectionError);
      }, 0);
    });

    _this.channel.on("tokenAboutToExpire", function () {
      return setTimeout(function () {
        return _this.emit("tokenAboutToExpire");
      }, 0);
    });

    _this.channel.on("tokenExpired", function () {
      return setTimeout(function () {
        return _this.emit("tokenExpired");
      }, 0);
    });

    _this.channel.on("connected", function () {
      return _this.registrations.updateRegistrations();
    });

    _this.channel.on("connected", function () {
      return _this.upstream.sendPendingMessages();
    });

    _this.channel.on("connected", function () {
      return setTimeout(function () {
        return _this.emit("connected");
      }, 0);
    }); // Twilsock telemetry events


    _this.channel.on("beforeConnect", function () {
      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Establish WebSocket connection", "", new Date()), TelemetryEvents.TWILSOCK_CONNECT, exports.TelemetryPoint.Start);
    });

    _this.channel.on("connected", function () {
      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Establish WebSocket connection", "", new Date(), new Date()), TelemetryEvents.TWILSOCK_CONNECT, exports.TelemetryPoint.End);
    });

    _this.channel.on("beforeSendInit", function () {
      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "", new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.Start);
    });

    _this.channel.on("initialized", function () {
      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "Succeeded", new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.End);
    });

    _this.channel.on("sendInitFailed", function () {
      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "Failed", new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.End);
    });

    _this.channel.on("initialized", function (initReply) {
      _this.handleStorageId(productId, initReply);

      TokenStorage$1.storeToken(initReply.continuationToken, productId);
      setTimeout(function () {
        return _this.emit("initialized", initReply);
      }, 0);
    });

    _this.channel.on("disconnected", function () {
      return setTimeout(function () {
        return _this.emit("disconnected");
      }, 0);
    });

    _this.channel.on("disconnected", function () {
      return _this.upstream.rejectPendingMessages();
    });

    _this.channel.on("disconnected", function () {
      return _this.offlineStorageDeferred.fail(new TwilsockError("Client disconnected"));
    });

    _this.offlineStorageDeferred.promise.catch(function () {
      return void 0;
    });

    return _this;
  }

  _createClass__default['default'](TwilsockClient, [{
    key: "emit",
    value: function emit(event) {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      logInstance.debug("Emitting ".concat(event.toString(), "(").concat(args.map(function (a) {
        return JSON.stringify(a);
      }).join(", "), ")"));
      return (_get2 = _get__default['default'](_getPrototypeOf__default['default'](TwilsockClient.prototype), "emit", this)).call.apply(_get2, [this, event].concat(args));
    }
  }, {
    key: "handleStorageId",
    value: function handleStorageId(productId, initReply) {
      if (!initReply.offlineStorage) {
        this.offlineStorageDeferred.fail(new TwilsockError("No offline storage id"));
      } else if (initReply.offlineStorage.hasOwnProperty(productId)) {
        try {
          this.offlineStorageDeferred.set(OfflineProductStorage.create(initReply.offlineStorage[productId]));
          logInstance.debug("Offline storage for '".concat(productId, "' product: ").concat(JSON.stringify(initReply.offlineStorage[productId]), "."));
        } catch (e) {
          this.offlineStorageDeferred.fail(new TwilsockError("Failed to parse offline storage for ".concat(productId, " ").concat(JSON.stringify(initReply.offlineStorage[productId]), ". ").concat(e, ".")));
        }
      } else {
        this.offlineStorageDeferred.fail(new TwilsockError("No offline storage id for '".concat(productId, "' product: ").concat(JSON.stringify(initReply.offlineStorage))));
      }
    }
    /**
     * Get offline storage ID
     * @returns {Promise}
     */

  }, {
    key: "storageId",
    value: function storageId() {
      return this.offlineStorageDeferred.promise;
    }
    /**
     * Indicates if twilsock is connected now
     * @returns {Boolean}
     */

  }, {
    key: "isConnected",
    get: function get() {
      return this.channel.isConnected;
    }
    /**
     * Current state
     * @returns {ConnectionState}
     */

  }, {
    key: "state",
    get: function get() {
      return this.channel.state;
    }
    /**
     * Update token
     * @param {String} token
     * @returns {Promise}
     */

  }, {
    key: "updateToken",
    value: function () {
      var _updateToken = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(token) {
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                logInstance.trace("updating token '".concat(token, "'"));

                if (!(this.config.token === token)) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                this.config.updateToken(token);
                _context.next = 6;
                return this.channel.updateToken(token);

              case 6:
                return _context.abrupt("return", _context.sent);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function updateToken(_x) {
        return _updateToken.apply(this, arguments);
      }

      return updateToken;
    }()
    /**
     * Updates notification context.
     * This method shouldn't be used anyone except twilio notifications library
     * @param contextId id of notification context
     * @param context value of notification context
     * @private
     */

  }, {
    key: "setNotificationsContext",
    value: function () {
      var _setNotificationsContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(contextId, context) {
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.registrations.setNotificationsContext(contextId, context);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setNotificationsContext(_x2, _x3) {
        return _setNotificationsContext.apply(this, arguments);
      }

      return setNotificationsContext;
    }()
    /**
     * Remove notification context.
     * This method shouldn't be used anyone except twilio notifications library
     * @param contextId id of notification context
     * @private
     */

  }, {
    key: "removeNotificationsContext",
    value: function () {
      var _removeNotificationsContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(contextId) {
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.registrations.removeNotificationsContext(contextId);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function removeNotificationsContext(_x4) {
        return _removeNotificationsContext.apply(this, arguments);
      }

      return removeNotificationsContext;
    }()
    /**
     * Connect to the server
     * @fires Twilsock#connected
     * @public
     * @returns {void}
     */

  }, {
    key: "connect",
    value: function connect() {
      return this.channel.connect();
    }
    /**
     * Disconnect from the server
     * @fires Twilsock#disconnected
     * @public
     * @returns {Promise}
     */

  }, {
    key: "disconnect",
    value: function () {
      var _disconnect = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {
        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEventsIncludingUnfinished);
                _context4.next = 3;
                return this.channel.disconnect();

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function disconnect() {
        return _disconnect.apply(this, arguments);
      }

      return disconnect;
    }()
    /**
     * Get HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */

  }, {
    key: "get",
    value: function () {
      var _get3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(url, headers, grant) {
        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment

                _context5.next = 3;
                return this.upstream.send("GET", url, headers, undefined, grant);

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function get(_x5, _x6, _x7) {
        return _get3.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Post HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */

  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(url, headers, body, grant) {
        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment

                _context6.next = 3;
                return this.upstream.send("POST", url, headers, body, grant);

              case 3:
                return _context6.abrupt("return", _context6.sent);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function post(_x8, _x9, _x10, _x11) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
    /**
     * Put HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */

  }, {
    key: "put",
    value: function () {
      var _put = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(url, headers, body, grant) {
        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment

                _context7.next = 3;
                return this.upstream.send("PUT", url, headers, body, grant);

              case 3:
                return _context7.abrupt("return", _context7.sent);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function put(_x12, _x13, _x14, _x15) {
        return _put.apply(this, arguments);
      }

      return put;
    }()
    /**
     * Delete HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */

  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8(url, headers, body, grant) {
        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment

                _context8.next = 3;
                return this.upstream.send("DELETE", url, headers, body, grant);

              case 3:
                return _context8.abrupt("return", _context8.sent);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _delete(_x16, _x17, _x18, _x19) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /**
     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
     * @param {TelemetryEventDescription} event Event details.
     * @returns {void}
     */

  }, {
    key: "addTelemetryEvent",
    value: function addTelemetryEvent(event) {
      this.telemetryTracker.addTelemetryEvent(event);
      this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need
    }
    /**
     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
     * @param {TelemetryEventDescription} event Event details.
     * @param {string} eventKey Unique event key.
     * @param {TelemetryPoint} point Is this partial event for start or end of measurement.
     * @returns {void}
     */

  }, {
    key: "addPartialTelemetryEvent",
    value: function addPartialTelemetryEvent(event, eventKey, point) {
      this.telemetryTracker.addPartialEvent(event, eventKey, point);

      if (point === exports.TelemetryPoint.End) {
        // this telemetry event is complete, so minimal portion could become ready to send
        this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need
      }
    }
  }]);

  return TwilsockClient;
}(EventEmitter);

exports.TwilsockClient = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.pureObject, "undefined", declarativeTypeValidator.literal(null)]), __metadata("design:paramtypes", [String, String, Object])], exports.TwilsockClient);
/**
 * Twilsock destination address descriptor
 * @typedef {Object} Twilsock#Address
 * @property {String} method - HTTP method. (POST, PUT, etc)
 * @property {String} host - host name without path. (e.g. my.company.com)
 * @property {String} path - path on the host (e.g. /my/app/to/call.php)
 */

/**
 * Twilsock upstream message
 * @typedef {Object} Twilsock#Message
 * @property {Twilsock#Address} to - destination address
 * @property {Object} headers - HTTP headers
 * @property {Object} body - Body
 */

/**
 * Fired when new message received
 * @param {Twilsock#Message} message
 * @event Twilsock#message
 */

/**
 * Fired when socket connected
 * @param {String} URI of endpoint
 * @event Twilsock#connected
 */

/**
 * Fired when socket disconnected
 * @event Twilsock#disconnected
 */

/**
 * Fired when token is about to expire and should be updated
 * @event Twilsock#tokenAboutToExpire
 */

/**
 * Fired when token has expired and connection is aborted
 * @event Twilsock#tokenExpired
 */

/**
 * Fired when socket connected
 * @param ConnectionState state - general twilsock state
 * @event Twilsock#stateChanged
 */

/**
 * Fired when connection is interrupted by unexpected reason
 * @type {Object}
 * @property {Boolean} terminal - twilsock will stop connection attempts
 * @property {String} message - root cause
 * @property {Number} [httpStatusCode] - http status code if available
 * @property {Number} [errorCode] - Twilio public error code if available
 * @event Twilsock#connectionError
 */

var InitRegistration = /*#__PURE__*/function () {
  // It's a Set<string> but TS cannot serialize Sets properly.
  function InitRegistration(product) {
    _classCallCheck__default['default'](this, InitRegistration);

    this.product = product;
    this.type = "ers";
    this.notification_protocol_version = 0;
    this.message_types = [];
  }
  /*
   * @internal
   *
   * Populate init registrations section in the Twilsock configuration generically with
   * passed-in list of types to register.
   *
   * Used only by the SDK, ignore.
   *
   * @param {string[]} types List of types to add to init registrations in options.
   * @param {object} options Twilsock options object to update. Omit to create a new one.
   */


  _createClass__default['default'](InitRegistration, [{
    key: "populateInitRegistrations",
    value: function populateInitRegistrations(types) {
      var s = new Set(this.message_types); // Update options reference in place

      for (var idx in types) {
        s.add(types[idx]);
      }

      this.message_types = Array.from(s);
    }
  }]);

  return InitRegistration;
}();

exports.InitRegistration = InitRegistration;
exports.TelemetryEventDescription = TelemetryEventDescription;
exports.TelemetryTracker = TelemetryTracker;
exports.TransportUnavailableError = TransportUnavailableError;
exports.Twilsock = exports.TwilsockClient;
exports.TwilsockError = TwilsockError;
//# sourceMappingURL=browser.js.map
