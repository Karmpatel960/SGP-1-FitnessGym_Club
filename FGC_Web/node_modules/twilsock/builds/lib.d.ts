/// <reference types="node" />
import { EventEmitter } from "events";
import { LogLevelDesc } from "loglevel";
declare class InitRegistration {
    product: string;
    type: string;
    notification_protocol_version: number;
    message_types: string[]; // It's a Set<string> but TS cannot serialize Sets properly.
    constructor(product: string);
    /*
    * @internal
    *
    * Populate init registrations section in the Twilsock configuration generically with
    * passed-in list of types to register.
    *
    * Used only by the SDK, ignore.
    *
    * @param {string[]} types List of types to add to init registrations in options.
    * @param {object} options Twilsock options object to update. Omit to create a new one.
    */
    populateInitRegistrations(types: string[]): void;
}
type RetryPolicyType = {
    min: number;
    max: number;
    initial?: number;
    maxAttemptsCount?: number;
    maxAttemptsTime?: number;
    randomness?: number;
};
/**
 * Settings container for the Twilsock client library
 */
declare class Configuration {
    private _token;
    private _continuationToken;
    confirmedCapabilities: Set<string>;
    readonly retryPolicy: RetryPolicyType;
    readonly url: string;
    readonly activeGrant: string;
    readonly logLevel: LogLevelDesc;
    readonly clientMetadata: Record<string, unknown>;
    readonly initRegistrations: InitRegistration[] | null;
    readonly tweaks: Record<string, unknown> | null;
    /**
     * @param {String} token - authentication token
     * @param {Object} options - options to override defaults
     */
    constructor(token: string, activeGrant: string, options: Partial<ClientOptionsType>);
    get token(): string;
    get continuationToken(): string | null;
    updateToken(token: string): void;
    updateContinuationToken(continuationToken: string): void;
}
declare namespace Messages {
    type MessageType = "notification" | "message" | "reply" | "ping" | "close" | "init" | "telemetry.v1" | "client_update";
    type Method = "GET" | "POST" | "PUT" | "DELETE" | "put_notification_ctx" | "delete_notification_ctx";
    type Headers = {
        [id: string]: string;
    };
    type Params = {
        [id: string]: string;
    };
    interface Request {
        host: string;
        path: string;
        method: Method;
        headers: Headers;
        params: Params;
    }
    interface Address {
        method: Method;
        host: string;
        path: string;
        headers: Headers;
        params: Params;
    }
    type StatusType = {
        status: string;
        description?: string;
        code: number;
        errorCode?: number;
    };
    interface Header {
        method: MessageType;
        id: string;
        payload_type?: string;
        payload_size?: number;
        notification_ctx_id?: string;
        http_request?: Request;
        http_status?: Record<string, unknown>;
        http_headers?: Headers;
        continuation_token_status?: Record<string, unknown>;
        capabilities?: string[];
        token?: string;
        active_grant?: string;
        status: StatusType;
        message_type?: string;
        client_update_type?: string;
        offline_storage?: Record<string, unknown>;
        continuation_token?: string | null;
        events?: unknown[];
    }
    type Context<T extends Record<string, unknown> = Record<string, unknown>> = T & {
        backoff_policy?: {
            reconnect_min_ms: number;
            reconnect_max_ms: number;
        };
        headers?: Record<string, string>;
    };
    class AbstractMessage {
        readonly id: string;
        constructor(id?: string);
    }
    class InitRegistration {
        product: string;
        type: string;
        notification_protocol_version: number;
        message_types: string[]; // It's a Set<string> but TS cannot serialize Sets properly.
        constructor(product: string);
        /*
        * @internal
        *
        * Populate init registrations section in the Twilsock configuration generically with
        * passed-in list of types to register.
        *
        * Used only by the SDK, ignore.
        *
        * @param {string[]} types List of types to add to init registrations in options.
        * @param {object} options Twilsock options object to update. Omit to create a new one.
        */
        populateInitRegistrations(types: string[]): void;
    }
    class Init extends AbstractMessage {
        readonly method: MessageType;
        readonly token: string;
        readonly continuation_token: string | null;
        readonly capabilities: string[];
        readonly metadata?: Record<string, unknown>;
        readonly registrations?: InitRegistration[] | null;
        readonly tweaks?: Record<string, unknown> | null;
        constructor(token: string, continuationToken: string | null, metadata?: Record<string, unknown>, registrations?: InitRegistration[] | null, tweaks?: Record<string, unknown> | null);
    }
    interface ContinuationTokenStatus {
        reissued: boolean;
        reissue_message: string;
    }
    class InitReply extends AbstractMessage {
        readonly continuationToken: string;
        readonly continuationTokenStatus?: ContinuationTokenStatus;
        readonly offlineStorage?: string;
        readonly initRegistrations?: string;
        readonly debugInfo?: string;
        readonly confirmedCapabilities: Set<string>;
        constructor(id: string, continuationToken: string, confirmedCapabilities: Set<string>, continuationTokenStatus?: ContinuationTokenStatus, offlineStorage?: string, initRegistrations?: string, debugInfo?: string);
    }
    class Update extends AbstractMessage {
        readonly method: MessageType;
        readonly token: string;
        constructor(token: string);
    }
    class Message extends AbstractMessage {
        readonly method: MessageType;
        readonly active_grant: string;
        readonly payload_type: string;
        readonly http_request: Request;
        constructor(grant: string, contentType: string, request: Request);
    }
    type ReplyType = {
        id: string;
        method?: MessageType;
        payload_type?: string;
        status: {
            status: string;
            code: number;
            errorCode?: number;
            description?: string;
        };
        header: Header;
        body: string;
    };
    class Reply extends AbstractMessage {
        readonly method = "reply";
        readonly payload_type = "application/json";
        readonly status: {
            code: number;
            status: string;
        };
        readonly header: any;
        readonly body: any;
        constructor(id: string);
    }
    class Close extends AbstractMessage {
        readonly method: MessageType;
        constructor();
    }
    class TelemetryEvent {
        readonly start: number;
        // relative to event send time
        readonly end: number;
        // relative to event send time
        readonly title: string;
        readonly details: string;
        readonly id?: string | undefined;
        // optional, default will be random assigned by backend
        readonly type?: string | undefined;
        constructor(start: number, end: number, title: string, details: string, id?: string | undefined, type?: string | undefined); // optional, default will be "SDK" assigned by backend
    }
    class Telemetry extends AbstractMessage {
        readonly method: MessageType;
        events: TelemetryEvent[];
        constructor(events: TelemetryEvent[]);
    }
}
interface PacketResponse {
    id: string;
    header: {
        continuation_token: string;
        continuation_token_status?: ContinuationTokenStatus;
        offline_storage: string;
        init_registrations: string;
        debug_info: string;
        capabilities: string[];
        http_status: {
            status: string;
            code: number;
            errorCode?: string;
        };
        http_headers: Headers;
    };
    body: Context;
}
type MessageType = "notification" | "message" | "reply" | "ping" | "close" | "init" | "telemetry.v1" | "client_update";
type Method = "GET" | "POST" | "PUT" | "DELETE" | "put_notification_ctx" | "delete_notification_ctx";
type Headers = {
    [id: string]: string;
};
type Params = {
    [id: string]: string;
};
interface Request {
    host: string;
    path: string;
    method: Method;
    headers: Headers;
    params: Params;
}
type StatusType = {
    status: string;
    description?: string;
    code: number;
    errorCode?: number;
};
interface Header {
    method: MessageType;
    id: string;
    payload_type?: string;
    payload_size?: number;
    notification_ctx_id?: string;
    http_request?: Request;
    http_status?: Record<string, unknown>;
    http_headers?: Headers;
    continuation_token_status?: Record<string, unknown>;
    capabilities?: string[];
    token?: string;
    active_grant?: string;
    status: StatusType;
    message_type?: string;
    client_update_type?: string;
    offline_storage?: Record<string, unknown>;
    continuation_token?: string | null;
    events?: unknown[];
}
type Context<T extends Record<string, unknown> = Record<string, unknown>> = T & {
    backoff_policy?: {
        reconnect_min_ms: number;
        reconnect_max_ms: number;
    };
    headers?: Record<string, string>;
};
interface Channel extends EventEmitter {
    isConnected: boolean;
    send(message: ArrayBuffer): void;
}
declare class AbstractMessage {
    readonly id: string;
    constructor(id?: string);
}
interface ContinuationTokenStatus {
    reissued: boolean;
    reissue_message: string;
}
type ReplyType = {
    id: string;
    method?: MessageType;
    payload_type?: string;
    status: {
        status: string;
        code: number;
        errorCode?: number;
        description?: string;
    };
    header: Header;
    body: string;
};
declare class PacketInterface {
    private readonly config;
    private readonly activeRequests;
    private readonly channel;
    constructor(channel: Channel, config: Configuration);
    get isConnected(): boolean;
    processReply(reply: ReplyType): void;
    private storeRequest;
    shutdown(): void;
    sendInit(): Promise<Messages.InitReply>;
    sendClose(): void;
    sendWithReply(header: Partial<Header>, payload?: Context): Promise<PacketResponse>;
    send(header: Partial<Header>, payload?: Context): string;
}
declare class WebSocketChannel extends EventEmitter implements Channel {
    private readonly url;
    private readonly WebSocket;
    private socket;
    constructor(url: string);
    get isConnected(): boolean;
    connect(): void;
    send(message: ArrayBuffer): void | null;
    close(): void;
}
/**
 * Twilsock channel level protocol implementation
 */
declare class TwilsockChannel extends EventEmitter {
    private readonly config;
    private readonly fsm;
    private disconnectingTimer;
    private disconnectedPromiseResolve;
    private retrier;
    private websocket;
    private transport;
    private readonly terminalStates;
    private lastEmittedState;
    private readonly tokenExpiredSasCode;
    private terminationReason;
    constructor(websocket: WebSocketChannel, transport: PacketInterface, config: Configuration);
    private changeState;
    private resetBackoff;
    private modifyBackoff;
    private startDisconnectTimer;
    private cancelDisconnectTimer;
    get isConnected(): boolean;
    get state(): ConnectionState;
    private initRetry;
    private retry;
    private onConnected;
    private finalizeSocket;
    private setupSocket;
    private onIncomingMessage;
    private sendInit;
    private sendUpdate;
    private emitReplyConnectionError;
    private cancelInit;
    private cancelUpdate;
    /**
     * Should be called for each message to confirm it received
     */
    private confirmReceiving;
    /**
     * Shutdown connection
     */
    private closeSocket;
    /**
     * Initiate the twilsock connection
     * If already connected, it does nothing
     */
    connect(): void;
    /**
     * Close twilsock connection
     * If already disconnected, it does nothing
     */
    disconnect(): Promise<void>;
    /**
     * Update fpa token for twilsock connection
     */
    updateToken(token: string): Promise<void>;
    get isTerminalState(): boolean;
    get getTerminationReason(): string;
    private onCloseReceived;
}
/**
 * Registrations module handles all operations with registration contexts through twilsock.
 * Main role: it automatically refreshes all registrations after reconnect.
 */
declare class Registrations extends EventEmitter {
    private readonly transport;
    private readonly registrations;
    private readonly registrationsInProgress;
    constructor(transport: PacketInterface);
    private putNotificationContext;
    private deleteNotificationContext;
    private updateRegistration;
    updateRegistrations(): Promise<void>;
    setNotificationsContext(contextId: string, context: Context): Promise<void>;
    removeNotificationsContext(contextId: string): Promise<void>;
}
interface Result<T = undefined> {
    status: {
        code: number;
        status: string;
    };
    headers: Headers;
    body: T;
}
interface Transport extends EventEmitter {
    readonly isConnected: boolean;
    readonly state: string;
    get<T>(url: string, headers: Headers, grant?: string): Promise<Result<T>>;
    post<T>(url: string, headers: Headers, body: string | Context, grant?: string): Promise<Result<T>>;
    put<T>(url: string, headers: Headers, body: Context, grant?: string): Promise<Result<T>>;
    delete<T>(url: string, headers: Headers, body?: Context, grant?: string): Promise<Result<T>>;
}
declare class OfflineProductStorage {
    readonly id: string;
    constructor(id: string);
    static create(productPayload: {
        storage_id: string;
    }): OfflineProductStorage;
}
declare class TelemetryEvent {
    readonly start: number;
    // relative to event send time
    readonly end: number;
    // relative to event send time
    readonly title: string;
    readonly details: string;
    readonly id?: string | undefined;
    // optional, default will be random assigned by backend
    readonly type?: string | undefined;
    constructor(start: number, end: number, title: string, details: string, id?: string | undefined, type?: string | undefined); // optional, default will be "SDK" assigned by backend
}
declare class TelemetryEventDescription {
    readonly title: string;
    readonly details: string;
    readonly start: Date;
    readonly type?: string | undefined;
    readonly id?: string | undefined;
    end?: Date | null;
    constructor(title: string, details: string, start: Date, end?: Date | null, type?: string | undefined, id?: string | undefined);
    // Prepare telemetry event right before sending it.
    // Convert times to relative.
    toTelemetryEvent(): TelemetryEvent;
}
declare enum TelemetryPoint {
    Start = 0,
    End = 1
}
declare enum EventSendingLimitation {
    MinEventsPortion = 0,
    // check for minimal amount of telemetry events, skip sending if less than 100 events are ready to send
    AnyEvents = 1,
    // send all collected events, do not check for count, skip sending only if no events are ready to send
    AnyEventsIncludingUnfinished = 2
}
declare class TelemetryTracker {
    // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)
    private readonly minEventsPortionToSend;
    // max events batch size to be sent in a single Telemetry message
    private readonly maxEventsPortionToSend;
    private readonly config; // to check confirmed capabilities
    private readonly packetInterface;
    private pendingEvents; // started events: have TelemetryEvent::startTime only
    private readyEvents; // events ready to send
    private hasInitializationFinished;
    private _canSendTelemetry;
    constructor(config: Configuration, packetInterface: PacketInterface);
    // Keeping this private prevents the type declaration from being generated properly.
    // Ideally, this should be private.
    get isTelemetryEnabled(): boolean;
    get canSendTelemetry(): boolean;
    set canSendTelemetry(enable: boolean);
    // Add complete event
    addTelemetryEvent(event: TelemetryEventDescription): void;
    // Add incomplete event (with either starting or ending time point)
    addPartialEvent(incompleteEvent: TelemetryEventDescription, eventKey: string, point: TelemetryPoint): void;
    getTelemetryToSend(sendingLimit: EventSendingLimitation): TelemetryEventDescription[];
    private getTelemetryPortion;
    // Merging 2 partial events:
    //   use start.startTime & end.endTime.
    // For other fields,
    //   if there are values in end, use them,
    //   else use values from start.
    private merge;
    sendTelemetryIfMinimalPortionCollected(): void;
    // NB: getTelemetryToSend will return non-empty array only if we have already received initReply
    // and telemetry.v1 capability is enabled there.
    sendTelemetry(limit: EventSendingLimitation): void;
}
/**
 * Indicates current state of connection between the client and Sync service.
 * <p>Possible values are as follows:
 * <li>'connecting' - client is offline and connection attempt is in process.
 * <li>'connected' - client is online and ready.
 * <li>'disconnecting' - client is going offline as disconnection is in process.
 * <li>'disconnected' - client is offline and no connection attempt is in process.
 * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.
 * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.
 * @typedef {('unknown'|'connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} TwilsockClient#ConnectionState
 */
type ConnectionState = "unknown" | "disconnecting" | "disconnected" | "connecting" | "connected" | "denied" | "error";
type ClientOptionsType = {
    continuationToken?: string | null;
    channel?: TwilsockChannel;
    transport?: Transport;
    registrations?: Registrations;
    logLevel?: LogLevelDesc;
    region?: string;
    twilsock?: {
        uri?: string;
    };
    Twilsock?: {
        uri?: string;
    };
    retryPolicy?: RetryPolicyType;
    initRegistrations?: InitRegistration[] | null;
    tweaks: Record<string, unknown> | null;
    clientMetadata: Record<string, unknown>;
    productId?: string;
    twilsockClient?: TwilsockClient;
    notifications?: {
        region?: string;
        ersUrl?: string;
    };
};
/**
 * @alias Twilsock
 * @classdesc Client library for the Twilsock service
 * It allows to recevie service-generated updates as well as bi-directional transport
 * @fires Twilsock#message
 * @fires Twilsock#connected
 * @fires Twilsock#disconnected
 * @fires Twilsock#tokenAboutToExpire
 * @fires Twilsock#tokenExpired
 * @fires Twilsock#stateChanged
 * @fires Twilsock#connectionError
 */
declare class TwilsockClient extends EventEmitter {
    private readonly config;
    private readonly channel;
    private readonly registrations;
    private readonly upstream;
    private readonly telemetryTracker;
    readonly version: string;
    private offlineStorageDeferred;
    /**
     * @param {string} token Twilio access token
     * @param {string} productId Product identifier. Should be the same as a grant name in token
     * @param {object} options Twilsock configuration options
     */
    constructor(token: string, productId: string, options: Partial<ClientOptionsType>);
    emit(event: string | symbol, ...args: unknown[]): boolean;
    private handleStorageId;
    /**
     * Get offline storage ID
     * @returns {Promise}
     */
    storageId(): Promise<OfflineProductStorage>;
    /**
     * Indicates if twilsock is connected now
     * @returns {Boolean}
     */
    get isConnected(): boolean;
    /**
     * Current state
     * @returns {ConnectionState}
     */
    get state(): ConnectionState;
    /**
     * Update token
     * @param {String} token
     * @returns {Promise}
     */
    updateToken(token: string): Promise<void>;
    /**
     * Updates notification context.
     * This method shouldn't be used anyone except twilio notifications library
     * @param contextId id of notification context
     * @param context value of notification context
     * @private
     */
    setNotificationsContext(contextId: string, context: Context): Promise<void>;
    /**
     * Remove notification context.
     * This method shouldn't be used anyone except twilio notifications library
     * @param contextId id of notification context
     * @private
     */
    removeNotificationsContext(contextId: string): Promise<void>;
    /**
     * Connect to the server
     * @fires Twilsock#connected
     * @public
     * @returns {void}
     */
    connect(): void;
    /**
     * Disconnect from the server
     * @fires Twilsock#disconnected
     * @public
     * @returns {Promise}
     */
    disconnect(): Promise<void>;
    /**
     * Get HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */
    get(url: string, headers: Headers, grant?: string): Promise<Result<Context>>;
    /**
     * Post HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */
    post<T extends Record<string, unknown> = Record<string, unknown>>(url: string, headers: Headers, body: Context | string, grant?: string): Promise<Result<Context<T>>>;
    /**
     * Put HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */
    put<T extends Record<string, unknown> = Record<string, unknown>>(url: string, headers: Headers, body: Context | string, grant?: string): Promise<Result<Context<T>>>;
    /**
     * Delete HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */
    delete<T extends Record<string, unknown> = Record<string, unknown>>(url: string, headers: Headers, body?: Context | string, grant?: string): Promise<Result<Context<T>>>;
    /**
     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
     * @param {TelemetryEventDescription} event Event details.
     * @returns {void}
     */
    addTelemetryEvent(event: TelemetryEventDescription): void;
    /**
     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
     * @param {TelemetryEventDescription} event Event details.
     * @param {string} eventKey Unique event key.
     * @param {TelemetryPoint} point Is this partial event for start or end of measurement.
     * @returns {void}
     */
    addPartialTelemetryEvent(event: TelemetryEventDescription, eventKey: string, point: TelemetryPoint): void;
}
declare class TwilsockError extends Error {
    constructor(description: string);
}
declare class TransportUnavailableError extends TwilsockError {
    constructor(description: string);
}
export { TwilsockClient, TwilsockClient as Twilsock, ConnectionState, TwilsockError, TransportUnavailableError, Transport, Headers as TransportHeaders, Result as TransportResult, InitRegistration, TelemetryTracker, TelemetryEventDescription, TelemetryPoint, EventSendingLimitation };
