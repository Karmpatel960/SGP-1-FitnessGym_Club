{"version":3,"file":"client.js","sources":["../src/client.ts"],"sourcesContent":["import { literal, nonEmptyString, nonNegativeInteger, objectSchema, pureObject, validateTypesAsync } from '@twilio/declarative-type-validator';\nimport { Twilsock, InitRegistration, ConnectionState as TwilsockConnectionState } from 'twilsock';\n\nimport { UriBuilder } from './utils/uri';\nimport { SyncError } from './utils/syncerror';\nimport { deepClone } from './utils/sanitize';\nimport log from './utils/logger';\n\nimport { Configuration } from './configuration';\nimport { Subscriptions } from './subscriptions';\n\nimport { Services } from './interfaces/services';\nimport { NetworkService } from './services/network';\nimport { SessionStorage } from './services/storage';\n\nimport { RemovalHandler, SyncEntity } from './entity';\nimport { DocumentDescriptor, SyncDocument, SyncDocumentImpl } from './syncdocument';\nimport { SyncListDescriptor, SyncList, SyncListImpl } from './synclist';\nimport { SyncMapDescriptor, SyncMap, SyncMapImpl } from './syncmap';\nimport { SyncStream, SyncStreamImpl } from './streams/syncstream';\nimport { StreamDescriptor } from './streams/serverapi';\nimport { ClientInfo } from './clientInfo';\nimport { EntitiesCache } from './entitiesCache';\nimport { LiveQuery, InstantQuery, LiveQueryImpl, LiveQueryDescriptor } from './livequery';\nimport { LiveQueryCreator, queryItems } from './livequery';\nimport { version } from '../package.json';\nimport { ReplayEventEmitter } from '@twilio/replay-event-emitter';\n\nconst SYNC_PRODUCT_ID = 'data_sync';\nconst SDK_VERSION = version;\n\ntype json = { [key: string]: any };\n\n/**\n * Mode for opening the Sync object:\n * * `'open_or_create'` - reads a Sync object or creates one if it does not exist.\n * * `'open_existing'` - reads an existing Sync object. The promise is rejected if the object does not exist.\n * * `'create_new'` - creates a new Sync object. If the *id* property is specified, it will be used as the unique name.\n */\ntype OpenMode = 'open_or_create'\n  | 'open_existing'\n  | 'create_new';\n\n/**\n * Client connection state.\n * Directly reflects connection state of the underlying websocket transport.\n * Possible values are as follows:\n * * 'connecting' - client is offline and connection attempt is in process.\n * * 'connected' - client is online and ready.\n * * 'disconnecting' - client is going offline as disconnection is in process.\n * * 'disconnected' - client is offline and no connection attempt is in process.\n * * 'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\n * * 'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\n */\ntype ConnectionState = TwilsockConnectionState;\n\n/**\n * Client options.\n */\ninterface SyncClientOptions {\n  /**\n   * The level of logging to enable.\n   */\n  logLevel?: 'silent' | 'error' | 'warn' | 'info' | 'debug' | 'trace';\n\n  twilsockClient?: Twilsock;\n  [key: string]: any;\n}\n\n/**\n * Options for opening a Sync object.\n *\n * @example The following example is applicable to all Sync objects\n * (i.e., `syncClient.document()`, `syncClient.list()`,` syncClient.map()`, `syncClient.stream()`)\n * ```typescript\n * // Attempts to open an existing document with a unique name of 'MyDocument'\n * // If no such document exists, the promise is rejected\n * syncClient.document({\n *   id: 'MyDocument',\n *   mode: 'open_existing'\n * })\n *   .then(...)\n *   .catch(...);\n *\n * // Attempts to create a new document with a unique name of 'MyDocument', TTL of 24 hours and initial data `{ name: 'John Smith' }`\n * // If such a document already exists, the promise is rejected\n * syncClient.document({\n *   id: 'MyDocument',\n *   mode: 'create_new',\n *   ttl: 86400\n *   data: { name: 'John Smith' } // the `data` property is only applicable for Documents\n * })\n *   .then(...)\n *   .catch(...);\n * ```\n */\ninterface OpenOptions {\n  /**\n   * Sync object SID or unique name.\n   */\n  id?: string;\n\n  /**\n   * Mode for opening the Sync object.\n   */\n  mode?: OpenMode;\n\n  /**\n   * The time-to-live of the Sync object in seconds. This is applied only if the object is created.\n   */\n  ttl?: number;\n}\n\n/**\n * Options for opening a document.\n */\ninterface OpenDocumentOptions extends OpenOptions {\n  /**\n   * The initial data of the Sync document.\n   */\n  data?: json;\n}\n\n/**\n * List options.\n */\ninterface OpenListOptions extends OpenOptions {\n  purpose?: string;\n  context?: json;\n  includeItems?: boolean;\n}\n\n/**\n * Map options.\n */\ninterface OpenMapOptions extends OpenOptions {\n  includeItems?: boolean;\n}\n\n/**\n * Stream options.\n */\ninterface OpenStreamOptions extends OpenOptions {\n}\n\nfunction decompose(arg?: string | OpenOptions): OpenOptions {\n  if (!arg) {\n    return {mode: 'create_new'};\n  } else if (typeof arg === 'string') {\n    return {id: arg, mode: 'open_or_create'};\n  } else {\n    let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');\n    return {...arg, mode: mode};\n  }\n}\n\nconst SYNC_DOCUMENT_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.document';\nconst SYNC_LIST_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.list';\nconst SYNC_MAP_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.map';\nconst SYNC_NOTIFICATION_TYPE = 'twilio.sync.event';\n\ntype ConnectionError = {\n  terminal: boolean;\n  message: string;\n};\n\ntype ClientEvents = {\n  tokenAboutToExpire: () => void;\n  tokenExpired: () => void;\n  connectionError: (error: ConnectionError) => void;\n  connectionStateChanged: (state: ConnectionState) => void;\n};\n\n/**\n * Client for the Twilio Sync service.\n *\n * @example\n * ```typescript\n * // Using NPM resolution\n * const SyncClient = require('twilio-sync');\n * const syncClient = new SyncClient(token, { loglevel: 'debug' });\n *\n * // Using CDN\n * const syncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });\n * ```\n */\nclass Client extends ReplayEventEmitter<ClientEvents> {\n  private readonly services: Services;\n  private readonly entities: EntitiesCache;\n\n  /**\n   * @param fpaToken Twilio access token.\n   * @param options Options to customize the client.\n   */\n  constructor(fpaToken: string, options: SyncClientOptions = {}) {\n    super();\n\n    if (!fpaToken) {\n      throw new Error('Sync library needs a valid Twilio token to be passed');\n    }\n\n    if (options.hasOwnProperty('logLevel')) {\n      log.setLevel(options.logLevel);\n    } else {\n      log.setLevel('silent');\n    }\n\n    const productId = options.productId = options.productId || SYNC_PRODUCT_ID;\n\n    // Fill ClientMetadata\n    options.clientMetadata = options.clientMetadata || {};\n    if (!options.clientMetadata.hasOwnProperty('type')) {\n      options.clientMetadata.type = 'sync';\n    }\n    if (!options.clientMetadata.hasOwnProperty('sdk')) {\n      options.clientMetadata.sdk = 'JS';\n      options.clientMetadata.sdkv = SDK_VERSION;\n    }\n\n    const startTwilsock = !options.twilsockClient;\n\n    // Create default init registrations if none were provided.\n    // Otherwise, the outside party have to list all the init registrations they need, including Sync ones.\n    if (!options.initRegistrations) {\n      let initRegistration = new InitRegistration(productId);\n      Client.populateInitRegistrations(initRegistration);\n      options.initRegistrations = [initRegistration];\n    }\n\n    let twilsock = options.twilsockClient = options.twilsockClient ?? new Twilsock(fpaToken, productId, options);\n    twilsock.on('tokenAboutToExpire', () => this.emit('tokenAboutToExpire'));\n    twilsock.on('tokenExpired', () => this.emit('tokenExpired'));\n    twilsock.on('connectionError', err => this.emit('connectionError', err));\n    twilsock.on('stateChanged', (state) => {\n      this.emit('connectionStateChanged', state);\n      /**\n       * Handle transport establishing event\n       * If we have any subscriptions - we should check object for modifications\n       */\n      this.services.subscriptions.onConnectionStateChanged(state === 'connected');\n    });\n    twilsock.on('message', (messageType, payload) => this._routeMessage(messageType, payload));\n\n    let config = new Configuration(options);\n    let network = new NetworkService(new ClientInfo(SDK_VERSION), config, twilsock);\n    let storage = new SessionStorage(config);\n\n    this.services = {\n      config,\n      twilsock,\n      network,\n      storage,\n      router: this,\n      subscriptions: null\n    };\n\n    this.services.subscriptions = new Subscriptions(this.services);\n\n    this.entities = new EntitiesCache();\n\n    // Start only if we created twilsock locally,\n    // otherwise it's the responsibility of whoever created the Twilsock client.\n    if (startTwilsock) {\n      twilsock.connect();\n    }\n  }\n\n  /**\n   * Fired when connection state has been changed.\n   *\n   * Parameters:\n   * 1. {@link ConnectionState} `connectionState` - contains current service connection state.\n   * @example\n   * ```typescript\n   * syncClient.on('connectionStateChanged', (newState) => {\n   *   console.log('Received a new connection state:', newState);\n   * });\n   * ```\n   * @event\n   */\n  static readonly connectionStateChanged = 'connectionStateChanged';\n\n  /**\n   * Fired when connection is interrupted by unexpected reason.\n   *\n   * Parameters:\n   * 1. object `connectionError` - connection error details. It has following properties:\n   *     * boolean `terminal` - twilsock will stop connection attempts\n   *     * string `message` - root cause\n   *     * number? `httpStatusCode` - HTTP status code if available\n   *     * number? `errorCode` - Twilio public error code if available\n   * @example\n   * ```typescript\n   * syncClient.on('connectionError', (connectionError) => {\n   *   console.error('Connection was interrupted:', connectionError.message);\n   *   console.error('Is terminal:', connectionError.terminal);\n   * });\n   * ```\n   * @event\n   */\n  static readonly connectionError = 'connectionError';\n\n  /**\n   * Fired when the access token is about to expire and needs to be updated.\n   * The trigger takes place three minutes before the JWT access token expiry.\n   * For long living applications, you should refresh the token when either\n   * {@link SyncClient.tokenAboutToExpire | tokenAboutToExpire} or\n   * {@link SyncClient.tokenExpired | tokenExpire} events occur; handling just\n   * one of them is sufficient.\n   * @example\n   * The following example illustrates access token refresh.\n   * ```typescript\n   * syncClient.on('tokenAboutToExpire', () => {\n   *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens\n   *   const token = '<your-access-token-here>';\n   *   syncClient.updateToken(token);\n   * });\n   * ```\n   * @event\n   */\n  static readonly tokenAboutToExpire = 'tokenAboutToExpire';\n\n  /**\n   * Fired when the access token is expired.\n   * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.\n   * For long living applications, you should refresh the token when either\n   * {@link SyncClient.tokenAboutToExpire | tokenAboutToExpire} or\n   * {@link SyncClient.tokenExpired | tokenExpire} events occur; handling just\n   * one of them is sufficient.\n   * @event\n   */\n  static readonly tokenExpired = 'tokenExpired';\n\n  static populateInitRegistrations(reg: InitRegistration) {\n    reg.populateInitRegistrations([SYNC_NOTIFICATION_TYPE, SYNC_DOCUMENT_NOTIFICATION_TYPE,\n      SYNC_LIST_NOTIFICATION_TYPE, SYNC_MAP_NOTIFICATION_TYPE]);\n  }\n\n  /**\n   * Entry point for all the incoming messages (Router).\n   *\n   * @param type Type of the incoming message\n   * @param message Message to route\n   * @internal\n   */\n  _routeMessage(type: string, message: any) {\n    log.trace('Notification type:', type, 'content:', message);\n    switch (type) {\n      case SYNC_DOCUMENT_NOTIFICATION_TYPE:\n      case SYNC_LIST_NOTIFICATION_TYPE:\n      case SYNC_MAP_NOTIFICATION_TYPE:\n        this.services.subscriptions.acceptMessage(message, false);\n        break;\n      case SYNC_NOTIFICATION_TYPE:\n        this.services.subscriptions.acceptMessage(message, true);\n        break;\n    }\n  }\n\n  /**\n   * Subscribe for events (Router)\n   *\n   * @internal\n   */\n  _subscribe(sid: string, entity: any) {\n    this.services.subscriptions.add(sid, entity);\n  }\n\n  /**\n   * Unsubscribe from events (Router)\n   *\n   * @internal\n   */\n  _unsubscribe(sid: string) {\n    this.services.subscriptions.remove(sid);\n  }\n\n  /**\n   * Current version of the Sync client.\n   */\n  static get version(): string {\n    return SDK_VERSION;\n  }\n\n  /**\n   * Current service connection state.\n   */\n  get connectionState(): ConnectionState {\n    return this.services.twilsock.state;\n  }\n\n  /**\n   * Returns a promise which resolves when library is correctly initialized\n   * Or throws if initialization is impossible\n   *\n   * @internal\n   */\n  private async ensureReady() {\n    if (!this.services.config.sessionStorageEnabled) {\n      return;\n    }\n\n    try {\n      let storageSettings = await this.services.twilsock.storageId();\n      this.services.storage.updateStorageId(storageSettings.id);\n    } catch (e) {\n      log.warn('Failed to initialize storage', e);\n    }\n  }\n\n  private storeRootInSessionCache(type: string, id: string, value: Object) {\n    // can't store without id\n    if (!this.services.config.sessionStorageEnabled || !id) {\n      return;\n    }\n\n    let valueToStore = deepClone(value);\n    if (type === SyncList.type || type === SyncMap.type) {\n      valueToStore['last_event_id'] = null;\n      delete valueToStore['items'];\n    }\n    this.services.storage.store(type, id, valueToStore);\n  }\n\n  private readRootFromSessionCache(type: string, id: string): Object {\n    if (!this.services.config.sessionStorageEnabled || !id) {\n      return null;\n    }\n    return this.services.storage.read(type, id);\n  }\n\n  private async _get(baseUri: string, id: string, optimistic: boolean = false) {\n    if (!id) {\n      throw new SyncError(`Cannot get entity without id`, 404);\n    }\n    const uri = new UriBuilder(baseUri).pathSegment(id)\n      .queryParam('Include', optimistic ? 'items' : undefined).build();\n    let response = await this.services.network.get(uri);\n    return response.body;\n  }\n\n  private _createDocument(id: string, data?: Object, ttl?: number) {\n    const requestBody: any = {\n      unique_name: id,\n      data: data || {}\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.documentsUri, requestBody)\n      .then(response => {\n        response.body.data = requestBody.data;\n        return response.body;\n      });\n  }\n\n  private async _getDocument(id: string): Promise<DocumentDescriptor> {\n    return (this.readRootFromSessionCache(SyncDocument.type, id) || this._get(this.services.config.documentsUri, id)) as Promise<DocumentDescriptor>;\n  }\n\n  private _createList(id: string, purpose?: string, context?: json, ttl?: number) {\n    const requestBody: any = {\n      unique_name: id,\n      purpose: purpose,\n      context: context\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);\n  }\n\n  private async _getList(id: string): Promise<SyncListDescriptor> {\n    return (this.readRootFromSessionCache(SyncList.type, id) || this._get(this.services.config.listsUri, id)) as Promise<SyncListDescriptor>;\n  }\n\n  private _createMap(id, ttl?: number) {\n    const requestBody: any = {\n      unique_name: id\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);\n  }\n\n  private async _getMap(id: string, optimistic: boolean = false): Promise<SyncMapDescriptor> {\n    return (this.readRootFromSessionCache(SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic)) as Promise<SyncMapDescriptor>;\n  }\n\n  private async _getStream(id: string): Promise<StreamDescriptor> {\n    return (this.readRootFromSessionCache(SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false)) as Promise<StreamDescriptor>;\n  }\n\n  private async _createStream(id, ttl?: number): Promise<StreamDescriptor> {\n    const requestBody: any = {\n      unique_name: id\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    const response = await this.services.network.post(this.services.config.streamsUri, requestBody);\n\n    return response.body;\n  }\n\n  private _getLiveQuery(sid: string): LiveQueryDescriptor {\n    return this.readRootFromSessionCache(LiveQuery.type, sid) as LiveQueryDescriptor;\n  }\n\n  private getCached<T extends SyncEntity>(id: string, type: string): T {\n    if (id) {\n      return this.entities.get(id, type) as T || null;\n    }\n    return null;\n  }\n\n  private removeFromCacheAndSession(type: string, sid: string, uniqueName: string) {\n    this.entities.remove(sid);\n    if (this.services.config.sessionStorageEnabled) {\n      this.services.storage.remove(type, sid, uniqueName);\n    }\n  }\n\n  /**\n   * Read or create a Sync document.\n   * @param arg Could be any of the following:\n   * * Unique name or SID identifying the Sync document - opens the document with the given identifier or creates one if it does not exist.\n   * * none - creates a new document with a randomly assigned SID and no unique name.\n   * * {@link OpenDocumentOptions} object for more granular control.\n   * @return A promise which resolves after the document is successfully read (or created).\n   * This promise may reject if the document could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @example\n   * ```typescript\n   * syncClient.document('MyDocument')\n   *   .then((document) => {\n   *     console.log('Successfully opened a document. SID:', document.sid);\n   *     document.on('updated', (event) => {\n   *       console.log('Received an \"updated\" event: ', event);\n   *     });\n   *   })\n   *   .catch((error) => {\n   *     console.error('Unexpected error', error);\n   *   });\n   * ```\n   */\n  @validateTypesAsync([\n    'undefined',\n    'string',\n    objectSchema('open document options', {\n      id: ['string', 'undefined'],\n      mode: [literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],\n      ttl: [nonNegativeInteger, 'undefined'],\n      data: [pureObject, 'undefined', literal(null)]\n    })\n  ])\n  public async document(arg?: string | OpenDocumentOptions): Promise<SyncDocument> {\n    await this.ensureReady();\n    let opts: OpenDocumentOptions = decompose(arg);\n\n    let docDescriptor: DocumentDescriptor;\n    if (opts.mode === 'create_new') {\n      docDescriptor = await this._createDocument(opts.id, opts.data, opts.ttl);\n    } else {\n      let docFromInMemoryCache = this.getCached<SyncDocumentImpl>(opts.id, SyncDocument.type);\n      if (docFromInMemoryCache) {\n        return new SyncDocument(docFromInMemoryCache);\n      } else {\n        try {\n          docDescriptor = await this._getDocument(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              docDescriptor = await this._createDocument(opts.id, opts.data, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.document(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n    this.storeRootInSessionCache(SyncDocument.type, opts.id, docDescriptor);\n    let syncDocumentImpl = new SyncDocumentImpl(this.services, docDescriptor,\n      (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncDocumentImpl = this.entities.store(syncDocumentImpl);\n    return new SyncDocument(syncDocumentImpl);\n  }\n\n  /**\n   * Read or create a Sync map.\n   * @param arg Could be any of the following:\n   * * Unique name or SID identifying the Sync map - opens the map with the given identifier or creates one if it does not exist.\n   * * none - creates a new map with a randomly assigned SID and no unique name.\n   * * {@link OpenMapOptions} object for more granular control.\n   * @return A promise which resolves after the map is successfully read (or created).\n   * This promise may reject if the map could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @example\n   * ```typescript\n   * syncClient.map('MyMap')\n   *   .then((map) => {\n   *     console.log('Successfully opened a map. SID:', map.sid);\n   *     map.on('itemUpdated', (event) => {\n   *       console.log('Received an \"itemUpdated\" event:', event);\n   *     });\n   *   })\n   *   .catch((error) => {\n   *     console.error('Unexpected error', error);\n   *   });\n   * ```\n   */\n  @validateTypesAsync([\n    'undefined',\n    'string',\n    objectSchema('open map options', {\n      id: ['string', 'undefined'],\n      mode: [literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],\n      ttl: [nonNegativeInteger, 'undefined'],\n      data: [pureObject, 'undefined', literal(null)],\n      includeItems: ['boolean', 'undefined']\n    })\n  ])\n  public async map(arg?: string | OpenMapOptions): Promise<SyncMap> {\n    await this.ensureReady();\n    let opts: OpenMapOptions = decompose(arg);\n\n    let mapDescriptor: SyncMapDescriptor;\n    if (opts.mode === 'create_new') {\n      mapDescriptor = await this._createMap(opts.id, opts.ttl);\n    } else {\n      let mapFromInMemoryCache = this.getCached<SyncMapImpl>(opts.id, SyncMap.type);\n      if (mapFromInMemoryCache) {\n        return new SyncMap(mapFromInMemoryCache);\n      } else {\n        try {\n          mapDescriptor = await this._getMap(opts.id, opts.includeItems);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              mapDescriptor = await this._createMap(opts.id, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.map(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n    this.storeRootInSessionCache(SyncMap.type, opts.id, mapDescriptor);\n    let syncMapImpl = new SyncMapImpl(this.services, mapDescriptor,\n      (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncMapImpl = this.entities.store(syncMapImpl);\n    return new SyncMap(syncMapImpl);\n  }\n\n  /**\n   * Read or create a Sync list.\n   * @param arg Could be any of the following:\n   * * Unique name or SID identifying a Sync list - opens the list with the given identifier or creates one if it does not exist.\n   * * none - creates a new list with a randomly assigned SID and no unique name.\n   * * {@link OpenListOptions} object for more granular control.\n   * @return A promise which resolves after the list is successfully read (or created).\n   * This promise may reject if the list could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @example\n   * ```typescript\n   * syncClient.list('MyList')\n   *   .then((list) => {\n   *     console.log('Successfully opened a List. SID:', list.sid);\n   *     list.on('itemAdded', (event) => {\n   *       console.log('Received an \"itemAdded\" event:', event);\n   *     });\n   *   })\n   *   .catch((error) => {\n   *     console.error('Unexpected error', error);\n   *   });\n   * ```\n   */\n  @validateTypesAsync([\n    'undefined',\n    'string',\n    objectSchema('open list options', {\n      id: ['string', 'undefined'],\n      mode: [literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],\n      ttl: [nonNegativeInteger, 'undefined'],\n      data: [pureObject, 'undefined', literal(null)],\n      purpose: ['string', 'undefined'],\n      context: [pureObject, 'undefined'],\n      includeItems: ['boolean', 'undefined']\n    })\n  ])\n  public async list(arg?: string | OpenListOptions): Promise<SyncList> {\n    await this.ensureReady();\n    let opts: OpenListOptions = decompose(arg);\n\n    let listDescriptor: SyncListDescriptor;\n    if (opts.mode === 'create_new') {\n      listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n    } else {\n      let listFromInMemoryCache = this.getCached<SyncListImpl>(opts.id, SyncList.type);\n      if (listFromInMemoryCache) {\n        return new SyncList(listFromInMemoryCache);\n      } else {\n        try {\n          listDescriptor = await this._getList(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.list(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n    this.storeRootInSessionCache(SyncList.type, opts.id, listDescriptor);\n    let syncListImpl = new SyncListImpl(this.services, listDescriptor,\n      (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncListImpl = this.entities.store(syncListImpl);\n    return new SyncList(syncListImpl);\n  }\n\n  /**\n   * Read or create a Sync message stream.\n   * @param arg Could be any of the following:\n   * * Unique name or SID identifying a stream - opens the stream with the given identifier or creates one if it does not exist.\n   * * none - creates a new stream with a randomly assigned SID and no unique name.\n   * * {@link OpenStreamOptions} object for more granular control.\n   * @return A promise which resolves after the stream is successfully read (or created).\n   * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.\n   * This promise may reject if the stream could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @example\n   * ```typescript\n   * syncClient.stream('MyStream')\n   *   .then((stream) => {\n   *     console.log('Successfully opened a message stream. SID:', stream.sid);\n   *     stream.on('messagePublished', (event) => {\n   *       console.log('Received a \"messagePublished\" event:', event);\n   *     });\n   *   })\n   *   .catch((error) => {\n   *     console.error('Unexpected error', error);\n   *   });\n   * ```\n   */\n  @validateTypesAsync([\n    'undefined',\n    'string',\n    objectSchema('open stream options', {\n      id: ['string', 'undefined'],\n      mode: [literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],\n      ttl: [nonNegativeInteger, 'undefined'],\n      data: [pureObject, 'undefined', literal(null)]\n    })\n  ])\n  public async stream(arg?: string | OpenStreamOptions): Promise<SyncStream> {\n    await this.ensureReady();\n    let opts: OpenStreamOptions = decompose(arg);\n\n    let streamDescriptor: StreamDescriptor;\n    if (opts.mode === 'create_new') {\n      streamDescriptor = await this._createStream(opts.id, opts.ttl);\n    } else {\n      let streamFromInMemoryCache = this.getCached<SyncStreamImpl>(opts.id, SyncStream.type);\n      if (streamFromInMemoryCache) {\n        return new SyncStream(streamFromInMemoryCache);\n      } else {\n        try {\n          streamDescriptor = await this._getStream(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              streamDescriptor = await this._createStream(opts.id, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.stream(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n    this.storeRootInSessionCache(SyncStream.type, opts.id, streamDescriptor);\n    const streamRemovalHandler: RemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n    let syncStreamImpl = new SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);\n    syncStreamImpl = this.entities.store(syncStreamImpl);\n    return new SyncStream(syncStreamImpl);\n  }\n\n  /**\n   * Gracefully shuts the Sync client down.\n   */\n  public async shutdown() {\n    await this.services.subscriptions.shutdown();\n    await this.services.twilsock.disconnect();\n  }\n\n  /**\n   * Set the authentication token.\n   * @param token New token to set.\n   */\n  @validateTypesAsync(nonEmptyString)\n  public async updateToken(token: string): Promise<void> {\n    return this.services.twilsock.updateToken(token)\n      .catch((error) => {\n        const status = error?.reply?.status;\n\n        if (status?.code === 401 && status?.status === 'UNAUTHORIZED') {\n          throw new SyncError('Updated token was rejected by server', 400, 51130);\n        }\n\n        throw error;\n      });\n  }\n\n  /**\n   * For Flex customers only. Establishes a long-running query against Flex data wherein the returned\n   * result set is updated whenever new (or updated) records match the given expression. Updated results\n   * are presented row-by-row according to the lifetime of the returned LiveQuery object.\n   *\n   * @param indexName Must specify one of the Flex data classes for which Live Queries are available.\n   * @param queryExpression A query expression to be executed against the given data index.\n   * Please review the [Live Query Language](https://www.twilio.com/docs/sync/live-query)\n   * page for Sync client limits and a full list of operators currently supported in query expressions.\n   *\n   * @return A promise that resolves when the query has been successfully executed.\n   * @example\n   * ```typescript\n   * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == \"Bob\"')\n   *   .then((args) => {\n   *      console.log('Subscribed to live data updates for worker Bob');\n   *      const items = args.getItems();\n   *      Object.entries(items).forEach(([key, value]) => {\n   *        console.log('Search result item key:', key);\n   *        console.log('Search result item value:', value);\n   *      });\n   *   })\n   *   .catch((err) => {\n   *      console.error('Error when subscribing to live updates for worker Bob', err);\n   *   });\n   * ```\n   */\n  @validateTypesAsync(nonEmptyString, 'string')\n  public async liveQuery(indexName: string, queryExpression: string): Promise<LiveQuery> {\n    await this.ensureReady();\n    const queryUri = new UriBuilder(this.services.config.insightsUri)\n      .pathSegment(indexName)\n      .pathSegment('Items')\n      .build();\n\n    // send query to CDS to get server-generated sid and item list\n    const response = await queryItems({\n      network: this.services.network,\n      uri: queryUri,\n      queryString: queryExpression,\n      type: LiveQuery.type\n    });\n\n    let liveQueryImpl: LiveQueryImpl = this.getCached<LiveQueryImpl>(response.query_id, LiveQuery.type);\n    if (!liveQueryImpl) {\n      let descriptor: LiveQueryDescriptor = this._getLiveQuery(response.query_id);\n\n      if (!descriptor) {\n        descriptor = {\n          indexName,\n          queryExpression,\n          sid: response.query_id,\n          queryUri,\n          last_event_id: response.last_event_id\n        } as LiveQueryDescriptor;\n      }\n\n      const liveQueryRemovalHandler: RemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n      liveQueryImpl = new LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);\n    }\n\n    this.storeRootInSessionCache(LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);\n    liveQueryImpl = this.entities.store(liveQueryImpl);\n    return new LiveQuery(liveQueryImpl);\n  }\n\n  /**\n   * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly\n   * against the target index.\n   *\n   * @param indexName Must specify one of the Flex data classes for which live queries are available.\n   * @return A promise which resolves after the instance of InstantQuery is successfully created.\n   * @example\n   * ```typescript\n   * syncClient.instantQuery('tr-worker')\n   *   .then((q) => {\n   *     q.on('searchResult', (items) => {\n   *       Object.entries(items).forEach(([key, value]) => {\n   *         console.log('Search result item key:', key);\n   *         console.log('Search result item value:', value);\n   *       });\n   *     });\n   *   });\n   * ```\n   */\n  @validateTypesAsync(nonEmptyString)\n  public async instantQuery(indexName: string): Promise<InstantQuery> {\n    await this.ensureReady();\n\n    const liveQueryCreator: LiveQueryCreator = (indexName, queryExpression) => {\n      return this.liveQuery(indexName, queryExpression);\n    };\n\n    return new InstantQuery({\n      indexName,\n      network: this.services.network,\n      insightsUri: this.services.config.insightsUri,\n      liveQueryCreator\n    });\n  }\n}\n\nexport {\n  Client,\n  SyncClientOptions,\n  ConnectionState,\n  OpenMode,\n  json,\n  OpenOptions,\n  OpenDocumentOptions,\n  OpenMapOptions,\n  OpenListOptions,\n  OpenStreamOptions\n};\n"],"names":["version","ReplayEventEmitter","log","InitRegistration","twilsock","Twilsock","Configuration","network","NetworkService","ClientInfo","storage","SessionStorage","Subscriptions","EntitiesCache","deepClone","SyncList","SyncMap","SyncError","uri","UriBuilder","SyncDocument","SyncStream","LiveQuery","SyncDocumentImpl","SyncMapImpl","SyncListImpl","SyncStreamImpl","queryItems","LiveQueryImpl","InstantQuery","__decorate","validateTypesAsync","objectSchema","literal","nonNegativeInteger","pureObject","nonEmptyString"],"mappings":"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"}