{"version":3,"file":"users.js","sources":["../../src/data/users.ts"],"sourcesContent":["import { UserUpdatedEventArgs, User, UserUpdateReason } from '../user';\nimport { UserDescriptor } from '../userdescriptor';\nimport { UserDescriptors } from './userdescriptors';\nimport { Paginator } from '../interfaces/paginator';\nimport { Network } from '../services/network';\nimport { SyncClient } from 'twilio-sync';\nimport { Configuration } from '../configuration';\nimport { CommandExecutor } from '../commandexecutor';\nimport { ReplayEventEmitter } from '@twilio/replay-event-emitter';\n\ntype UsersEvents = {\n  userUpdated: (data: {\n    user: User;\n    updateReasons: UserUpdateReason[];\n  }) => void;\n  userSubscribed: (user: User) => void;\n  userUnsubscribed: (user: User) => void;\n};\n\nexport interface UsersServices {\n  network: Network;\n  syncClient: SyncClient;\n  commandExecutor: CommandExecutor;\n}\n\n/**\n * @classdesc Container for known users\n * @fires Users#userUpdated\n */\nclass Users extends ReplayEventEmitter<UsersEvents> {\n\n  private userDescriptors: UserDescriptors;\n  private subscribedUsers: Map<string, User>;\n  private fifoStack: any;\n  public readonly myself: User;\n\n  constructor(\n    myself: User,\n    private readonly configuration: Configuration,\n    private readonly services: UsersServices\n  ) {\n    super();\n\n    this.fifoStack = [];\n\n    this.myself = myself;\n    this.myself.on('updated', (args: UserUpdatedEventArgs) => this.emit('userUpdated', args));\n    this.myself.on('userSubscribed', () => this.emit('userSubscribed', this.myself));\n    this.myself.on('userUnsubscribed', () => {\n      this.emit('userUnsubscribed', this.myself);\n      this.myself._ensureFetched();\n    });\n    this.subscribedUsers = new Map<string, User>();\n    this.userDescriptors = new UserDescriptors(this.configuration, {...this.services, users: this });\n  }\n\n  private handleUnsubscribeUser(user: User): void {\n    if (this.subscribedUsers.has(user.identity)) {\n      this.subscribedUsers.delete(user.identity);\n    }\n    let foundItemIndex = -1;\n    let foundItem = this.fifoStack.find((item, index) => {\n      if (item == user.identity) {\n        foundItemIndex = index;\n        return true;\n      }\n      return false;\n    });\n    if (foundItem) {\n      this.fifoStack.splice(foundItemIndex, 1);\n    }\n    this.emit('userUnsubscribed', user);\n  }\n\n  private handleSubscribeUser(user: User): void {\n    if (this.subscribedUsers.has(user.identity)) {\n      return;\n    }\n    if (this.fifoStack.length >= this.configuration.userInfosToSubscribe) {\n      this.subscribedUsers.get(this.fifoStack.shift()).unsubscribe();\n    }\n    this.fifoStack.push(user.identity);\n    this.subscribedUsers.set(user.identity, user);\n    this.emit('userSubscribed', user);\n  }\n\n  /**\n   * Gets user, if it's in subscribed list - then return the user object from it,\n   * if not - then subscribes and adds user to the FIFO stack\n   * @returns {Promise<User>} Fully initialized user\n   */\n  public async getUser(identity: string, entityName: string = null): Promise<User> {\n    await this.myself._ensureFetched();\n\n    if (identity == this.myself.identity) {\n      return this.myself;\n    }\n\n    let user = this.subscribedUsers.get(identity);\n    if (!user) {\n      if (!entityName) {\n        let userDescriptor = await this.getUserDescriptor(identity);\n        entityName = userDescriptor._getDescriptor().sync_objects.user_info_map;\n      }\n\n      user = new User(identity, entityName, this.configuration, this.services);\n      user.on('updated', (args: UserUpdatedEventArgs) => this.emit('userUpdated', args));\n      user.on('userSubscribed', () => this.handleSubscribeUser(user));\n      user.on('userUnsubscribed', () => this.handleUnsubscribeUser(user));\n      await user._ensureFetched();\n    }\n\n    return user;\n  }\n\n  /**\n   * @returns {Promise<UserDescriptor>} User descriptor\n   */\n  public async getUserDescriptor(identity: string): Promise<UserDescriptor> {\n    return this.userDescriptors.getUserDescriptor(identity);\n  }\n\n  /**\n   * @returns {Promise<Paginator<UserDescriptor>>} Users descriptors page for given channel sid\n   */\n  public async getChannelUserDescriptors(channelSid: string): Promise<Paginator<UserDescriptor>> {\n    return this.userDescriptors.getChannelUserDescriptors(channelSid);\n  }\n\n  /**\n   * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}\n   */\n  public async getSubscribedUsers(): Promise<Array<User>> {\n    await this.myself._ensureFetched();\n\n    const users = [this.myself];\n    this.subscribedUsers.forEach((user) => users.push(user));\n\n    return users;\n  }\n}\n\nexport { Users };\n"],"names":["ReplayEventEmitter","UserDescriptors","user","User"],"mappings":"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"}