import { SyncClient } from "twilio-sync";
import { Transport, TwilsockClient, InitRegistration } from "twilsock";
import { ConnectionState as TwilsockConnectionState } from "twilsock";
import { ReplayEventEmitter } from "@twilio/replay-event-emitter";
import { ChannelType, Notifications } from "@twilio/notifications";
import { Notifications as NotificationClient } from "@twilio/notifications";
import { McsClient } from "@twilio/mcs-client";
interface ConfigurationResponse {
    options: {
        consumption_report_interval: string;
        user_infos_to_subscribe: number;
        reachability_enabled: boolean;
        http_cache_interval: string;
        my_conversations_page_size: number;
    };
    sync_objects: {
        my_conversations: string;
        my_user_info: string;
    };
    links: {
        my_conversations: string;
        conversations: string;
        users: string;
        current_user: string;
        typing: string;
        media_service: string;
        messages_receipts: string;
    };
    identity: string;
    url: string;
}
// twilio-chat is used by Flex SDK. Please DO NOT change
declare class Logger {
    private prefix;
    private constructor();
    static scope(prefix: string): Logger;
    setLevel(level: any): void;
    static setLevel(level: any): void;
    trace(...args: any[]): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    static trace(...args: any[]): void;
    static debug(...args: any[]): void;
    static info(...args: any[]): void;
    static warn(...args: any[]): void;
    static error(...args: any[]): void;
}
interface BackoffConfiguration {
    min: number;
    max: number;
    maxAttemptsCount: number;
}
declare class Configuration {
    readonly links: {
        myConversations: string;
        conversations: string;
        users: string;
        currentUser: string;
        typing: string;
        mediaService: string;
        messagesReceipts: string;
    };
    readonly productId?: string;
    readonly typingIndicatorTimeoutOverride?: number;
    readonly typingIndicatorTimeoutDefault: number;
    readonly backoffConfiguration: BackoffConfiguration;
    readonly retryWhenThrottled: boolean;
    readonly consumptionReportInterval: number;
    readonly userInfosToSubscribe: number;
    readonly httpCacheInterval: number;
    readonly reachabilityEnabled: boolean;
    readonly userIdentity: string;
    readonly userInfo: string;
    readonly myConversations: string;
    constructor(options: Record<string, any>, configurationResponse: ConfigurationResponse, logger: Logger);
}
interface CommandExecutorServices {
    transport: Transport;
}
declare class CommandExecutor {
    private _serviceUrl;
    private _services;
    private _productId?;
    constructor(_serviceUrl: string, _services: CommandExecutorServices, _productId?: string);
    private _preProcessUrl;
    private _makeRequest;
    fetchResource<REQ = void, RESP = void>(url: string, requestBody?: REQ): Promise<RESP>;
    mutateResource<REQ = void, RESP = void>(method: "post" | "delete", url: string, requestBody?: REQ): Promise<RESP>;
}
type UserEvents = {
    updated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
};
interface UserServices {
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
/**
 * The reason for the `updated` event being emitted by a user.
 */
type UserUpdateReason = "friendlyName" | "attributes" | "online" | "notifiable";
/**
 * Extended user information.
 * Note that `isOnline` and `isNotifiable` properties are eligible
 * for use only if the reachability function is enabled.
 * You may check if it is enabled by reading the value of {@link Client.reachabilityEnabled}.
 */
declare class User extends ReplayEventEmitter<UserEvents> {
    private entity;
    private state;
    private promiseToFetch;
    private subscribed;
    private links;
    private configuration;
    private readonly services;
    private _initializationPromise;
    private _resolveInitializationPromise;
    /**
     * @internal
     */
    constructor(identity: string, entityName: string, configuration: Configuration | null, services: UserServices);
    /**
     * Fired when the properties or the reachability status of the message have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link User} `user` - the user in question
     *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    readonly updated = "updated";
    /**
     * Fired when the client has subscribed to the user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    readonly userSubscribed = "userSubscribed";
    /**
     * Fired when the client has unsubscribed from the user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    readonly userUnsubscribed = "userUnsubscribed";
    /**
     * User identity.
     */
    get identity(): string;
    set identity(identity: string);
    set entityName(name: string);
    /**
     * Custom attributes of the user.
     */
    get attributes(): any;
    /**
     * Friendly name of the user, null if not set.
     */
    get friendlyName(): string;
    /**
     * Status of the real-time conversation connection of the user.
     */
    get online(): boolean;
    /**
     * User push notification registration status.
     */
    get notifiable(): boolean;
    /**
     * True if this user is receiving real-time status updates.
     */
    get isSubscribed(): boolean;
    // Handles service updates
    private _update;
    // Fetch reachability info
    private _updateReachabilityInfo;
    // Fetch user
    private _fetch;
    // Not private because it is accessed from Client constructor.
    _ensureFetched(): Promise<User>;
    /**
     * Edit user attributes.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: any): Promise<User>;
    /**
     * Update the friendly name of the user.
     * @param friendlyName New friendly name.
     */
    updateFriendlyName(friendlyName: any): Promise<User>;
    /**
     * Remove the user from the subscription list.
     * @return A promise of completion.
     */
    unsubscribe(): Promise<void>;
    _resolveInitialization(configuration: Configuration, identity: string, entityName: string, emitUpdated: boolean): void;
}
/**
 * Pagination helper class.
 *
 * @interface
 * @property {Array} items Elements on current page
 * @property {boolean} hasNextPage Indicates the existence of next page
 * @property {boolean} hasPrevPage Indicates the existence of previous page
 * @function {Promise<Paginator>} nextPage() Request next page. Does not modify existing object
 * @function {Promise<Paginator>} prevPage() Request previous page. Does not modify existing object
 */
interface Paginator<T> {
    hasNextPage: boolean;
    hasPrevPage: boolean;
    items: Array<T>;
    /**
     * Request next page.
     * Does not modify existing object.
     * @return {Promise<Paginator<T>>}
     */
    nextPage(): Promise<Paginator<T>>;
    /**
     * Request previous page.
     * Does not modify existing object.
     * @return {Promise<Paginator<T>>}
     */
    prevPage(): Promise<Paginator<T>>;
}
interface NetworkServices {
    transport: Transport;
}
declare class Network {
    private readonly configuration;
    private readonly services;
    private readonly cacheLifetime;
    private readonly cache;
    private timer;
    constructor(configuration: Configuration, services: NetworkServices);
    private isExpired;
    private cleanupCache;
    pokeTimer(): void;
    private executeWithRetry;
    get(url: string): Promise<any>;
}
type UsersEvents = {
    userUpdated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
};
interface UsersServices {
    network: Network;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
/**
 * @classdesc Container for known users
 * @fires Users#userUpdated
 */
declare class Users extends ReplayEventEmitter<UsersEvents> {
    private readonly configuration;
    private readonly services;
    private userDescriptors;
    private subscribedUsers;
    private fifoStack;
    readonly myself: User;
    constructor(myself: User, configuration: Configuration, services: UsersServices);
    private handleUnsubscribeUser;
    private handleSubscribeUser;
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string, entityName?: string): Promise<User>;
    /**
     * @returns {Promise<UserDescriptor>} User descriptor
     */
    getUserDescriptor(identity: string): Promise<UserDescriptor>;
    /**
     * @returns {Promise<Paginator<UserDescriptor>>} Users descriptors page for given channel sid
     */
    getChannelUserDescriptors(channelSid: string): Promise<Paginator<UserDescriptor>>;
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
interface UserDescriptorServices {
    users: Users;
}
/**
 * Contains extended user information.
 */
declare class UserDescriptor {
    private services;
    private descriptor;
    /**
     * User identity.
     */
    readonly identity: string;
    /**
     * Friendly name of the user, null if not set.
     */
    readonly friendlyName: string;
    /**
     * Custom attributes of the user.
     */
    readonly attributes: any;
    /**
     * Status of the real-time conversation connection of the user.
     *
     * Works only when the reachability functionality is enabled.
     * Refer to {@link Client.reachabilityEnabled}.
     */
    readonly online: boolean;
    /**
     * User push notification registration status.
     *
     * Works only when the reachability functionality is enabled.
     * Refer to {@link Client.reachabilityEnabled}.
     */
    readonly notifiable: boolean;
    /**
     * @internal
     */
    constructor(services: UserDescriptorServices, descriptor: any);
    /**
     * Get the user object from the descriptor and subscribe to it.
     */
    subscribe(): Promise<User>;
    _getDescriptor(): any;
}
type MemberEvents = {
    typingEnded: (member: Member) => void;
    typingStarted: (member: Member) => void;
    updated: (data: {
        member: Member;
        updateReasons: MemberUpdateReason[];
    }) => void;
};
interface MemberDescriptor {
    attributes?: Object;
    dateCreated: any;
    dateUpdated: any;
    identity: string;
    roleSid?: string;
    lastConsumedMessageIndex: number;
    lastConsumptionTimestamp: number;
    type?: MemberType;
    userInfo: string;
}
interface MemberServices {
    users: Users;
    commandExecutor: CommandExecutor;
}
interface MemberLinks {
    self: string;
}
/**
 * The reason for the `updated` event being emitted by a member.
 */
type MemberUpdateReason = "attributes" | "dateCreated" | "dateUpdated" | "roleSid" | "lastConsumedMessageIndex" | "lastConsumptionTimestamp";
/**
 * Push notification type of a member.
 */
type MemberType = "chat" | "sms" | "whatsapp";
/**
 * A member represents a remote client in a channel.
 */
declare class Member extends ReplayEventEmitter<MemberEvents> {
    private state;
    /**
     * Channel that the remote client is a member of.
     */
    readonly channel: Channel;
    private readonly links;
    private readonly services;
    /**
     * @internal
     */
    constructor(data: MemberDescriptor, sid: string, channel: Channel, links: MemberLinks, services: MemberServices);
    /**
     * Fired when the member has started typing.
     *
     * Parameters:
     * 1. {@link Member} `member` - the member in question
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the member has stopped typing.
     *
     * Parameters:
     * 1. {@link Member} `member` - the member in question
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when the fields of the member have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Member} member - the member in question
     *     * {@link MemberUpdateReason}[] updateReasons - array of reasons for the update
     * @event
     */
    static readonly updated = "updated";
    /**
     * The server-assigned unique identifier for the member.
     */
    get sid(): string;
    /**
     * Custom attributes of the member.
     */
    get attributes(): Object;
    /**
     * Date this member was created on.
     */
    get dateCreated(): Date;
    /**
     * Date this member was last updated on.
     */
    get dateUpdated(): Date;
    /**
     * Identity of the member.
     */
    get identity(): string;
    /**
     * Indicates whether the member is currently typing.
     */
    get isTyping(): boolean;
    /**
     * The index of the last consumed message by the member.
     * Note that retrieving messages on a client endpoint does not mean that messages are read,
     * please consider reading about the [Read Horizon feature](https://www.twilio.com/docs/api/chat/guides/consumption-horizon)
     * to find out about the proper way to mark messages as read.
     */
    get lastConsumedMessageIndex(): number | null;
    /**
     * Date of the most recent consumption horizon update.
     */
    get lastConsumptionTimestamp(): Date;
    get roleSid(): string;
    /**
     * Message type of the member.
     */
    get type(): MemberType;
    /**
     * Internal method used to start or reset the typing indicator timeout (with event emitting).
     * @internal
     */
    _startTyping(timeout: any): this;
    /**
     * Internal method function used to stop typing indicator timeout (with event emitting).
     * @internal
     */
    _endTyping(): void;
    /**
     * Internal method function used update local object's property roleSid with a new value.
     * @internal
     */
    _update(data: any): this;
    /**
     * Get the user descriptor for this member. Supported only for members of type `chat`.
     */
    getUserDescriptor(): Promise<UserDescriptor>;
    /**
     * Get the user for this member and subscribes to it. Supported only for members of type `chat`.
     */
    getUser(): Promise<User>;
    /**
     * Remove the member from the channel.
     */
    remove(): Promise<void>;
    /**
     * Update the attributes of the member.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: any): Promise<Member>;
}
interface MediaState {
    sid: string;
    filename?: string;
    contentType: string;
    size: number;
}
interface MediaServices {
    mcsClient: McsClient;
}
/**
 * Represents media information for a message in a channel.
 */
declare class Media {
    private state;
    private services;
    private mcsMedia;
    /**
     * @internal
     */
    constructor(data: MediaState, services: MediaServices);
    /**
     * Server-assigned unique identifier for the media.
     */
    get sid(): string;
    /**
     * File name. Null if absent.
     */
    get filename(): string;
    /**
     * Content type of the media.
     */
    get contentType(): string;
    /**
     * Size of the media in bytes.
     */
    get size(): number;
    /**
     * Returns the direct content URL for the media.
     *
     * This URL is impermanent, it will expire in several minutes and cannot be cached.
     * If the URL becomes expired, you need to request a new one.
     * Each call to this function produces a new temporary URL.
     */
    getContentTemporaryUrl(): Promise<string>;
}
type MessageEvents = {
    updated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
};
interface MessageServices {
    mcsClient: McsClient;
    commandExecutor: CommandExecutor;
}
interface MessageLinks {
    self: string;
    conversation: string;
    messages_receipts: string;
}
/**
 * The reason for the `updated` event being emitted by a message.
 */
type MessageUpdateReason = "body" | "lastUpdatedBy" | "dateCreated" | "dateUpdated" | "attributes" | "author";
/**
 * Push notification type of a message.
 */
type MessageType = "text" | "media";
/**
 * A message in a channel.
 */
declare class Message extends ReplayEventEmitter<MessageEvents> {
    private state;
    /**
     * Channel that the message is in.
     */
    readonly channel: Channel;
    private readonly links;
    private readonly configuration;
    private readonly services;
    /**
     * @internal
     */
    constructor(index: number, data: any, channel: Channel, links: MessageLinks, configuration: Configuration, services: MessageServices);
    /**
     * Fired when the properties or the body of the message have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Message} message - the message in question
     *     * {@link MessageUpdateReason}[] updateReasons - array of reasons for the update
     */
    static readonly updated = "updated";
    /**
     * The server-assigned unique identifier for the message.
     */
    get sid(): string;
    /**
     * Name of the user that sent the message.
     */
    get author(): string;
    /**
     * Body of the message. Null if the message is a media message.
     */
    get body(): string;
    /**
     * Date this message was last updated on.
     */
    get dateUpdated(): Date;
    /**
     * Index of the message in the channel's messages list.
     * By design of the Programmable Chat system, the message indices may have arbitrary gaps between them,
     * that does not necessarily mean they were deleted or otherwise modified - just that
     * messages may have some non-contiguous indices even if they are being sent immediately one after another.
     *
     * Trying to use indices for some calculations is going to be unreliable.
     *
     * To calculate the number of unread messages it is better to use the read horizon API.
     * See {@link Channel.getUnconsumedMessagesCount} for details.
     */
    get index(): number;
    /**
     * Identity of the last user that updated the message.
     */
    get lastUpdatedBy(): string;
    /**
     * Date this message was created on.
     */
    get dateCreated(): Date;
    /**
     * Custom attributes of the message.
     */
    get attributes(): Object;
    /**
     * Push notification type of the message.
     */
    get type(): MessageType;
    /**
     * Media information (if present).
     */
    get media(): Media;
    /**
     * The server-assigned unique identifier of the authoring member.
     */
    get memberSid(): string;
    _update(data: any): void;
    /**
     * Get the member who is the author of the message.
     */
    getMember(): Promise<Member>;
    /**
     * Remove the message.
     */
    remove(): Promise<Message>;
    /**
     * Edit the message body.
     * @param body New body of the message.
     */
    updateBody(body: string): Promise<Message>;
    /**
     * Edit the message attributes.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: any): Promise<Message>;
}
interface TypingIndicatorServices {
    transport: Transport;
    notificationClient: Notifications;
}
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */
declare class TypingIndicator {
    private readonly getChannel;
    private readonly configuration;
    private readonly services;
    private sentUpdates;
    private serviceTypingTimeout;
    constructor(getChannel: any, configuration: Configuration, services: TypingIndicatorServices);
    get typingTimeout(): number;
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */
    initialize(): void;
    /**
     * Remote members typing events handler
     * @private
     */
    private _handleRemoteTyping;
    /**
     * Send typing event for the given channel sid
     * @param {String} channelSid
     */
    send(channelSid: string): Promise<void>;
    private _send;
}
type ChannelEvents = {
    memberJoined: (member: Member) => void;
    memberInvited: (member: Member) => void;
    memberLeft: (member: Member) => void;
    memberUpdated: (data: {
        member: Member;
        updateReasons: MemberUpdateReason[];
    }) => void;
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
    typingEnded: (member: Member) => void;
    typingStarted: (member: Member) => void;
    updated: (data: {
        channel: Channel;
        updateReasons: ChannelUpdateReason[];
    }) => void;
    removed: (channel: Channel) => void;
};
interface ChannelServices {
    users: Users;
    typingIndicator: TypingIndicator;
    network: Network;
    mcsClient: McsClient;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
interface ChannelDescriptor {
    channel: string;
    entityName: string;
    uniqueName: string;
    attributes: any;
    createdBy?: string;
    friendlyName: string;
    lastConsumedMessageIndex: number;
    dateCreated: any;
    dateUpdated: any;
    type: ChannelType;
    notificationLevel?: NotificationLevel;
}
interface ChannelLinks {
    self: string;
    messages: string;
    participants: string;
    invites: string;
}
/**
 * The reason for the `updated` event being emitted by a channel.
 */
type ChannelUpdateReason = "attributes" | "createdBy" | "dateCreated" | "dateUpdated" | "friendlyName" | "lastConsumedMessageIndex" | "state" | "status" | "uniqueName" | "lastMessage" | "notificationLevel";
/**
 * The status of the channel, relative to the client: whether
 * the channel has been `joined` or the client is
 * `notParticipating` in the channel or has been `invited` to
 * the channel.
 */
type ChannelStatus = "unknown" | "notParticipating" | "invited" | "joined";
/**
 * Channel type.
 */
type ChannelType$0 = "public" | "private";
/**
 * The user's notification level for the channel. Determines
 * whether the currently logged-in user will receive pushes for events
 * in this channel. Can be either `muted` or `default`, where
 * `default` defers to the global service push configuration.
 */
type NotificationLevel = "default" | "muted";
/**
 * The conversational state of the channel.
 */
type ChannelState = {
    /**
     * The current state.
     */
    current: "active" | "inactive" | "closed";
    /**
     * Date at which the latest channel state update happened.
     */
    dateUpdated: Date;
};
interface ChannelUpdatedEventArgs {
    channel: Channel;
    updateReasons: ChannelUpdateReason[];
}
/**
 * These options can be passed to {@link Channel.sendMessage}.
 */
interface SendMediaOptions {
    /**
     * Content type of media.
     */
    contentType: string;
    /**
     * Content to post.
     */
    media: string | Buffer;
}
/**
 * Information about the last message of a channel.
 */
interface LastMessage {
    /**
     * Message's index.
     */
    index?: number;
    /**
     *  Message's creation date.
     */
    dateCreated?: Date;
}
/**
 * A channel represents a remote channel of communication between multiple Programmable Chat clients.
 */
declare class Channel extends ReplayEventEmitter<ChannelEvents> {
    private readonly channelState;
    private statusSource;
    private entityPromise;
    private entityName;
    private entity;
    private messagesEntity;
    private membersEntity;
    private readonly members;
    /**
     * Unique system identifier of the channel.
     */
    readonly sid: string;
    readonly links: ChannelLinks;
    private readonly configuration;
    private readonly services;
    /**
     * @internal
     */
    constructor(descriptor: ChannelDescriptor, sid: string, links: ChannelLinks, configuration: Configuration, services: ChannelServices);
    /**
     * Fired when a member has joined the channel.
     *
     * Parameters:
     * 1. {@link Member} `member` - member that joined the channel
     * @event
     */
    static readonly memberJoined = "memberJoined";
    /**
     * Fired when a member has left the channel.
     *
     * Parameters:
     * 1. {@link Member} `member` - member that left the channel
     * @event
     */
    static readonly memberLeft = "memberLeft";
    /**
     * Fired when data of a member has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Member} `member` - member that has received the update
     *     * {@link MemberUpdateReason}[] `updateReasons` - array of reasons for update
     * @event
     */
    static readonly memberUpdated = "memberUpdated";
    /**
     * Fired when a new message has been added to the channel.
     *
     * Parameters:
     * 1. {@link Message} `message` - message that has been added
     * @event
     */
    static readonly messageAdded = "messageAdded";
    /**
     * Fired when message is removed from the channel's message list.
     *
     * Parameters:
     * 1. {@link Message} `message` - message that has been removed
     * @event
     */
    static readonly messageRemoved = "messageRemoved";
    /**
     * Fired when data of a message has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Message} `message` - message that has received the update
     *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for update
     * @event
     */
    static readonly messageUpdated = "messageUpdated";
    /**
     * Fired when a member has stopped typing.
     *
     * Parameters:
     * 1. {@link Member} `member` - the member that has stopped typing
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when a member has started typing.
     *
     * Parameters:
     * 1. {@link Member} `member` - the member that has started typing
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the data of the message has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Channel} `channel` - channel that has received the update
     *     * {@link ChannelUpdateReason}[] `updateReasons` - array of reasons for update
     * @event
     */
    static readonly updated = "updated";
    /**
     * Fired when the channel was destroyed or the currently-logged-in user has left private channel.
     *
     * Parameters:
     * 1. {@link Channel} `channel` - channel that has been removed
     * @event
     */
    static readonly removed = "removed";
    /**
     * Delivery status of the channel.
     */
    get status(): ChannelStatus;
    /**
     * MemberType of the channel.
     */
    get type(): ChannelType$0;
    /**
     * Unique name of the channel.
     */
    get uniqueName(): string;
    /**
     * Signifies whether the channel is private.
     */
    get isPrivate(): boolean;
    /**
     * Name of the channel.
     */
    get friendlyName(): string;
    /**
     * Date this channel was last updated on.
     */
    get dateUpdated(): any;
    /**
     * Date this channel was created on.
     */
    get dateCreated(): any;
    /**
     * Identity of the user that created this channel.
     */
    get createdBy(): string;
    /**
     * Custom attributes of the channel.
     */
    get attributes(): Object;
    /**
     * Index of the last message the user has read in this channel.
     */
    get lastConsumedMessageIndex(): number | null;
    /**
     * Last message sent to this channel.
     */
    get lastMessage(): LastMessage;
    /**
     * User notification level for this channel.
     */
    get notificationLevel(): NotificationLevel;
    /**
     * State of the channel.
     */
    get state(): ChannelState | undefined;
    /**
     * Load and subscribe to this channel and do not subscribe to its members and messages.
     * This or _subscribeStreams will need to be called before any events on channel will fire.
     * @internal
     */
    _subscribe(): Promise<any>;
    /**
     * Load the attributes of this channel and instantiate its members and messages.
     * This or _subscribe will need to be called before any events on the channel will fire.
     * This will need to be called before any events on members or messages will fire
     * @internal
     */
    private _subscribeStreams;
    /**
     * Stop listening for and firing events on this channel.
     * @internal
     */
    private _unsubscribe;
    /**
     * Set channel status.
     * @internal
     */
    _setStatus(status: ChannelStatus, source: Channels.DataSource): void;
    /**
     * Update source of the channel.
     * @internal
     */
    _statusSource(): Channels.DataSource;
    private static preprocessUpdate;
    /**
     * Update the local channel object with new values.
     * @internal
     */
    _update(update: any): void;
    /**
     * @internal
     */
    private _onMessageAdded;
    private _setLastConsumedMessageIndex;
    /**
     * Add a member to the channel by its identity.
     * @param identity Identity of the Client to add.
     */
    add(identity: string): Promise<void>;
    /**
     * Advance the channel's last consumed message index to the current read horizon.
     * Rejects if the user is not a member of the channel.
     * Last consumed message index is updated only if the new index value is higher than the previous.
     * @param index Message index to advance to.
     * @return Resulting unread messages count in the channel.
     */
    advanceLastConsumedMessageIndex(index: number): Promise<number>;
    /**
     * Decline an invitation to the channel and unsubscribe from its events.
     */
    decline(): Promise<Channel>;
    /**
     * Delete the channel and unsubscribe from its events.
     */
    delete(): Promise<Channel>;
    /**
     * Get the custom attributes of this Channel.
     *
     * *Note: {@link Channel.attributes} will be empty for public channels until this function is called.*
     */
    getAttributes(): Promise<any>;
    /**
     * Return messages from the channel using the paginator interface.
     * @param pageSize Number of messages to return in a single chunk. Default is 30.
     * @param anchor Index of the newest message to fetch. Default is from the end.
     * @param direction Query direction. By default it queries backwards
     * from newer to older. The `"forward"` value will query in the opposite direction.
     * @return A page of messages.
     */
    getMessages(pageSize?: number, anchor?: number, direction?: "backwards" | "forward"): Promise<Paginator<Message>>;
    /**
     * Get a list of all the members who are joined to this channel.
     */
    getMembers(): Promise<Member[]>;
    /**
     * Get channel members count.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Programmable Chat system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    getMembersCount(): Promise<number>;
    /**
     * Get a member by its SID.
     * @param memberSid Member SID.
     */
    getMemberBySid(memberSid: string): Promise<Member>;
    /**
     * Get a member by its identity.
     * @param identity Member identity.
     */
    getMemberByIdentity(identity: string): Promise<Member>;
    /**
     * Get the total message count in the channel.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Programmable Chat system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    getMessagesCount(): Promise<number>;
    /**
     * Get unread messages count for the user if they are a member of this channel.
     * Rejects if the user is not a member of the channel.
     *
     * Use this method to obtain the number of unread messages together with
     * {@link Channel.updateLastConsumedMessageIndex} instead of relying on the
     * message indices which may have gaps. See {@link Message.index} for details.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Programmable Chat system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    getUnconsumedMessagesCount(): Promise<number | null>;
    /**
     * Invite a user to the channel by their identity.
     * @param identity Identity of the user.
     */
    invite(identity: string): Promise<void>;
    /**
     * Join the channel and subscribe to its events.
     */
    join(): Promise<Channel>;
    /**
     * Leave the channel.
     */
    leave(): Promise<Channel>;
    /**
     * Remove a member from the channel. When a string is passed as the argument, it will assume that the string is an identity.
     * @param member Identity or the member object to remove.
     */
    removeMember(member: string | Member): Promise<void>;
    /**
     * Send a message to the channel.
     * @param message Message body for the text message,
     * `FormData` or {@link Channel.MediaOptions) for media content. Sending FormData is supported only with the browser engine.
     * @param messageAttributes Attributes for the message.
     * @return Index of the new message.
     */
    sendMessage(message: string | FormData | SendMediaOptions | null, messageAttributes?: any): Promise<number>;
    /**
     * Set last consumed message index of the channel to the index of the last known message.
     * @return Resulting unread messages count in the channel.
     */
    setAllMessagesConsumed(): Promise<number>;
    /**
     * Set all messages in the channel unread.
     * @return Resulting unread messages count in the channel.
     */
    setNoMessagesConsumed(): Promise<number>;
    /**
     * Set user notification level for this channel.
     * @param notificationLevel New user notification level.
     */
    setUserNotificationLevel(notificationLevel: NotificationLevel): Promise<void>;
    /**
     * Send a notification to the server indicating that this client is currently typing in this channel.
     * Typing ended notification is sent after a while automatically, but by calling this method again you ensure that typing ended is not received.
     */
    typing(): Promise<void>;
    /**
     * Update the attributes of the channel.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: any): Promise<Channel>;
    /**
     * Update the friendly name of the channel.
     * @param friendlyName New friendly name.
     */
    updateFriendlyName(friendlyName: string): Promise<Channel>;
    /**
     * Set the last consumed message index to the current read horizon.
     * @param index Message index to set as last consumed.
     * If null is provided, then the behavior is identical to {@link Channel.setNoMessagesConsumed}.
     * @returns Resulting unread messages count in the channel.
     */
    updateLastConsumedMessageIndex(index: number | null): Promise<number>;
    /**
     * Update the unique name of the channel.
     * @param uniqueName New unique name for the channel. Setting unique name to null removes it.
     */
    updateUniqueName(uniqueName: string | null): Promise<Channel>;
    /**
     * Get user descriptors of this channel.
     */
    getUserDescriptors(): Promise<Paginator<UserDescriptor>>;
}
/**
 * Contains channel information.
 * Unlike {@link Channel}, this information won't be updated in realtime.
 * To have fresh data, user should query for channel descriptors again.
 */
declare class ChannelDescriptor$0 {
    client: Client;
    descriptor: any;
    /**
     * Unique system identifier of the channel.
     */
    readonly sid: string;
    /**
     * Custom attributes of the channel.
     */
    readonly channel: string;
    /**
     * Unique name of the channel.
     */
    readonly uniqueName: string;
    /**
     * Name of the channel.
     */
    readonly friendlyName: string;
    /**
     * Custom attributes of the channel.
     */
    readonly attributes: any;
    /**
     * Identity of the user that created this channel.
     */
    readonly createdBy: string;
    /**
     * Date this channel was created on.
     */
    readonly dateCreated: Date;
    /**
     * Date this channel was last updated on.
     */
    readonly dateUpdated: Date;
    /**
     * Amount of messages in the channel.
     */
    readonly messagesCount: number;
    /**
     * Amount of members in the channel.
     */
    readonly membersCount: number;
    /**
     * Index of the last message the user has read in this channel.
     */
    readonly lastConsumedMessageIndex: number;
    /**
     * Delivery status of the channel.
     */
    readonly status: ChannelStatus;
    /**
     * MemberType of the channel.
     */
    readonly type: ChannelType$0;
    /**
     * Signifies whether the channel is private.
     */
    readonly isPrivate: boolean;
    /**
     * User notification level for this channel.
     */
    readonly notificationLevel: NotificationLevel;
    /**
     * @internal
     */
    constructor(client: Client, descriptor: any);
    /**
     * Get the channel object from the descriptor.
     */
    getChannel(): Promise<Channel>;
}
declare class Deferred<T> {
    private _promise;
    private _resolve;
    private _reject;
    current: T;
    constructor();
    get promise(): Promise<T>;
    update(value: T): void;
    set(value: T): void;
    fail(e: any): void;
}
/**
 * @classdesc Pagination helper class for Sync
 *
 * @property {Array} items Array of elements on current page
 * @property {boolean} hasNextPage
 * @property {boolean} hasPrevPage
 */
declare class SyncPaginator<T> implements Paginator<T> {
    private state;
    hasNextPage: boolean;
    hasPrevPage: boolean;
    get items(): Array<T>;
    /**
     * @param {Array} items Array of element for current page
     * @param {Object} params
     */
    constructor(items: any, pageSize: any, anchor: any, direction: any, source: any);
    nextPage(): Promise<SyncPaginator<T>>;
    prevPage(): Promise<SyncPaginator<T>>;
}
type ChannelsEvents = {
    channelAdded: (channel: Channel) => void;
    channelJoined: (channel: Channel) => void;
    channelInvited: (channel: Channel) => void;
    channelLeft: (channel: Channel) => void;
    channelRemoved: (channel: Channel) => void;
    channelUpdated: (data: {
        channel: Channel;
        updateReasons: ChannelUpdateReason[];
    }) => void;
    memberJoined: (member: Member) => void;
    memberLeft: (member: Member) => void;
    memberUpdated: (data: {
        member: Member;
        updateReasons: MemberUpdateReason[];
    }) => void;
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
    typingEnded: (member: Member) => void;
    typingStarted: (member: Member) => void;
};
interface ChannelsServices {
    syncClient: SyncClient;
    users: Users;
    typingIndicator: TypingIndicator;
    network: Network;
    mcsClient: McsClient;
    commandExecutor: CommandExecutor;
}
/**
 * Represents channels collection
 * {@see Channel}
 */
declare class Channels extends ReplayEventEmitter<ChannelsEvents> {
    private readonly configuration;
    private readonly services;
    readonly channels: Map<string, Channel>;
    private readonly tombstones;
    private myChannelsFetched;
    myChannelsRead: Deferred<boolean>;
    constructor(configuration: Configuration, services: ChannelsServices);
    private getMap;
    /**
     * Add channel to server
     * @private
     * @returns {Promise<Channel>} Channel
     */
    addChannel(options: any): Promise<Channel>;
    /**
     * Fetch channels list and instantiate all necessary objects
     */
    fetchChannels(): Promise<Channels>;
    private _wrapPaginator;
    getChannels(args: any): Promise<SyncPaginator<Channel>>;
    getChannel(sid: string): Promise<Channel>;
    pushChannel(descriptor: Channel | ChannelDescriptor$0): Promise<Channel>;
    private _updateChannel;
    private upsertChannel;
    private onChannelRemoved;
    private registerForEvents;
    private _fetchMyChannels;
}
declare namespace Channels {
    type DataSource = "sync" | "chat" | "rest";
}
/**
 * Push notification type.
 */
type PushNotificationType = "twilio.channel.new_message" | "twilio.channel.added_to_channel" | "twilio.channel.invited_to_channel" | "twilio.channel.removed_from_channel";
interface PushNotificationDescriptor {
    title: string;
    body: string;
    sound: string;
    badge: number;
    action: string;
    type: PushNotificationType;
    data: Object;
}
/**
 * Additional data for a given push notification.
 */
interface PushNotificationData {
    /**
     * SID of the conversation.
     */
    conversationSid?: string;
    /**
     * Index of the message in the conversation.
     */
    messageIndex?: number;
    /**
     * SID of the message in the conversation.s
     */
    messageSid?: string;
}
/**
 * Push notification for a Conversations client.
 */
declare class PushNotification {
    /**
     * Title of the notification.
     */
    readonly title: string;
    /**
     * Text of the notification.
     */
    readonly body: string;
    /**
     * Sound of the notification.
     */
    readonly sound: string;
    /**
     * Number of the badge.
     */
    readonly badge: number;
    /**
     * Notification action (`click_action` in FCM/GCM terms and `category` in APN terms).
     */
    readonly action: string;
    /**
     * Type of the notification.
     */
    readonly type: PushNotificationType;
    /**
     * Additional data of the conversation.
     */
    readonly data: PushNotificationData;
    /**
     * @internal
     */
    constructor(data: PushNotificationDescriptor);
}
type ClientEvents = {
    channelAdded: (channel: Channel) => void;
    channelInvited: (channel: Channel) => void;
    channelJoined: (channel: Channel) => void;
    channelLeft: (channel: Channel) => void;
    channelRemoved: (channel: Channel) => void;
    channelUpdated: (data: {
        channel: Channel;
        updateReasons: ChannelUpdateReason[];
    }) => void;
    memberJoined: (member: Member) => void;
    memberLeft: (member: Member) => void;
    memberUpdated: (data: {
        member: Member;
        updateReasons: MemberUpdateReason[];
    }) => void;
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
    tokenAboutToExpire: (ttl: number) => void;
    tokenExpired: () => void;
    typingEnded: (member: Member) => void;
    typingStarted: (member: Member) => void;
    pushNotification: (pushNotification: PushNotification) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
    userUpdated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    stateChanged: (state: State) => void;
    connectionStateChanged: (state: TwilsockConnectionState) => void;
    connectionError: (data: {
        terminal: boolean;
        message: string;
        httpStatusCode?: number;
        errorCode?: number;
    }) => void;
};
/**
 * Connection state of the client. Possible values are as follows:
 * * `'connecting'` - client is offline and connection attempt is in process
 * * `'connected'` - client is online and ready
 * * `'disconnecting'` - client is going offline as disconnection is in process
 * * `'disconnected'` - client is offline and no connection attempt is in process
 * * `'denied'` - client connection is denied because of invalid JWT access token. User must
 * refresh token in order to proceed
 */
type ConnectionState = TwilsockConnectionState;
/**
 * State of the client. Possible values are as follows:
 * * `'failed'` - the client failed to initialize
 * * `'initialized'` - the client successfully initialized
 */
type State = "failed" | "initialized";
/**
 * Notifications channel type. Possible values are as follows:
 * * `'fcm'`
 * * `'apn'`
 */
type NotificationsChannelType = ChannelType;
type LogLevel = "trace" | "debug" | "info" | "warn" | "error" | "silent" | null;
/**
 * Chat client options.
 */
interface ClientOptions {
    region?: string;
    /**
     * The level of logging to enable.
     */
    logLevel?: LogLevel;
    productId?: string;
    twilsockClient?: TwilsockClient;
    transport?: Transport;
    notificationsClient?: NotificationClient;
    syncClient?: SyncClient;
    typingIndicatorTimeoutOverride?: number;
    consumptionReportIntervalOverride?: string;
    httpCacheIntervalOverride?: number;
    userInfosToSubscribeOverride?: number;
    retryWhenThrottledOverride?: boolean;
    backoffConfigOverride?: any;
    Chat?: any;
    IPMessaging?: any;
    Sync?: any;
    Notification?: any;
    Twilsock?: any;
    clientMetadata?: any;
    disableDeepClone?: boolean;
    initRegistrations?: InitRegistration[];
}
/**
 * Options for {@link Client.createChannel}.
 */
interface CreateChannelOptions {
    /**
     * Any custom attributes to attach to the channel.
     */
    attributes?: any;
    /**
     * A non-unique display name of the channel.
     */
    friendlyName?: string;
    /**
     * Signifies whether the channel is private.
     */
    isPrivate?: boolean;
    /**
     * A unique identifier of the channel.
     */
    uniqueName?: string;
}
/**
 * Channel sorting criteria.
 */
type ChannelSortingCriteria = "lastMessage" | "friendlyName" | "uniqueName";
/**
 * Channel sorting order.
 */
type ChannelSortingOrder = "ascending" | "descending";
/**
 * Channel sorting options.
 */
interface ChannelSortingOptions {
    /**
     * Channel sorting criteria.
     */
    criteria?: ChannelSortingCriteria;
    /**
     * Channel sorting order.
     */
    order?: ChannelSortingOrder;
}
/**
 * A client is the starting point to the Twilio Programmable Chat functionality.
 */
declare class Client extends ReplayEventEmitter<ClientEvents> {
    private fpaToken;
    private readonly options;
    /**
     * Client connection state.
     */
    connectionState: ConnectionState; // @todo make private?
    private _ensureReady;
    private _resolveEnsureReady;
    private _rejectEnsureReady;
    private channelsPromise;
    private configurationPromise;
    private configuration;
    private channels;
    private readonly services;
    private readonly _myself;
    /**
     * Current version of the Chat client.
     */
    static readonly version: string;
    /**
     * Current version of the Chat client.
     */
    readonly version: string;
    private static readonly supportedPushChannels;
    private static readonly supportedPushDataFields;
    /**
     * Returned client instance is not yet fully initialized. Calling any operations will block until it is.
     * Use connection events to monitor when client becomes fully available (connectionStateChanged with state
     * 'connected') or not available (connectionStateChange with state 'denied', event tokenExpired, event connectionError).
     *
     * @param fpaToken Access token
     * @param options Options to customize the Client
     * @returns A not yet fully-initialized client.
     */
    constructor(fpaToken: string, options?: ClientOptions);
    /**
     * Fired when a channel becomes visible to the client. The event is also triggered when the client creates a new channel.
     * Fired for all channels client has joined.
     *
     * Parameters:
     * 1. {@link Channel} `channel` - the channel in question
     * @event
     */
    static readonly channelAdded = "channelAdded";
    /**
     * Fired when the client gets invited to a channel.
     *
     * Parameters:
     * 1. {@link Channel} `channel` - the channel in question
     * @event
     */
    static readonly channelInvited = "channelInvited";
    /**
     * Fired when the client joins a channel.
     *
     * Parameters:
     * 1. {@link Channel} `channel` - the channel in question
     * @event
     */
    static readonly channelJoined = "channelJoined";
    /**
     * Fired when the client leaves a channel.
     *
     * Parameters:
     * 1. {@link Channel} `channel` - the channel in question
     * @event
     */
    static readonly channelLeft = "channelLeft";
    /**
     * Fired when a channel is no longer visible to the client.
     *
     * Parameters:
     * 1. {@link Channel} `channel` - the channel in question
     * @event
     */
    static readonly channelRemoved = "channelRemoved";
    /**
     * Fired when the attributes or the metadata of a channel have been updated.
     * During channel's {@link Client.constructor| creation and initialization}, this event might be fired multiple times
     * for same joined or created channel as new data is arriving from different sources.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Channel} `channel` - the channel in question
     *     * {@link ChannelUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    static readonly channelUpdated = "channelUpdated";
    /**
     * Fired when a member has joined a channel.
     *
     * Parameters:
     * 1. {@link Member} `member` - the member in question
     * @event
     */
    static readonly memberJoined = "memberJoined";
    /**
     * Fired when a member has left a channel.
     *
     * Parameters:
     * 1. {@link Member} `member` - the member in question
     * @event
     */
    static readonly memberLeft = "memberLeft";
    /**
     * Fired when a member's fields have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Member} `member` - the member in question
     *     * {@link MemberUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    static readonly memberUpdated = "memberUpdated";
    /**
     * Fired when a new message has been added to the channel on the server.
     *
     * Parameters:
     * 1. {@link Message} `message` - the message in question
     * @event
     */
    static readonly messageAdded = "messageAdded";
    /**
     * Fired when a message is removed from the message list of a channel.
     *
     * Parameters:
     * 1. {@link Message} `message` - the message in question
     * @event
     */
    static readonly messageRemoved = "messageRemoved";
    /**
     * Fired when the fields of an existing message are updated with new values.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Message} `message` - the message in question
     *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    static readonly messageUpdated = "messageUpdated";
    /**
     * Fired when the token is about to expire and needs to be updated.
     *
     * * Parameters:
     * 1. number `ttl` - token's time to live
     * @event
     */
    static readonly tokenAboutToExpire = "tokenAboutToExpire";
    /**
     * Fired when the token has expired.
     * @event
     */
    static readonly tokenExpired = "tokenExpired";
    /**
     * Fired when a member has stopped typing.
     *
     * Parameters:
     * 1. {@link Member} `member` - the member in question
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when a member has started typing.
     *
     * Parameters:
     * 1. {@link Member} `member` - the member in question
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the client has received (and parsed) a push notification via one of the push channels (apn or fcm).
     *
     * Parameters:
     * 1. {@link PushNotification} `pushNotification` - the push notification in question
     * @event
     */
    static readonly pushNotification = "pushNotification";
    /**
     * Fired when the client has subscribed to a user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    static readonly userSubscribed = "userSubscribed";
    /**
     * Fired when the client has unsubscribed from a user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    static readonly userUnsubscribed = "userUnsubscribed";
    /**
     * Fired when the properties or the reachability status of a user have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link User} `user` - the user in question
     *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    static readonly userUpdated = "userUpdated";
    /**
     * Fired when the connection is interrupted for an unexpected reason.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * boolean `terminal` - Twilsock will stop connection attempts if true
     *     * string `message` - the error message of the root cause
     *     * number? `httpStatusCode` - http status code if available
     *     * number? `errorCode` - Twilio public error code if available
     * @event
     */
    static readonly connectionError = "connectionError";
    /**
     * Fired when the state of the client has been changed.
     *
     * Parameters:
     * 1. {@link State} `state` - the new client state
     * @event
     */
    static readonly stateChanged = "stateChanged";
    /**
     * Fired when the connection state of the client has been changed.
     *
     * Parameters:
     * 1. {@link ConnectionState} `connectionState` - the updated connection state
     * @event
     */
    static readonly connectionStateChanged = "connectionStateChanged";
    /**
     * @deprecated Call constructor directly.
     *
     * Factory method to create Chat client instance.
     *
     * The factory method will automatically trigger connection.
     * Do not use it if you need finer-grained control.
     *
     * @param token Access token.
     * @param options Options to customize the client.
     * @returns Returns a fully initialized client.
     */
    static create(token: string, options?: ClientOptions): Promise<Client>;
    /**
     * Information of the logged-in user. Before client initialization, returns an
     * uninitialized user. Will trigger a {@link Client.userUpdated} event after
     * initialization.
     */
    get user(): User;
    /**
     * Client reachability state. Throws if accessed before the client
     * initialization was completed.
     */
    get reachabilityEnabled(): boolean;
    get token(): string;
    static populateInitRegistrations(reg: InitRegistration): void;
    private _subscribeToPushNotifications;
    private _unsubscribeFromPushNotifications;
    private _initialize;
    /**
     * Gracefully shut down the client.
     */
    shutdown(): Promise<void>;
    /**
     * Update the token used by the client and re-register with the Programmable Chat services.
     * @param token New access token.
     */
    updateToken(token: string): Promise<Client>;
    /**
     * Get a known channel by its SID.
     * @param channelSid Channel sid
     */
    getChannelBySid(channelSid: string): Promise<Channel>;
    /**
     * Get a known channel by its unique identifier name.
     * @param uniqueName The unique identifier name of the channel.
     */
    getChannelByUniqueName(uniqueName: string): Promise<Channel>;
    /**
     * Get the current list of all the subscribed channels.
     */
    getSubscribedChannels(args?: any): Promise<Paginator<Channel>>;
    /**
     * Get an array of channels that are locally known to the client in the provided sorting order.
     * Locally known channels are the ones that are created and/or joined during the client runtime
     * and all the subscribed channel of the currently-logged-in user.
     * To ensure that the full list of the subscribed channels has fetched, call the
     * {@link Client.getSubscribedChannels} method
     * and fetch all the pages with the help of the {@link RestPaginator.nextPage} method.
     * @param sortingOptions Sorting options.
     */
    getLocalChannels(sortingOptions?: ChannelSortingOptions): Promise<Array<Channel>>;
    private static compareChannelsByLastMessage;
    private static compareChannelsByStringProperty;
    /**
     * Get the content of the public channels directory.
     */
    getPublicChannelDescriptors(): Promise<Paginator<ChannelDescriptor$0>>;
    /**
     * Get the content of the channels directory of the user (created by, joined or invited to).
     */
    getUserChannelDescriptors(): Promise<Paginator<ChannelDescriptor$0>>;
    /**
     * Create a channel on the server and subscribe to its events.
     * The default is a public channel with an empty friendly name.
     * @param options Options for the channel.
     */
    createChannel(options?: CreateChannelOptions): Promise<Channel>;
    /**
     * Register for push notifications.
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the platform.
     */
    setPushRegistrationId(channelType: NotificationsChannelType, registrationId: string): Promise<void>;
    /**
     * Unregister from push notifications.
     * @param channelType Channel type.
     */
    unsetPushRegistrationId(channelType: NotificationsChannelType): Promise<void>;
    private static parsePushNotificationChatData;
    /**
     * Static method for push notification payload parsing. Returns parsed push as a {@link PushNotification} object.
     * @param notificationPayload Push notification payload.
     */
    static parsePushNotification(notificationPayload: any): PushNotification;
    parsePushNotification: typeof Client.parsePushNotification;
    /**
     * Handle push notification payload parsing and emit the {@link Client.pushNotification} event on this {@link Client} instance.
     * @param notificationPayload Push notification payload
     */
    handlePushNotification(notificationPayload: any): Promise<void>;
    /**
     * Gets a user with the given identity. If it's in the subscribed list, then return the user object from it;
     * if not, then subscribe and add user to the subscribed list.
     * @param identity Identity of the user.
     * @returns A fully initialized user.
     */
    getUser(identity: string): Promise<User>;
    /**
     * Gets the user descriptor for given identity.
     * @param identity Identity of the user.
     * @returns The user descriptor.
     */
    getUserDescriptor(identity: string): Promise<UserDescriptor>;
    /**
     * Get a list of subscribed user objects.
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
/**
 * Pagination helper class.
 */
declare class RestPaginator<T> implements Paginator<T> {
    private state;
    /**
     * Indicates the existence of the next page.
     */
    get hasNextPage(): boolean;
    /**
     * Indicates the existence of the previous page
     */
    get hasPrevPage(): boolean;
    /**
     * Array of elements on the current page.
     */
    get items(): Array<T>;
    /**
     * @internal
     */
    constructor(items: any, source: any, prevToken: any, nextToken: any);
    /**
     * Request the next page. Does not modify the existing object.
     */
    nextPage(): Promise<RestPaginator<T>>;
    /**
     * Request the previous page. Does not modify the existing object.
     */
    prevPage(): Promise<RestPaginator<T>>;
}
export { Channel, ChannelUpdateReason, ChannelType$0 as ChannelType, ChannelStatus, NotificationLevel, ChannelState, ChannelUpdatedEventArgs, SendMediaOptions, LastMessage, ChannelDescriptor$0 as ChannelDescriptor, UserDescriptor, Member, MemberUpdateReason, MemberType, Message, MessageUpdateReason, MessageType, Media, RestPaginator, User, UserUpdateReason, PushNotification, PushNotificationData, Client, ConnectionState, NotificationsChannelType, ClientOptions, CreateChannelOptions, ChannelSortingCriteria, ChannelSortingOrder, ChannelSortingOptions, State };
