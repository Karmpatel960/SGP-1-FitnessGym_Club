import { EventEmitter } from "events";
import { TwilsockClient, ConnectionState } from "twilsock";
import { LogLevelDesc } from "loglevel";
type ChannelType = "twilsock" | "apn" | "fcm";
interface PushNotification {
    messageType: string;
    payload: any;
}
interface NotificationOptions {
    region?: string;
    ersUrl?: string;
}
interface ClientOptions {
    logLevel?: LogLevelDesc;
    minTokenRefreshInterval?: number;
    productId?: string;
    twilsockClient?: TwilsockClient;
    notifications?: NotificationOptions;
    region?: string;
}
/**
 * @class
 * @alias Notifications
 * @classdesc The helper library for the notification service.
 * Provides high level api for creating and managing notification subscriptions and receiving messages
 * Creates the instance of Notification helper library
 *
 * @constructor
 * @param {string} token - Twilio access token
 * @param {Notifications#ClientOptions} options - Options to customize client behavior
 *
 * @event stateChanged channelType (registered|unregistered) -- coming from connector, i.e. it's per-connector type!
 * @event transportState Forwarded from Twilsock's stateChanged event.
 * @event message Routed from twilsock as a notification event.
 */
declare class Client extends EventEmitter {
    private readonly twilsock?;
    private readonly connectors;
    constructor(token: string, options?: ClientOptions);
    shutdown(): Promise<void>;
    /**
     * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.
     *
     * You must call this function once you've received the ID of your device from the underlying OS.
     *
     * @param {ChannelType} channelType Channel type ('apn'/'fcm').
     * @param {string} pushRegistrationId Token received from FCM/APNS system on device.
     */
    setPushRegistrationId(channelType: ChannelType, pushRegistrationId: string): void;
    /**
     * Subscribe to a given message type for a given channel type.
     *
     * Creates a subscriptions to receive incoming messages according to message type.
     * Subscription establishes a binding and you will receive a signal when a notification
     * of this type has been received by the library.
     *
     * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.
     * This is the responsibility of the client SDK.
     *
     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
     * @param {string} messageType The type of message that you want to receive
     */
    subscribe(channelType: ChannelType, messageType: string): void;
    /**
     * Unsubscribe from a given message type.
     *
     * Unsubscribing breaks a binding and you will not receive more notifications for this message type.
     * Please note that you have to call commitChanges() and receive a successful result before
     * the subscription is actually removed.
     *
     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
     * @param {string} messageType The type of message that you don't want to receive anymore
     */
    unsubscribe(channelType: ChannelType, messageType: string): void;
    /**
     * Update subscription token. You must update the token when the old one expires.
     *
     * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed
     * token _after_ you have updated twilsock and other associated objects with the new token.
     *
     * @param {string} token Authentication token for registrations
     */
    updateToken(token: string): void;
    /**
     * Commit all collected subscription changes as a batched update. This function tries to reduce
     * number of network calls necessary to update bindings status.
     */
    commitChanges(): Promise<void>;
    /**
     * Clear existing registrations directly using provided device token.
     * This is useful to ensure stopped subscriptions without resubscribing.
     *
     * This function goes completely beside the state machine and removes all registrations.
     * Use with caution: if it races with current state machine operations, madness will ensue.
     *
     * @param {ChannelType} channelType Channel type ('apn'/'fcm').
     * @param {string} registrationId Token received from FCM/APNS system on device.
     */
    removeRegistrations(channelType: ChannelType, registrationId: string): Promise<void>;
    /**
     * Handle incoming push notification.
     * Client application should call this method when it receives push notifications and pass the received data.
     * @param {Object} message push message
     * @return {PushNotification} A reformatted payload with extracted message type.
     */
    handlePushNotification(message: any): PushNotification;
    /**
     * Routes messages to the external subscribers
     */
    private _routeMessage;
    /**
     * @param {String} type Channel type
     * @throws {Error} Error with description
     */
    private _connector;
    /**
     * Returns platform string limited to max 128 chars
     */
    private static _detectPlatform;
}
export { Client as Notifications, ChannelType, ConnectionState, PushNotification };
