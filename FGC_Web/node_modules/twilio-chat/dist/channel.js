/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2019, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes javascript-state-machine under the following license.

    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes q under the following license.

    Copyright 2009â€“2014 Kristopher Michael Kowal. All rights reserved.
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

This software includes platform.js under the following license.

    Copyright 2014 Benjamin Tan <https://d10.github.io/>
    Copyright 2011-2015 John-David Dalton <http://allyoucanleet.com/>

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('./node_modules/tslib/tslib.es6.js');
var logger = require('./logger.js');
var members = require('./data/members.js');
var member = require('./member.js');
var messages = require('./data/messages.js');
var index = require('./util/index.js');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var isEqual = require('lodash.isequal');
var replayEventEmitter = require('@twilio/replay-event-emitter');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

const log = logger.Logger.scope('Channel');
const fieldMappings = {
    lastMessage: 'lastMessage',
    attributes: 'attributes',
    createdBy: 'createdBy',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    friendlyName: 'friendlyName',
    lastConsumedMessageIndex: 'lastConsumedMessageIndex',
    notificationLevel: 'notificationLevel',
    sid: 'sid',
    status: 'status',
    type: 'type',
    uniqueName: 'uniqueName',
    state: 'state'
};
function parseTime(timeString) {
    try {
        return new Date(timeString);
    }
    catch (e) {
        return null;
    }
}
/**
 * A channel represents a remote channel of communication between multiple Programmable Chat clients.
 */
class Channel extends replayEventEmitter.ReplayEventEmitter {
    /**
     * @internal
     */
    constructor(descriptor, sid, links, configuration, services) {
        super();
        this.sid = sid;
        this.links = links;
        this.configuration = configuration;
        this.services = services;
        let attributes = descriptor.attributes || {};
        let createdBy = descriptor.createdBy;
        let dateCreated = parseTime(descriptor.dateCreated);
        let dateUpdated = parseTime(descriptor.dateUpdated);
        let friendlyName = descriptor.friendlyName || null;
        let lastConsumedMessageIndex = Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;
        let uniqueName = descriptor.uniqueName || null;
        try {
            JSON.stringify(attributes);
        }
        catch (e) {
            throw new Error('Attributes must be a valid JSON object.');
        }
        this.entityName = descriptor.channel;
        this.channelState = {
            uniqueName,
            status: 'notParticipating',
            type: descriptor.type,
            attributes,
            createdBy,
            dateCreated,
            dateUpdated,
            friendlyName,
            lastConsumedMessageIndex
        };
        if (descriptor.notificationLevel) {
            this.channelState.notificationLevel = descriptor.notificationLevel;
        }
        const membersLinks = {
            participants: this.links.participants
        };
        this.members = new Map();
        this.membersEntity = new members.Members(this, this.members, membersLinks, this.configuration, this.services);
        this.membersEntity.on('memberJoined', this.emit.bind(this, 'memberJoined'));
        this.membersEntity.on('memberLeft', this.emit.bind(this, 'memberLeft'));
        this.membersEntity.on('memberUpdated', (args) => this.emit('memberUpdated', args));
        this.messagesEntity = new messages.Messages(this, this.configuration, services);
        this.messagesEntity.on('messageAdded', message => this._onMessageAdded(message));
        this.messagesEntity.on('messageUpdated', (args) => this.emit('messageUpdated', args));
        this.messagesEntity.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
    }
    /**
     * Delivery status of the channel.
     */
    get status() { return this.channelState.status; }
    /**
     * MemberType of the channel.
     */
    get type() { return this.channelState.type; }
    /**
     * Unique name of the channel.
     */
    get uniqueName() { return this.channelState.uniqueName; }
    /**
     * Signifies whether the channel is private.
     */
    get isPrivate() { return this.channelState.type === 'private'; }
    /**
     * Name of the channel.
     */
    get friendlyName() { return this.channelState.friendlyName; }
    /**
     * Date this channel was last updated on.
     */
    get dateUpdated() { return this.channelState.dateUpdated; }
    /**
     * Date this channel was created on.
     */
    get dateCreated() { return this.channelState.dateCreated; }
    /**
     * Identity of the user that created this channel.
     */
    get createdBy() { return this.channelState.createdBy; }
    /**
     * Custom attributes of the channel.
     */
    get attributes() { return this.channelState.attributes; }
    /**
     * Index of the last message the user has read in this channel.
     */
    get lastConsumedMessageIndex() { return this.channelState.lastConsumedMessageIndex; }
    /**
     * Last message sent to this channel.
     */
    get lastMessage() { return this.channelState.lastMessage; }
    /**
     * User notification level for this channel.
     */
    get notificationLevel() { return this.channelState.notificationLevel; }
    /**
     * State of the channel.
     */
    get state() { return this.channelState.state; }
    /**
     * Load and subscribe to this channel and do not subscribe to its members and messages.
     * This or _subscribeStreams will need to be called before any events on channel will fire.
     * @internal
     */
    async _subscribe() {
        if (this.entityPromise) {
            return this.entityPromise;
        }
        return this.entityPromise = this.entityPromise ||
            this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' })
                .then(entity => {
                this.entity = entity;
                this.entity.on('updated', args => { this._update(args.data); });
                this.entity.on('removed', () => this.emit('removed', this));
                this._update(this.entity.data);
                return entity;
            })
                .catch(err => {
                this.entity = null;
                this.entityPromise = null;
                if (this.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get channel object', err);
                }
                log.debug('ERROR: Failed to get channel object', err);
                throw err;
            });
    }
    /**
     * Load the attributes of this channel and instantiate its members and messages.
     * This or _subscribe will need to be called before any events on the channel will fire.
     * This will need to be called before any events on members or messages will fire
     * @internal
     */
    async _subscribeStreams() {
        try {
            await this._subscribe();
            log.trace('_subscribeStreams, this.entity.data=', this.entity.data);
            const messagesObjectName = this.entity.data.messages;
            const rosterObjectName = this.entity.data.roster;
            await Promise.all([
                this.messagesEntity.subscribe(messagesObjectName),
                this.membersEntity.subscribe(rosterObjectName)
            ]);
        }
        catch (err) {
            if (this.services.syncClient.connectionState !== 'disconnected') {
                log.error('Failed to subscribe on channel objects', this.sid, err);
            }
            log.debug('ERROR: Failed to subscribe on channel objects', this.sid, err);
            throw err;
        }
    }
    /**
     * Stop listening for and firing events on this channel.
     * @internal
     */
    async _unsubscribe() {
        // Keep our subscription to public channels objects
        if (this.isPrivate && this.entity) {
            await this.entity.close();
            this.entity = null;
            this.entityPromise = null;
        }
        return Promise.all([
            this.membersEntity.unsubscribe(),
            this.messagesEntity.unsubscribe()
        ]);
    }
    /**
     * Set channel status.
     * @internal
     */
    _setStatus(status, source) {
        this.statusSource = source;
        if (this.channelState.status === status) {
            return;
        }
        this.channelState.status = status;
        if (status === 'joined') {
            this._subscribeStreams()
                .catch(err => {
                log.debug('ERROR while setting channel status ' + status, err);
                if (this.services.syncClient.connectionState !== 'disconnected') {
                    throw err;
                }
            });
        }
        else if (status === 'invited') {
            this._subscribe()
                .catch(err => {
                log.debug('ERROR while setting channel status ' + status, err);
                if (this.services.syncClient.connectionState !== 'disconnected') {
                    throw err;
                }
            });
        }
        else if (this.entityPromise) {
            this._unsubscribe().catch(err => {
                log.debug('ERROR while setting channel status ' + status, err);
                if (this.services.syncClient.connectionState !== 'disconnected') {
                    throw err;
                }
            });
        }
    }
    /**
     * Update source of the channel.
     * @internal
     */
    _statusSource() {
        return this.statusSource;
    }
    static preprocessUpdate(update, channelSid) {
        try {
            if (typeof update.attributes === 'string') {
                update.attributes = JSON.parse(update.attributes);
            }
            else if (update.attributes) {
                JSON.stringify(update.attributes);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);
            update.attributes = {};
        }
        try {
            if (update.dateCreated) {
                update.dateCreated = new Date(update.dateCreated);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed dateCreated from the server for channel: ' + channelSid);
            delete update.dateCreated;
        }
        try {
            if (update.dateUpdated) {
                update.dateUpdated = new Date(update.dateUpdated);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed dateUpdated from the server for channel: ' + channelSid);
            delete update.dateUpdated;
        }
        try {
            if (update.lastMessage && update.lastMessage.timestamp) {
                update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed lastMessage.timestamp from the server for channel: ' + channelSid);
            delete update.lastMessage.timestamp;
        }
    }
    /**
     * Update the local channel object with new values.
     * @internal
     */
    _update(update) {
        var _a, _b, _c, _d, _e;
        log.trace('_update', update);
        Channel.preprocessUpdate(update, this.sid);
        const updateReasons = new Set();
        for (const key of Object.keys(update)) {
            const localKey = fieldMappings[key];
            if (!localKey) {
                continue;
            }
            switch (localKey) {
                case fieldMappings.status:
                    if (!update.status || update.status === 'unknown'
                        || this.channelState.status === update.status) {
                        break;
                    }
                    this.channelState.status = update.status;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.attributes:
                    if (isEqual__default['default'](this.channelState.attributes, update.attributes)) {
                        break;
                    }
                    this.channelState.attributes = update.attributes;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.lastConsumedMessageIndex:
                    if (update.lastConsumedMessageIndex === undefined
                        || update.lastConsumedMessageIndex === this.channelState.lastConsumedMessageIndex) {
                        break;
                    }
                    this.channelState.lastConsumedMessageIndex = update.lastConsumedMessageIndex;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.lastMessage:
                    if (this.channelState.lastMessage && !update.lastMessage) {
                        delete this.channelState.lastMessage;
                        updateReasons.add(localKey);
                        break;
                    }
                    this.channelState.lastMessage = this.channelState.lastMessage || {};
                    if (((_a = update.lastMessage) === null || _a === void 0 ? void 0 : _a.index) !== undefined
                        && update.lastMessage.index !== this.channelState.lastMessage.index) {
                        this.channelState.lastMessage.index = update.lastMessage.index;
                        updateReasons.add(localKey);
                    }
                    if (((_b = update.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp) !== undefined
                        && ((_d = (_c = this.channelState.lastMessage) === null || _c === void 0 ? void 0 : _c.dateCreated) === null || _d === void 0 ? void 0 : _d.getTime()) !== update.lastMessage.timestamp.getTime()) {
                        this.channelState.lastMessage.dateCreated = update.lastMessage.timestamp;
                        updateReasons.add(localKey);
                    }
                    if (isEqual__default['default'](this.channelState.lastMessage, {})) {
                        delete this.channelState.lastMessage;
                    }
                    break;
                case fieldMappings.state:
                    const state = update.state || undefined;
                    if (state !== undefined) {
                        state.dateUpdated = new Date(state.dateUpdated);
                    }
                    if (isEqual__default['default'](this.channelState.state, state)) {
                        break;
                    }
                    this.channelState.state = state;
                    updateReasons.add(localKey);
                    break;
                default:
                    const isDate = update[key] instanceof Date;
                    const keysMatchAsDates = isDate && ((_e = this.channelState[localKey]) === null || _e === void 0 ? void 0 : _e.getTime()) === update[key].getTime();
                    const keysMatchAsNonDates = !isDate && this[localKey] === update[key];
                    if (keysMatchAsDates || keysMatchAsNonDates) {
                        break;
                    }
                    this.channelState[localKey] = update[key];
                    updateReasons.add(localKey);
            }
        }
        if (updateReasons.size > 0) {
            this.emit('updated', { channel: this, updateReasons: [...updateReasons] });
        }
    }
    /**
     * @internal
     */
    _onMessageAdded(message) {
        for (let member of this.members.values()) {
            if (member.identity === message.author) {
                member._endTyping();
                break;
            }
        }
        this.emit('messageAdded', message);
    }
    async _setLastConsumedMessageIndex(index) {
        const result = await this.services.commandExecutor.mutateResource('post', `${this.configuration.links.myConversations}/${this.sid}`, {
            last_consumed_message_index: index
        });
        return result.unread_messages_count;
    }
    /**
     * Add a member to the channel by its identity.
     * @param identity Identity of the Client to add.
     */
    async add(identity) {
        await this.membersEntity.add(identity);
    }
    /**
     * Advance the channel's last consumed message index to the current read horizon.
     * Rejects if the user is not a member of the channel.
     * Last consumed message index is updated only if the new index value is higher than the previous.
     * @param index Message index to advance to.
     * @return Resulting unread messages count in the channel.
     */
    async advanceLastConsumedMessageIndex(index) {
        await this._subscribeStreams();
        if (index < this.lastConsumedMessageIndex) {
            return await this._setLastConsumedMessageIndex(this.lastConsumedMessageIndex);
        }
        return await this._setLastConsumedMessageIndex(index);
    }
    /**
     * Decline an invitation to the channel and unsubscribe from its events.
     */
    async decline() {
        await this.services.commandExecutor.mutateResource('delete', `${this.links.invites}/${this.configuration.userIdentity}`);
        return this;
    }
    /**
     * Delete the channel and unsubscribe from its events.
     */
    async delete() {
        await this.services.commandExecutor.mutateResource('delete', this.links.self);
        return this;
    }
    /**
     * Get the custom attributes of this Channel.
     *
     * *Note: {@link Channel.attributes} will be empty for public channels until this function is called.*
     */
    async getAttributes() {
        await this._subscribe();
        return this.attributes;
    }
    /**
     * Return messages from the channel using the paginator interface.
     * @param pageSize Number of messages to return in a single chunk. Default is 30.
     * @param anchor Index of the newest message to fetch. Default is from the end.
     * @param direction Query direction. By default it queries backwards
     * from newer to older. The `"forward"` value will query in the opposite direction.
     * @return A page of messages.
     */
    async getMessages(pageSize, anchor, direction) {
        await this._subscribeStreams();
        return await this.messagesEntity.getMessages(pageSize, anchor, direction);
    }
    /**
     * Get a list of all the members who are joined to this channel.
     */
    async getMembers() {
        await this._subscribeStreams();
        return await this.membersEntity.getMembers();
    }
    /**
     * Get channel members count.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Programmable Chat system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    async getMembersCount() {
        const url = new index.UriBuilder(this.configuration.links.conversations).path(this.sid).build();
        const response = await this.services.network.get(url);
        return response.body.participants_count;
    }
    /**
     * Get a member by its SID.
     * @param memberSid Member SID.
     */
    async getMemberBySid(memberSid) {
        return await this.membersEntity.getMemberBySid(memberSid);
    }
    /**
     * Get a member by its identity.
     * @param identity Member identity.
     */
    async getMemberByIdentity(identity) {
        return await this.membersEntity.getMemberByIdentity(identity);
    }
    /**
     * Get the total message count in the channel.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Programmable Chat system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    async getMessagesCount() {
        const url = new index.UriBuilder(this.configuration.links.conversations).path(this.sid).build();
        const response = await this.services.network.get(url);
        return response.body.messages_count;
    }
    /**
     * Get unread messages count for the user if they are a member of this channel.
     * Rejects if the user is not a member of the channel.
     *
     * Use this method to obtain the number of unread messages together with
     * {@link Channel.updateLastConsumedMessageIndex} instead of relying on the
     * message indices which may have gaps. See {@link Message.index} for details.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Programmable Chat system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    async getUnconsumedMessagesCount() {
        const url = new index.UriBuilder(this.configuration.links.myConversations).path(this.sid).build();
        const response = await this.services.network.get(url);
        if (response.body.conversation_sid !== this.sid) {
            throw new Error('Channel was not found in the user channels list');
        }
        const unreadMessageCount = response.body.unread_messages_count;
        if (typeof unreadMessageCount === 'number') {
            return unreadMessageCount;
        }
        return null;
    }
    /**
     * Invite a user to the channel by their identity.
     * @param identity Identity of the user.
     */
    async invite(identity) {
        await this.membersEntity.invite(identity);
    }
    /**
     * Join the channel and subscribe to its events.
     */
    async join() {
        await this.services.commandExecutor.mutateResource('post', this.links.participants, {
            identity: this.configuration.userIdentity
        });
        return this;
    }
    /**
     * Leave the channel.
     */
    async leave() {
        if (this.channelState.status === 'joined') {
            await this.services.commandExecutor.mutateResource('delete', `${this.links.participants}/${this.configuration.userIdentity}`);
        }
        return this;
    }
    /**
     * Remove a member from the channel. When a string is passed as the argument, it will assume that the string is an identity.
     * @param member Identity or the member object to remove.
     */
    async removeMember(member) {
        await this.membersEntity.remove(typeof member === 'string' ? member : member.sid);
    }
    /**
     * Send a message to the channel.
     * @param message Message body for the text message,
     * `FormData` or {@link Channel.MediaOptions) for media content. Sending FormData is supported only with the browser engine.
     * @param messageAttributes Attributes for the message.
     * @return Index of the new message.
     */
    async sendMessage(message, messageAttributes) {
        if (typeof message === 'string' || message === null) {
            const response = await this.messagesEntity.send(message, messageAttributes);
            return index.parseToNumber(response.index);
        }
        const response = await this.messagesEntity.sendMedia(message, messageAttributes);
        return index.parseToNumber(response.index);
    }
    /**
     * Set last consumed message index of the channel to the index of the last known message.
     * @return Resulting unread messages count in the channel.
     */
    async setAllMessagesConsumed() {
        await this._subscribeStreams();
        const messagesPage = await this.getMessages(1);
        if (messagesPage.items.length > 0) {
            return this.advanceLastConsumedMessageIndex(messagesPage.items[0].index);
        }
        return Promise.resolve(0);
    }
    /**
     * Set all messages in the channel unread.
     * @return Resulting unread messages count in the channel.
     */
    async setNoMessagesConsumed() {
        await this._subscribeStreams();
        return await this._setLastConsumedMessageIndex(null);
    }
    /**
     * Set user notification level for this channel.
     * @param notificationLevel New user notification level.
     */
    async setUserNotificationLevel(notificationLevel) {
        await this.services.commandExecutor.mutateResource('post', `${this.configuration.links.myConversations}/${this.sid}`, {
            notification_level: notificationLevel
        });
    }
    /**
     * Send a notification to the server indicating that this client is currently typing in this channel.
     * Typing ended notification is sent after a while automatically, but by calling this method again you ensure that typing ended is not received.
     */
    typing() {
        return this.services.typingIndicator.send(this.sid);
    }
    /**
     * Update the attributes of the channel.
     * @param attributes New attributes.
     */
    async updateAttributes(attributes) {
        await this.services.commandExecutor.mutateResource('post', this.links.self, { attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined });
        return this;
    }
    /**
     * Update the friendly name of the channel.
     * @param friendlyName New friendly name.
     */
    async updateFriendlyName(friendlyName) {
        if (this.channelState.friendlyName !== friendlyName) {
            await this.services.commandExecutor.mutateResource('post', this.links.self, { friendly_name: friendlyName });
        }
        return this;
    }
    /**
     * Set the last consumed message index to the current read horizon.
     * @param index Message index to set as last consumed.
     * If null is provided, then the behavior is identical to {@link Channel.setNoMessagesConsumed}.
     * @returns Resulting unread messages count in the channel.
     */
    async updateLastConsumedMessageIndex(index) {
        await this._subscribeStreams();
        return await this._setLastConsumedMessageIndex(index);
    }
    /**
     * Update the unique name of the channel.
     * @param uniqueName New unique name for the channel. Setting unique name to null removes it.
     */
    async updateUniqueName(uniqueName) {
        if (this.channelState.uniqueName !== uniqueName) {
            if (!uniqueName) {
                uniqueName = '';
            }
            await this.services.commandExecutor.mutateResource('post', this.links.self, { unique_name: uniqueName });
        }
        return this;
    }
    /**
     * Get user descriptors of this channel.
     */
    async getUserDescriptors() {
        return await this.services.users.getChannelUserDescriptors(this.sid);
    }
}
/**
 * Fired when a member has joined the channel.
 *
 * Parameters:
 * 1. {@link Member} `member` - member that joined the channel
 * @event
 */
Channel.memberJoined = 'memberJoined';
/**
 * Fired when a member has left the channel.
 *
 * Parameters:
 * 1. {@link Member} `member` - member that left the channel
 * @event
 */
Channel.memberLeft = 'memberLeft';
/**
 * Fired when data of a member has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Member} `member` - member that has received the update
 *     * {@link MemberUpdateReason}[] `updateReasons` - array of reasons for update
 * @event
 */
Channel.memberUpdated = 'memberUpdated';
/**
 * Fired when a new message has been added to the channel.
 *
 * Parameters:
 * 1. {@link Message} `message` - message that has been added
 * @event
 */
Channel.messageAdded = 'messageAdded';
/**
 * Fired when message is removed from the channel's message list.
 *
 * Parameters:
 * 1. {@link Message} `message` - message that has been removed
 * @event
 */
Channel.messageRemoved = 'messageRemoved';
/**
 * Fired when data of a message has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Message} `message` - message that has received the update
 *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for update
 * @event
 */
Channel.messageUpdated = 'messageUpdated';
/**
 * Fired when a member has stopped typing.
 *
 * Parameters:
 * 1. {@link Member} `member` - the member that has stopped typing
 * @event
 */
Channel.typingEnded = 'typingEnded';
/**
 * Fired when a member has started typing.
 *
 * Parameters:
 * 1. {@link Member} `member` - the member that has started typing
 * @event
 */
Channel.typingStarted = 'typingStarted';
/**
 * Fired when the data of the message has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Channel} `channel` - channel that has received the update
 *     * {@link ChannelUpdateReason}[] `updateReasons` - array of reasons for update
 * @event
 */
Channel.updated = 'updated';
/**
 * Fired when the channel was destroyed or the currently-logged-in user has left private channel.
 *
 * Parameters:
 * 1. {@link Channel} `channel` - channel that has been removed
 * @event
 */
Channel.removed = 'removed';
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "add", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "advanceLastConsumedMessageIndex", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(['undefined', declarativeTypeValidator.nonNegativeInteger], ['undefined', declarativeTypeValidator.nonNegativeInteger], ['undefined', declarativeTypeValidator.literal('backwards', 'forward')]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number, Number, String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "getMessages", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "getMemberBySid", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "getMemberByIdentity", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "invite", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.nonEmptyString, member.Member]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "removeMember", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'string',
        declarativeTypeValidator.literal(null),
        // Wrapping it into a custom rule is necessary because the FormData class is not available on initialization.
        declarativeTypeValidator.custom((value) => [value instanceof FormData, 'an instance of FormData']),
        declarativeTypeValidator.objectSchema('media options', {
            contentType: [declarativeTypeValidator.nonEmptyString, 'undefined'],
            media: declarativeTypeValidator.custom((value) => {
                let isValid = (typeof value === 'string' && value.length > 0) || value instanceof Uint8Array || value instanceof ArrayBuffer;
                if (typeof Blob === 'function') {
                    isValid = isValid || value instanceof Blob;
                }
                return [
                    isValid,
                    'a non-empty string, an instance of Buffer or an instance of Blob'
                ];
            })
        })
    ], ['undefined', 'string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object, Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "sendMessage", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal('default', 'muted')),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "setUserNotificationLevel", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "updateAttributes", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync('string'),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "updateFriendlyName", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.literal(null), declarativeTypeValidator.nonNegativeInteger]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "updateLastConsumedMessageIndex", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(['string', declarativeTypeValidator.literal(null)]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Channel.prototype, "updateUniqueName", null);

exports.Channel = Channel;
//# sourceMappingURL=channel.js.map
