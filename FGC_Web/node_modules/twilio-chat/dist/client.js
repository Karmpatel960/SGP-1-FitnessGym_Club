/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2019, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes javascript-state-machine under the following license.

    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes q under the following license.

    Copyright 2009â€“2014 Kristopher Michael Kowal. All rights reserved.
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

This software includes platform.js under the following license.

    Copyright 2014 Benjamin Tan <https://d10.github.io/>
    Copyright 2011-2015 John-David Dalton <http://allyoucanleet.com/>

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('./node_modules/tslib/tslib.es6.js');
var logger = require('./logger.js');
var configuration = require('./configuration.js');
var user = require('./user.js');
var publicchannels = require('./data/publicchannels.js');
var network = require('./services/network.js');
var notificationtypes = require('./interfaces/notificationtypes.js');
var notifications = require('@twilio/notifications');
var twilsock = require('twilsock');
var twilioSync = require('twilio-sync');
var mcsClient = require('@twilio/mcs-client');
var channels = require('./data/channels.js');
var users = require('./data/users.js');
var typingindicator = require('./services/typingindicator.js');
var userchannels = require('./data/userchannels.js');
var pushnotification = require('./pushnotification.js');
var index = require('./util/index.js');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var commandexecutor = require('./commandexecutor.js');
var _package = require('./packages/chat/package.json.js');
var replayEventEmitter = require('@twilio/replay-event-emitter');

var Client_1;
const log = logger.Logger.scope('Client');
const SDK_VERSION = _package.version;
class ClientServices {
}
/**
 * A client is the starting point to the Twilio Programmable Chat functionality.
 */
exports.Client = Client_1 = class Client extends replayEventEmitter.ReplayEventEmitter {
    /**
     * Returned client instance is not yet fully initialized. Calling any operations will block until it is.
     * Use connection events to monitor when client becomes fully available (connectionStateChanged with state
     * 'connected') or not available (connectionStateChange with state 'denied', event tokenExpired, event connectionError).
     *
     * @param fpaToken Access token
     * @param options Options to customize the Client
     * @returns A not yet fully-initialized client.
     */
    constructor(fpaToken, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        super();
        this.fpaToken = fpaToken;
        this.options = options;
        /**
         * Client connection state.
         */
        this.connectionState = 'unknown'; // @todo make private?
        this._ensureReady = null;
        this._resolveEnsureReady = null;
        this._rejectEnsureReady = null;
        this.channelsPromise = null;
        this.configurationPromise = null;
        /**
         * Current version of the Chat client.
         */
        this.version = SDK_VERSION;
        this.parsePushNotification = Client_1.parsePushNotification;
        this.options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
        if (!this.options.disableDeepClone) {
            let options = Object.assign(Object.assign({}, this.options), { transport: undefined, twilsockClient: undefined });
            options = index.deepClone(options);
            options.transport = this.options.transport;
            options.twilsockClient = this.options.twilsockClient;
            this.options = options;
        }
        this.options.logLevel = (_b = this.options.logLevel) !== null && _b !== void 0 ? _b : 'silent';
        log.setLevel(this.options.logLevel);
        const productId = this.options.productId = 'ip_messaging';
        // Fill ClientMetadata
        this.options.clientMetadata = (_c = this.options.clientMetadata) !== null && _c !== void 0 ? _c : {};
        if (!this.options.clientMetadata.hasOwnProperty('type')) {
            this.options.clientMetadata.type = 'chat';
        }
        if (!this.options.clientMetadata.hasOwnProperty('sdk')) {
            this.options.clientMetadata.sdk = 'JS';
            this.options.clientMetadata.sdkv = SDK_VERSION;
        }
        // Enable session local storage for Sync
        this.options.Sync = (_d = this.options.Sync) !== null && _d !== void 0 ? _d : {};
        if (!((_e = this.options.Sync) === null || _e === void 0 ? void 0 : _e.enableSessionStorage)) {
            this.options.Sync.enableSessionStorage = true;
        }
        if (this.options.region) {
            this.options.Sync.region = this.options.region;
        }
        this.services = new ClientServices();
        const startTwilsock = !this.options.twilsockClient;
        // Create default init registrations if none were provided.
        // Otherwise, the outside party have to list all the init registrations they need, including Sync ones.
        if (!this.options.initRegistrations) {
            const initRegistration = new twilsock.InitRegistration(productId);
            Client_1.populateInitRegistrations(initRegistration);
            twilioSync.SyncClient.populateInitRegistrations(initRegistration);
            this.options.initRegistrations = [initRegistration];
        }
        this.services.twilsockClient = (this.options.twilsockClient = (_f = this.options.twilsockClient) !== null && _f !== void 0 ? _f : new twilsock.TwilsockClient(fpaToken, productId, this.options));
        this.services.twilsockClient.on('tokenAboutToExpire', (ttl) => this.emit('tokenAboutToExpire', ttl));
        this.services.twilsockClient.on('tokenExpired', () => this.emit('tokenExpired'));
        this.services.twilsockClient.on('connectionError', (error) => this.emit('connectionError', error));
        this.services.twilsockClient.on('stateChanged', (state) => {
            log.debug(`Handling stateChanged for ChatClient: new state ${state}`);
            if (state !== this.connectionState) {
                this.connectionState = state;
                this.emit('connectionStateChanged', this.connectionState);
            }
        });
        this.services.transport = (this.options.transport = ((_g = this.options.transport) !== null && _g !== void 0 ? _g : this.options.twilsockClient));
        this.services.notificationClient = (this.options.notificationsClient = (_h = this.options.notificationsClient) !== null && _h !== void 0 ? _h : new notifications.Notifications(fpaToken, this.options));
        this.services.syncClient = (this.options.syncClient = (_j = this.options.syncClient) !== null && _j !== void 0 ? _j : new twilioSync.SyncClient(fpaToken, this.options));
        const configurationOptions = (_p = (_o = (_l = (_k = this.options) === null || _k === void 0 ? void 0 : _k.Chat) !== null && _l !== void 0 ? _l : (_m = this.options) === null || _m === void 0 ? void 0 : _m.IPMessaging) !== null && _o !== void 0 ? _o : this.options) !== null && _p !== void 0 ? _p : {};
        const region = (_q = configurationOptions.region) !== null && _q !== void 0 ? _q : this.options.region;
        const baseUrl = (_s = (_r = configurationOptions.apiUri) !== null && _r !== void 0 ? _r : configurationOptions.typingUri) !== null && _s !== void 0 ? _s : `https://aim.${region || 'us1'}.twilio.com`;
        this.services.commandExecutor = new commandexecutor.CommandExecutor(baseUrl, { transport: this.options.transport }, productId);
        const emitFailed = (err) => {
            this._rejectEnsureReady(err);
            this.emit('stateChanged', 'failed');
        };
        this.services.twilsockClient.once('connectionError', emitFailed);
        this.services.twilsockClient.once('disconnected', emitFailed);
        // ChatClient will be able to initialize only after twilsock is connected
        this.services.twilsockClient.once('connected', async () => {
            log.debug(`ChatClient started INITIALIZING`);
            this.services.twilsockClient.off('connectionError', emitFailed);
            this.services.twilsockClient.off('disconnected', emitFailed);
            try {
                await this._initialize();
            }
            catch (err) {
                // Fail ChatClient if initialization is incomplete
                this._rejectEnsureReady(err);
                this.emit('stateChanged', 'failed');
            }
        });
        this._ensureReady = new Promise((resolve, reject) => {
            this._resolveEnsureReady = resolve;
            this._rejectEnsureReady = reject;
        }).catch((err) => { }); // @todo How to process unhandled rejection here?
        this._myself = new user.User('', '', null, this.services);
        if (startTwilsock) {
            this.services.twilsockClient.connect();
        }
    }
    /**
     * @deprecated Call constructor directly.
     *
     * Factory method to create Chat client instance.
     *
     * The factory method will automatically trigger connection.
     * Do not use it if you need finer-grained control.
     *
     * @param token Access token.
     * @param options Options to customize the client.
     * @returns Returns a fully initialized client.
     */
    static async create(token, options) {
        // The logic is as follows:
        // - If twilsock is not passed in, then the ChatClient constructor will call twilsock.connect() by itself
        //   and we do not need to do it here.
        // - If twilsock was passed in from the outside, but customer called ChatClient.create() then they are
        //   using an obsolete workflow and the startup sequence will never complete.
        if (options === null || options === void 0 ? void 0 : options.twilsockClient) {
            throw new Error('Obsolete usage of ChatClient.create() factory method: if you pass twilsock from the outside then you must use ChatClient constructor and be prepared to work with uninitialized client.');
        }
        const client = new Client_1(token, options);
        await client._ensureReady;
        return client;
    }
    /**
     * Information of the logged-in user. Before client initialization, returns an
     * uninitialized user. Will trigger a {@link Client.userUpdated} event after
     * initialization.
     */
    get user() { return this._myself; }
    /**
     * Client reachability state. Throws if accessed before the client
     * initialization was completed.
     */
    get reachabilityEnabled() {
        if (!this.configuration) {
            throw new Error('Reachability information could not yet be accessed as the client ' +
                "has not yet been initialized. Subscribe to the 'stateChanged' event " +
                'to properly react to the client initialization.');
        }
        return this.configuration.reachabilityEnabled;
    }
    get token() { return this.fpaToken; }
    static populateInitRegistrations(reg) {
        reg.populateInitRegistrations([notificationtypes.NotificationTypes.TYPING_INDICATOR]);
    }
    _subscribeToPushNotifications(channelType) {
        [notificationtypes.NotificationTypes.NEW_MESSAGE,
            notificationtypes.NotificationTypes.ADDED_TO_CHANNEL,
            notificationtypes.NotificationTypes.INVITED_TO_CHANNEL,
            notificationtypes.NotificationTypes.REMOVED_FROM_CHANNEL,
            notificationtypes.NotificationTypes.CONSUMPTION_UPDATE] // Supported only on iOS
            .forEach(messageType => {
            this.services.notificationClient.subscribe(channelType, messageType);
        });
    }
    _unsubscribeFromPushNotifications(channelType) {
        [notificationtypes.NotificationTypes.NEW_MESSAGE,
            notificationtypes.NotificationTypes.ADDED_TO_CHANNEL,
            notificationtypes.NotificationTypes.INVITED_TO_CHANNEL,
            notificationtypes.NotificationTypes.REMOVED_FROM_CHANNEL,
            notificationtypes.NotificationTypes.CONSUMPTION_UPDATE] // Supported only on iOS
            .forEach(messageType => {
            this.services.notificationClient.unsubscribe(channelType, messageType);
        });
    }
    async _initialize() {
        const configurationResponse = await this.services.commandExecutor.fetchResource('Client/v1/Configuration');
        this.configuration = new configuration.Configuration(this.options, configurationResponse, log);
        this._myself._resolveInitialization(this.configuration, this.configuration.userIdentity, this.configuration.userInfo, true);
        this.services.typingIndicator = new typingindicator.TypingIndicator(this.getChannelBySid.bind(this), this.configuration, this.services);
        this.services.network = new network.Network(this.configuration, this.services);
        this.services.users = new users.Users(this._myself, this.configuration, this.services);
        this.services.users.on('userSubscribed', this.emit.bind(this, 'userSubscribed'));
        this.services.users.on('userUpdated', (args) => this.emit('userUpdated', args));
        this.services.users.on('userUnsubscribed', this.emit.bind(this, 'userUnsubscribed'));
        this.channels = new channels.Channels(this.configuration, this.services);
        this.channels.on('channelAdded', this.emit.bind(this, 'channelAdded'));
        this.channels.on('channelInvited', this.emit.bind(this, 'channelInvited'));
        this.channels.on('channelRemoved', this.emit.bind(this, 'channelRemoved'));
        this.channels.on('channelJoined', this.emit.bind(this, 'channelJoined'));
        this.channels.on('channelLeft', this.emit.bind(this, 'channelLeft'));
        this.channels.on('channelUpdated', (args) => this.emit('channelUpdated', args));
        this.channels.on('memberJoined', this.emit.bind(this, 'memberJoined'));
        this.channels.on('memberLeft', this.emit.bind(this, 'memberLeft'));
        this.channels.on('memberUpdated', (args) => this.emit('memberUpdated', args));
        this.channels.on('messageAdded', this.emit.bind(this, 'messageAdded'));
        this.channels.on('messageUpdated', (args) => this.emit('messageUpdated', args));
        this.channels.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
        this.channels.on('typingStarted', this.emit.bind(this, 'typingStarted'));
        this.channels.on('typingEnded', this.emit.bind(this, 'typingEnded'));
        this.channelsPromise = this.channels.fetchChannels()
            .then(() => this.channels)
            .catch((err) => { throw err; });
        await this.services.users.myself._ensureFetched();
        Client_1.supportedPushChannels.forEach(channelType => this._subscribeToPushNotifications(channelType));
        this.services.typingIndicator.initialize();
        this.services.publicChannels = new publicchannels.PublicChannels(this, this.services, this.configuration.links.conversations);
        this.services.userChannels = new userchannels.UserChannels(this, this.services, this.configuration.links.myConversations);
        this.services.mcsClient = new mcsClient.McsClient(this.fpaToken, this.configuration.links.mediaService, null, Object.assign(Object.assign({}, this.options), { transport: null }));
        this._resolveEnsureReady();
        this.emit('stateChanged', 'initialized');
    }
    /**
     * Gracefully shut down the client.
     */
    async shutdown() {
        await this._ensureReady;
        await this.services.syncClient.shutdown(); // also disconnects twilsock
    }
    /**
     * Update the token used by the client and re-register with the Programmable Chat services.
     * @param token New access token.
     */
    async updateToken(token) {
        await this._ensureReady;
        log.info('updateToken');
        if (this.fpaToken === token) {
            return this;
        }
        await this.services.twilsockClient.updateToken(token);
        this.fpaToken = token;
        this.services.mcsClient.updateToken(token);
        await this.configurationPromise;
        return this;
    }
    /**
     * Get a known channel by its SID.
     * @param channelSid Channel sid
     */
    async getChannelBySid(channelSid) {
        await this._ensureReady;
        await this.channels.myChannelsRead.promise;
        let channel = await this.channels.getChannel(channelSid);
        if (!channel) {
            channel = await this.services.publicChannels.getChannelBySid(channelSid);
        }
        return await this.channels.pushChannel(channel);
    }
    /**
     * Get a known channel by its unique identifier name.
     * @param uniqueName The unique identifier name of the channel.
     */
    async getChannelByUniqueName(uniqueName) {
        await this._ensureReady;
        await this.channels.myChannelsRead.promise;
        const channel = await this.services.publicChannels.getChannelByUniqueName(uniqueName);
        return await this.channels.pushChannel(channel);
    }
    /**
     * Get the current list of all the subscribed channels.
     */
    async getSubscribedChannels(args) {
        await this._ensureReady;
        const channelsEntity = await this.channelsPromise;
        return await channelsEntity.getChannels(args);
    }
    /**
     * Get an array of channels that are locally known to the client in the provided sorting order.
     * Locally known channels are the ones that are created and/or joined during the client runtime
     * and all the subscribed channel of the currently-logged-in user.
     * To ensure that the full list of the subscribed channels has fetched, call the
     * {@link Client.getSubscribedChannels} method
     * and fetch all the pages with the help of the {@link RestPaginator.nextPage} method.
     * @param sortingOptions Sorting options.
     */
    async getLocalChannels(sortingOptions) {
        await this._ensureReady;
        const channelsEntity = await this.channelsPromise;
        let result = Array.from(channelsEntity.channels.values());
        const sortingOrder = (sortingOptions === null || sortingOptions === void 0 ? void 0 : sortingOptions.order) || 'ascending';
        if (sortingOptions === null || sortingOptions === void 0 ? void 0 : sortingOptions.criteria) {
            if (sortingOptions.criteria === 'lastMessage') {
                result.sort((a, b) => Client_1.compareChannelsByLastMessage(a, b, sortingOrder));
            }
            else if (sortingOptions.criteria === 'uniqueName') {
                result.sort((a, b) => Client_1.compareChannelsByStringProperty(a.uniqueName, b.uniqueName, sortingOrder));
            }
            else if (sortingOptions.criteria === 'friendlyName') {
                result.sort((a, b) => Client_1.compareChannelsByStringProperty(a.friendlyName, b.friendlyName, sortingOrder));
            }
        }
        return result;
    }
    static compareChannelsByLastMessage(a, b, order) {
        const lessThan = (a, b) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            if (((_b = (_a = a.lastMessage) === null || _a === void 0 ? void 0 : _a.dateCreated) === null || _b === void 0 ? void 0 : _b.getTime()) > ((_d = (_c = b.lastMessage) === null || _c === void 0 ? void 0 : _c.dateCreated) === null || _d === void 0 ? void 0 : _d.getTime())) {
                // console.log('A time > B time');
                return 1;
            }
            else if (((_f = (_e = a.lastMessage) === null || _e === void 0 ? void 0 : _e.dateCreated) === null || _f === void 0 ? void 0 : _f.getTime()) < ((_h = (_g = b.lastMessage) === null || _g === void 0 ? void 0 : _g.dateCreated) === null || _h === void 0 ? void 0 : _h.getTime())) {
                // console.log('A time < B time');
                return -1;
            }
            if ((_j = b.lastMessage) === null || _j === void 0 ? void 0 : _j.dateCreated) {
                // console.log('B has time');
                return 1;
            }
            else if ((_k = a.lastMessage) === null || _k === void 0 ? void 0 : _k.dateCreated) {
                // console.log('A has time');
                return -1;
            }
            if (b.lastMessage) {
                // console.log('B has lastmessage');
                return 1;
            }
            else if (a.lastMessage) {
                // console.log('A has lastmessage');
                return -1;
            }
            return 0;
        };
        const result = lessThan(a, b);
        console.log(`Sorted ${a.sid} and ${b.sid}: return ${result}`);
        return (order === 'ascending') ? result : -result;
    }
    static compareChannelsByStringProperty(str1, str2, order) {
        const lessThan = (a, b) => {
            if (a && b) {
                return str1.localeCompare(str2);
            }
            else if (b) {
                return 1;
            }
            else if (a) {
                return -1;
            }
            return 0;
        };
        const result = lessThan(str1, str2);
        return (order === 'ascending') ? result : -result;
    }
    /**
     * Get the content of the public channels directory.
     */
    async getPublicChannelDescriptors() {
        await this._ensureReady;
        return await this.services.publicChannels.getChannels();
    }
    /**
     * Get the content of the channels directory of the user (created by, joined or invited to).
     */
    async getUserChannelDescriptors() {
        await this._ensureReady;
        return await this.services.userChannels.getChannels();
    }
    /**
     * Create a channel on the server and subscribe to its events.
     * The default is a public channel with an empty friendly name.
     * @param options Options for the channel.
     */
    async createChannel(options) {
        await this._ensureReady;
        options = options || {};
        const channelsEntity = await this.channelsPromise;
        return await channelsEntity.addChannel(options);
    }
    /**
     * Register for push notifications.
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the platform.
     */
    async setPushRegistrationId(channelType, registrationId) {
        await this._ensureReady;
        this.services.notificationClient.setPushRegistrationId(channelType, registrationId);
        await this.services.notificationClient.commitChanges(); // Committing before this point is useless because we have no push id
    }
    /**
     * Unregister from push notifications.
     * @param channelType Channel type.
     */
    async unsetPushRegistrationId(channelType) {
        await this._ensureReady;
        // await this.services.notificationClient.removeRegistrations(..) // @todo
        // old version:
        this._unsubscribeFromPushNotifications(channelType);
        await this.services.notificationClient.commitChanges();
    }
    static parsePushNotificationChatData(data) {
        let result = {};
        for (let key in Client_1.supportedPushDataFields) {
            if (typeof data[key] !== 'undefined' && data[key] !== null) {
                if (key === 'message_index') {
                    if (index.parseToNumber(data[key]) !== null) {
                        result[Client_1.supportedPushDataFields[key]] = Number(data[key]);
                    }
                }
                else {
                    result[Client_1.supportedPushDataFields[key]] = data[key];
                }
            }
        }
        return result;
    }
    /**
     * Static method for push notification payload parsing. Returns parsed push as a {@link PushNotification} object.
     * @param notificationPayload Push notification payload.
     */
    static parsePushNotification(notificationPayload) {
        log.debug('parsePushNotification, notificationPayload=', notificationPayload);
        // APNS specifics
        if (typeof notificationPayload.aps !== 'undefined') {
            if (!notificationPayload.twi_message_type) {
                throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
            }
            let data = Client_1.parsePushNotificationChatData(notificationPayload);
            let apsPayload = notificationPayload.aps;
            let body = null;
            let title = null;
            if (typeof apsPayload.alert === 'string') {
                body = apsPayload.alert || null;
            }
            else {
                body = apsPayload.alert.body || null;
                title = apsPayload.alert.title || null;
            }
            return new pushnotification.PushNotification({
                title: title,
                body: body,
                sound: apsPayload.sound || null,
                badge: apsPayload.badge || null,
                action: apsPayload.category || null,
                type: notificationPayload.twi_message_type,
                data: data
            });
        }
        // FCM specifics
        if (typeof notificationPayload.data !== 'undefined') {
            let dataPayload = notificationPayload.data;
            if (!dataPayload.twi_message_type) {
                throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
            }
            let data = Client_1.parsePushNotificationChatData(notificationPayload.data);
            return new pushnotification.PushNotification({
                title: dataPayload.twi_title || null,
                body: dataPayload.twi_body || null,
                sound: dataPayload.twi_sound || null,
                badge: null,
                action: dataPayload.twi_action || null,
                type: dataPayload.twi_message_type,
                data: data
            });
        }
        throw new Error('Provided push notification payload is not Programmable Chat notification');
    }
    /**
     * Handle push notification payload parsing and emit the {@link Client.pushNotification} event on this {@link Client} instance.
     * @param notificationPayload Push notification payload
     */
    async handlePushNotification(notificationPayload) {
        await this._ensureReady;
        log.debug('handlePushNotification, notificationPayload=', notificationPayload);
        this.emit('pushNotification', Client_1.parsePushNotification(notificationPayload));
    }
    /**
     * Gets a user with the given identity. If it's in the subscribed list, then return the user object from it;
     * if not, then subscribe and add user to the subscribed list.
     * @param identity Identity of the user.
     * @returns A fully initialized user.
     */
    async getUser(identity) {
        await this._ensureReady;
        return await this.services.users.getUser(identity);
    }
    /**
     * Gets the user descriptor for given identity.
     * @param identity Identity of the user.
     * @returns The user descriptor.
     */
    async getUserDescriptor(identity) {
        await this._ensureReady;
        return await this.services.users.getUserDescriptor(identity);
    }
    /**
     * Get a list of subscribed user objects.
     */
    async getSubscribedUsers() {
        await this._ensureReady;
        return await this.services.users.getSubscribedUsers();
    }
};
/**
 * Current version of the Chat client.
 */
exports.Client.version = SDK_VERSION;
exports.Client.supportedPushChannels = ['fcm', 'apn'];
exports.Client.supportedPushDataFields = {
    'channel_sid': 'channelSid',
    'message_sid': 'messageSid',
    'message_index': 'messageIndex'
};
/**
 * Fired when a channel becomes visible to the client. The event is also triggered when the client creates a new channel.
 * Fired for all channels client has joined.
 *
 * Parameters:
 * 1. {@link Channel} `channel` - the channel in question
 * @event
 */
exports.Client.channelAdded = 'channelAdded';
/**
 * Fired when the client gets invited to a channel.
 *
 * Parameters:
 * 1. {@link Channel} `channel` - the channel in question
 * @event
 */
exports.Client.channelInvited = 'channelInvited';
/**
 * Fired when the client joins a channel.
 *
 * Parameters:
 * 1. {@link Channel} `channel` - the channel in question
 * @event
 */
exports.Client.channelJoined = 'channelJoined';
/**
 * Fired when the client leaves a channel.
 *
 * Parameters:
 * 1. {@link Channel} `channel` - the channel in question
 * @event
 */
exports.Client.channelLeft = 'channelLeft';
/**
 * Fired when a channel is no longer visible to the client.
 *
 * Parameters:
 * 1. {@link Channel} `channel` - the channel in question
 * @event
 */
exports.Client.channelRemoved = 'channelRemoved';
/**
 * Fired when the attributes or the metadata of a channel have been updated.
 * During channel's {@link Client.constructor| creation and initialization}, this event might be fired multiple times
 * for same joined or created channel as new data is arriving from different sources.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Channel} `channel` - the channel in question
 *     * {@link ChannelUpdateReason}[] `updateReasons` - array of reasons for the update
 * @event
 */
exports.Client.channelUpdated = 'channelUpdated';
/**
 * Fired when a member has joined a channel.
 *
 * Parameters:
 * 1. {@link Member} `member` - the member in question
 * @event
 */
exports.Client.memberJoined = 'memberJoined';
/**
 * Fired when a member has left a channel.
 *
 * Parameters:
 * 1. {@link Member} `member` - the member in question
 * @event
 */
exports.Client.memberLeft = 'memberLeft';
/**
 * Fired when a member's fields have been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Member} `member` - the member in question
 *     * {@link MemberUpdateReason}[] `updateReasons` - array of reasons for the update
 * @event
 */
exports.Client.memberUpdated = 'memberUpdated';
/**
 * Fired when a new message has been added to the channel on the server.
 *
 * Parameters:
 * 1. {@link Message} `message` - the message in question
 * @event
 */
exports.Client.messageAdded = 'messageAdded';
/**
 * Fired when a message is removed from the message list of a channel.
 *
 * Parameters:
 * 1. {@link Message} `message` - the message in question
 * @event
 */
exports.Client.messageRemoved = 'messageRemoved';
/**
 * Fired when the fields of an existing message are updated with new values.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Message} `message` - the message in question
 *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for the update
 * @event
 */
exports.Client.messageUpdated = 'messageUpdated';
/**
 * Fired when the token is about to expire and needs to be updated.
 *
 * * Parameters:
 * 1. number `ttl` - token's time to live
 * @event
 */
exports.Client.tokenAboutToExpire = 'tokenAboutToExpire';
/**
 * Fired when the token has expired.
 * @event
 */
exports.Client.tokenExpired = 'tokenExpired';
/**
 * Fired when a member has stopped typing.
 *
 * Parameters:
 * 1. {@link Member} `member` - the member in question
 * @event
 */
exports.Client.typingEnded = 'typingEnded';
/**
 * Fired when a member has started typing.
 *
 * Parameters:
 * 1. {@link Member} `member` - the member in question
 * @event
 */
exports.Client.typingStarted = 'typingStarted';
/**
 * Fired when the client has received (and parsed) a push notification via one of the push channels (apn or fcm).
 *
 * Parameters:
 * 1. {@link PushNotification} `pushNotification` - the push notification in question
 * @event
 */
exports.Client.pushNotification = 'pushNotification';
/**
 * Fired when the client has subscribed to a user.
 *
 * Parameters:
 * 1. {@link User} `user` - the user in question
 * @event
 */
exports.Client.userSubscribed = 'userSubscribed';
/**
 * Fired when the client has unsubscribed from a user.
 *
 * Parameters:
 * 1. {@link User} `user` - the user in question
 * @event
 */
exports.Client.userUnsubscribed = 'userUnsubscribed';
/**
 * Fired when the properties or the reachability status of a user have been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link User} `user` - the user in question
 *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
 * @event
 */
exports.Client.userUpdated = 'userUpdated';
/**
 * Fired when the connection is interrupted for an unexpected reason.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * boolean `terminal` - Twilsock will stop connection attempts if true
 *     * string `message` - the error message of the root cause
 *     * number? `httpStatusCode` - http status code if available
 *     * number? `errorCode` - Twilio public error code if available
 * @event
 */
exports.Client.connectionError = 'connectionError';
/**
 * Fired when the state of the client has been changed.
 *
 * Parameters:
 * 1. {@link State} `state` - the new client state
 * @event
 */
exports.Client.stateChanged = 'stateChanged';
/**
 * Fired when the connection state of the client has been changed.
 *
 * Parameters:
 * 1. {@link ConnectionState} `connectionState` - the updated connection state
 * @event
 */
exports.Client.connectionStateChanged = 'connectionStateChanged';
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "updateToken", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "getChannelBySid", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "getChannelByUniqueName", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        declarativeTypeValidator.objectSchema('sorting options', {
            criteria: [declarativeTypeValidator.literal('lastMessage', 'friendlyName', 'uniqueName'), 'undefined'],
            order: [declarativeTypeValidator.literal('ascending', 'descending'), 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "getLocalChannels", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        declarativeTypeValidator.objectSchema('channel options', {
            friendlyName: ['string', 'undefined'],
            isPrivate: ['boolean', 'undefined'],
            uniqueName: ['string', 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "createChannel", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal('fcm', 'apn'), 'string'),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String, String]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "setPushRegistrationId", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal('fcm', 'apn')),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "unsetPushRegistrationId", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "handlePushNotification", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "getUser", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], exports.Client.prototype, "getUserDescriptor", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypes(declarativeTypeValidator.pureObject),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", pushnotification.PushNotification)
], exports.Client, "parsePushNotification", null);
exports.Client = Client_1 = tslib_es6.__decorate([
    declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [
        declarativeTypeValidator.pureObject,
        'undefined',
        declarativeTypeValidator.literal(null),
    ]),
    tslib_es6.__metadata("design:paramtypes", [String, Object])
], exports.Client);
//# sourceMappingURL=client.js.map
